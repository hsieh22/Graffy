"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/matter-js@0.19.0";
exports.ids = ["vendor-chunks/matter-js@0.19.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/matter-js@0.19.0/node_modules/matter-js/build/matter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/matter-js@0.19.0/node_modules/matter-js/build/matter.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n/*!\n * matter-js 0.19.0 by @liabru\n * http://brm.io/matter-js/\n * License MIT\n * \n * The MIT License (MIT)\n * \n * Copyright (c) Liam Brummitt and contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(void 0, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_1821__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_1821__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_1821__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_1821__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_1821__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_1821__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_1821__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_1821__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_1821__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_1821__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_1821__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_1821__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_1821__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_1821__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_1821__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_1821__(__nested_webpack_require_1821__.s = 20);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1) {\n            /**\n* The `Matter.Common` module contains utility functions that are common to all modules.\n*\n* @class Common\n*/ var Common = {};\n            module1.exports = Common;\n            (function() {\n                Common._baseDelta = 1000 / 60;\n                Common._nextId = 0;\n                Common._seed = 0;\n                Common._nowStartTime = +new Date();\n                Common._warnedOnce = {};\n                Common._decomp = null;\n                /**\n     * Extends the object in the first argument using the object in the second argument.\n     * @method extend\n     * @param {} obj\n     * @param {boolean} deep\n     * @return {} obj extended\n     */ Common.extend = function(obj, deep) {\n                    var argsStart, args, deepClone;\n                    if (typeof deep === \"boolean\") {\n                        argsStart = 2;\n                        deepClone = deep;\n                    } else {\n                        argsStart = 1;\n                        deepClone = true;\n                    }\n                    for(var i = argsStart; i < arguments.length; i++){\n                        var source = arguments[i];\n                        if (source) {\n                            for(var prop in source){\n                                if (deepClone && source[prop] && source[prop].constructor === Object) {\n                                    if (!obj[prop] || obj[prop].constructor === Object) {\n                                        obj[prop] = obj[prop] || {};\n                                        Common.extend(obj[prop], deepClone, source[prop]);\n                                    } else {\n                                        obj[prop] = source[prop];\n                                    }\n                                } else {\n                                    obj[prop] = source[prop];\n                                }\n                            }\n                        }\n                    }\n                    return obj;\n                };\n                /**\n     * Creates a new clone of the object, if deep is true references will also be cloned.\n     * @method clone\n     * @param {} obj\n     * @param {bool} deep\n     * @return {} obj cloned\n     */ Common.clone = function(obj, deep) {\n                    return Common.extend({}, deep, obj);\n                };\n                /**\n     * Returns the list of keys for the given object.\n     * @method keys\n     * @param {} obj\n     * @return {string[]} keys\n     */ Common.keys = function(obj) {\n                    if (Object.keys) return Object.keys(obj);\n                    // avoid hasOwnProperty for performance\n                    var keys = [];\n                    for(var key in obj)keys.push(key);\n                    return keys;\n                };\n                /**\n     * Returns the list of values for the given object.\n     * @method values\n     * @param {} obj\n     * @return {array} Array of the objects property values\n     */ Common.values = function(obj) {\n                    var values = [];\n                    if (Object.keys) {\n                        var keys = Object.keys(obj);\n                        for(var i = 0; i < keys.length; i++){\n                            values.push(obj[keys[i]]);\n                        }\n                        return values;\n                    }\n                    // avoid hasOwnProperty for performance\n                    for(var key in obj)values.push(obj[key]);\n                    return values;\n                };\n                /**\n     * Gets a value from `base` relative to the `path` string.\n     * @method get\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} The object at the given path\n     */ Common.get = function(obj, path, begin, end) {\n                    path = path.split(\".\").slice(begin, end);\n                    for(var i = 0; i < path.length; i += 1){\n                        obj = obj[path[i]];\n                    }\n                    return obj;\n                };\n                /**\n     * Sets a value on `base` relative to the given `path` string.\n     * @method set\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {} val The value to set\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} Pass through `val` for chaining\n     */ Common.set = function(obj, path, val, begin, end) {\n                    var parts = path.split(\".\").slice(begin, end);\n                    Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\n                    return val;\n                };\n                /**\n     * Shuffles the given array in-place.\n     * The function uses a seeded random generator.\n     * @method shuffle\n     * @param {array} array\n     * @return {array} array shuffled randomly\n     */ Common.shuffle = function(array) {\n                    for(var i = array.length - 1; i > 0; i--){\n                        var j = Math.floor(Common.random() * (i + 1));\n                        var temp = array[i];\n                        array[i] = array[j];\n                        array[j] = temp;\n                    }\n                    return array;\n                };\n                /**\n     * Randomly chooses a value from a list with equal probability.\n     * The function uses a seeded random generator.\n     * @method choose\n     * @param {array} choices\n     * @return {object} A random choice object from the array\n     */ Common.choose = function(choices) {\n                    return choices[Math.floor(Common.random() * choices.length)];\n                };\n                /**\n     * Returns true if the object is a HTMLElement, otherwise false.\n     * @method isElement\n     * @param {object} obj\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\n     */ Common.isElement = function(obj) {\n                    if (typeof HTMLElement !== \"undefined\") {\n                        return obj instanceof HTMLElement;\n                    }\n                    return !!(obj && obj.nodeType && obj.nodeName);\n                };\n                /**\n     * Returns true if the object is an array.\n     * @method isArray\n     * @param {object} obj\n     * @return {boolean} True if the object is an array, otherwise false\n     */ Common.isArray = function(obj) {\n                    return Object.prototype.toString.call(obj) === \"[object Array]\";\n                };\n                /**\n     * Returns true if the object is a function.\n     * @method isFunction\n     * @param {object} obj\n     * @return {boolean} True if the object is a function, otherwise false\n     */ Common.isFunction = function(obj) {\n                    return typeof obj === \"function\";\n                };\n                /**\n     * Returns true if the object is a plain object.\n     * @method isPlainObject\n     * @param {object} obj\n     * @return {boolean} True if the object is a plain object, otherwise false\n     */ Common.isPlainObject = function(obj) {\n                    return typeof obj === \"object\" && obj.constructor === Object;\n                };\n                /**\n     * Returns true if the object is a string.\n     * @method isString\n     * @param {object} obj\n     * @return {boolean} True if the object is a string, otherwise false\n     */ Common.isString = function(obj) {\n                    return toString.call(obj) === \"[object String]\";\n                };\n                /**\n     * Returns the given value clamped between a minimum and maximum value.\n     * @method clamp\n     * @param {number} value\n     * @param {number} min\n     * @param {number} max\n     * @return {number} The value clamped between min and max inclusive\n     */ Common.clamp = function(value, min, max) {\n                    if (value < min) return min;\n                    if (value > max) return max;\n                    return value;\n                };\n                /**\n     * Returns the sign of the given value.\n     * @method sign\n     * @param {number} value\n     * @return {number} -1 if negative, +1 if 0 or positive\n     */ Common.sign = function(value) {\n                    return value < 0 ? -1 : 1;\n                };\n                /**\n     * Returns the current timestamp since the time origin (e.g. from page load).\n     * The result is in milliseconds and will use high-resolution timing if available.\n     * @method now\n     * @return {number} the current timestamp in milliseconds\n     */ Common.now = function() {\n                    if (false) {}\n                    if (Date.now) {\n                        return Date.now();\n                    }\n                    return new Date() - Common._nowStartTime;\n                };\n                /**\n     * Returns a random value between a minimum and a maximum value inclusive.\n     * The function uses a seeded random generator.\n     * @method random\n     * @param {number} min\n     * @param {number} max\n     * @return {number} A random number between min and max inclusive\n     */ Common.random = function(min, max) {\n                    min = typeof min !== \"undefined\" ? min : 0;\n                    max = typeof max !== \"undefined\" ? max : 1;\n                    return min + _seededRandom() * (max - min);\n                };\n                var _seededRandom = function() {\n                    // https://en.wikipedia.org/wiki/Linear_congruential_generator\n                    Common._seed = (Common._seed * 9301 + 49297) % 233280;\n                    return Common._seed / 233280;\n                };\n                /**\n     * Converts a CSS hex colour string into an integer.\n     * @method colorToNumber\n     * @param {string} colorString\n     * @return {number} An integer representing the CSS hex string\n     */ Common.colorToNumber = function(colorString) {\n                    colorString = colorString.replace(\"#\", \"\");\n                    if (colorString.length == 3) {\n                        colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);\n                    }\n                    return parseInt(colorString, 16);\n                };\n                /**\n     * The console logging level to use, where each level includes all levels above and excludes the levels below.\n     * The default level is 'debug' which shows all console messages.  \n     *\n     * Possible level values are:\n     * - 0 = None\n     * - 1 = Debug\n     * - 2 = Info\n     * - 3 = Warn\n     * - 4 = Error\n     * @static\n     * @property logLevel\n     * @type {Number}\n     * @default 1\n     */ Common.logLevel = 1;\n                /**\n     * Shows a `console.log` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method log\n     * @param ...objs {} The objects to log.\n     */ Common.log = function() {\n                    if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n                        console.log.apply(console, [\n                            \"matter-js:\"\n                        ].concat(Array.prototype.slice.call(arguments)));\n                    }\n                };\n                /**\n     * Shows a `console.info` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method info\n     * @param ...objs {} The objects to log.\n     */ Common.info = function() {\n                    if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\n                        console.info.apply(console, [\n                            \"matter-js:\"\n                        ].concat(Array.prototype.slice.call(arguments)));\n                    }\n                };\n                /**\n     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method warn\n     * @param ...objs {} The objects to log.\n     */ Common.warn = function() {\n                    if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n                        console.warn.apply(console, [\n                            \"matter-js:\"\n                        ].concat(Array.prototype.slice.call(arguments)));\n                    }\n                };\n                /**\n     * Uses `Common.warn` to log the given message one time only.\n     * @method warnOnce\n     * @param ...objs {} The objects to log.\n     */ Common.warnOnce = function() {\n                    var message = Array.prototype.slice.call(arguments).join(\" \");\n                    if (!Common._warnedOnce[message]) {\n                        Common.warn(message);\n                        Common._warnedOnce[message] = true;\n                    }\n                };\n                /**\n     * Shows a deprecated console warning when the function on the given object is called.\n     * The target function will be replaced with a new function that first shows the warning\n     * and then calls the original function.\n     * @method deprecated\n     * @param {object} obj The object or module\n     * @param {string} name The property name of the function on obj\n     * @param {string} warning The one-time message to show if the function is called\n     */ Common.deprecated = function(obj, prop, warning) {\n                    obj[prop] = Common.chain(function() {\n                        Common.warnOnce(\"\\uD83D\\uDD05 deprecated \\uD83D\\uDD05\", warning);\n                    }, obj[prop]);\n                };\n                /**\n     * Returns the next unique sequential ID.\n     * @method nextId\n     * @return {Number} Unique sequential ID\n     */ Common.nextId = function() {\n                    return Common._nextId++;\n                };\n                /**\n     * A cross browser compatible indexOf implementation.\n     * @method indexOf\n     * @param {array} haystack\n     * @param {object} needle\n     * @return {number} The position of needle in haystack, otherwise -1.\n     */ Common.indexOf = function(haystack, needle) {\n                    if (haystack.indexOf) return haystack.indexOf(needle);\n                    for(var i = 0; i < haystack.length; i++){\n                        if (haystack[i] === needle) return i;\n                    }\n                    return -1;\n                };\n                /**\n     * A cross browser compatible array map implementation.\n     * @method map\n     * @param {array} list\n     * @param {function} func\n     * @return {array} Values from list transformed by func.\n     */ Common.map = function(list, func) {\n                    if (list.map) {\n                        return list.map(func);\n                    }\n                    var mapped = [];\n                    for(var i = 0; i < list.length; i += 1){\n                        mapped.push(func(list[i]));\n                    }\n                    return mapped;\n                };\n                /**\n     * Takes a directed graph and returns the partially ordered set of vertices in topological order.\n     * Circular dependencies are allowed.\n     * @method topologicalSort\n     * @param {object} graph\n     * @return {array} Partially ordered set of vertices in topological order.\n     */ Common.topologicalSort = function(graph) {\n                    // https://github.com/mgechev/javascript-algorithms\n                    // Copyright (c) Minko Gechev (MIT license)\n                    // Modifications: tidy formatting and naming\n                    var result = [], visited = [], temp = [];\n                    for(var node in graph){\n                        if (!visited[node] && !temp[node]) {\n                            Common._topologicalSort(node, visited, temp, graph, result);\n                        }\n                    }\n                    return result;\n                };\n                Common._topologicalSort = function(node, visited, temp, graph, result) {\n                    var neighbors = graph[node] || [];\n                    temp[node] = true;\n                    for(var i = 0; i < neighbors.length; i += 1){\n                        var neighbor = neighbors[i];\n                        if (temp[neighbor]) {\n                            continue;\n                        }\n                        if (!visited[neighbor]) {\n                            Common._topologicalSort(neighbor, visited, temp, graph, result);\n                        }\n                    }\n                    temp[node] = false;\n                    visited[node] = true;\n                    result.push(node);\n                };\n                /**\n     * Takes _n_ functions as arguments and returns a new function that calls them in order.\n     * The arguments applied when calling the new function will also be applied to every function passed.\n     * The value of `this` refers to the last value returned in the chain that was not `undefined`.\n     * Therefore if a passed function does not return a value, the previously returned value is maintained.\n     * After all passed functions have been called the new function returns the last returned value (if any).\n     * If any of the passed functions are a chain, then the chain will be flattened.\n     * @method chain\n     * @param ...funcs {function} The functions to chain.\n     * @return {function} A new function that calls the passed functions in order.\n     */ Common.chain = function() {\n                    var funcs = [];\n                    for(var i = 0; i < arguments.length; i += 1){\n                        var func = arguments[i];\n                        if (func._chained) {\n                            // flatten already chained functions\n                            funcs.push.apply(funcs, func._chained);\n                        } else {\n                            funcs.push(func);\n                        }\n                    }\n                    var chain = function() {\n                        // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\n                        var lastResult, args = new Array(arguments.length);\n                        for(var i = 0, l = arguments.length; i < l; i++){\n                            args[i] = arguments[i];\n                        }\n                        for(i = 0; i < funcs.length; i += 1){\n                            var result = funcs[i].apply(lastResult, args);\n                            if (typeof result !== \"undefined\") {\n                                lastResult = result;\n                            }\n                        }\n                        return lastResult;\n                    };\n                    chain._chained = funcs;\n                    return chain;\n                };\n                /**\n     * Chains a function to excute before the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathBefore\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain before the original\n     * @return {function} The chained function that replaced the original\n     */ Common.chainPathBefore = function(base, path, func) {\n                    return Common.set(base, path, Common.chain(func, Common.get(base, path)));\n                };\n                /**\n     * Chains a function to excute after the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathAfter\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain after the original\n     * @return {function} The chained function that replaced the original\n     */ Common.chainPathAfter = function(base, path, func) {\n                    return Common.set(base, path, Common.chain(Common.get(base, path), func));\n                };\n                /**\n     * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable\n     * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require('poly-decomp'))`.\n     * @method setDecomp\n     * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module.\n     */ Common.setDecomp = function(decomp) {\n                    Common._decomp = decomp;\n                };\n                /**\n     * Returns the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module provided through `Common.setDecomp`,\n     * otherwise returns the global `decomp` if set.\n     * @method getDecomp\n     * @return {} The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module if provided.\n     */ Common.getDecomp = function() {\n                    // get user provided decomp if set\n                    var decomp = Common._decomp;\n                    try {\n                        // otherwise from window global\n                        if (!decomp && \"undefined\" !== \"undefined\") {}\n                        // otherwise from node global\n                        if (!decomp && typeof global !== \"undefined\") {\n                            decomp = global.decomp;\n                        }\n                    } catch (e) {\n                        // decomp not available\n                        decomp = null;\n                    }\n                    return decomp;\n                };\n            })();\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1) {\n            /**\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\n*\n* @class Bounds\n*/ var Bounds = {};\n            module1.exports = Bounds;\n            (function() {\n                /**\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\n     * @method create\n     * @param {vertices} vertices\n     * @return {bounds} A new bounds object\n     */ Bounds.create = function(vertices) {\n                    var bounds = {\n                        min: {\n                            x: 0,\n                            y: 0\n                        },\n                        max: {\n                            x: 0,\n                            y: 0\n                        }\n                    };\n                    if (vertices) Bounds.update(bounds, vertices);\n                    return bounds;\n                };\n                /**\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\n     * @method update\n     * @param {bounds} bounds\n     * @param {vertices} vertices\n     * @param {vector} velocity\n     */ Bounds.update = function(bounds, vertices, velocity) {\n                    bounds.min.x = Infinity;\n                    bounds.max.x = -Infinity;\n                    bounds.min.y = Infinity;\n                    bounds.max.y = -Infinity;\n                    for(var i = 0; i < vertices.length; i++){\n                        var vertex = vertices[i];\n                        if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n                        if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n                        if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n                        if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n                    }\n                    if (velocity) {\n                        if (velocity.x > 0) {\n                            bounds.max.x += velocity.x;\n                        } else {\n                            bounds.min.x += velocity.x;\n                        }\n                        if (velocity.y > 0) {\n                            bounds.max.y += velocity.y;\n                        } else {\n                            bounds.min.y += velocity.y;\n                        }\n                    }\n                };\n                /**\n     * Returns true if the bounds contains the given point.\n     * @method contains\n     * @param {bounds} bounds\n     * @param {vector} point\n     * @return {boolean} True if the bounds contain the point, otherwise false\n     */ Bounds.contains = function(bounds, point) {\n                    return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;\n                };\n                /**\n     * Returns true if the two bounds intersect.\n     * @method overlaps\n     * @param {bounds} boundsA\n     * @param {bounds} boundsB\n     * @return {boolean} True if the bounds overlap, otherwise false\n     */ Bounds.overlaps = function(boundsA, boundsB) {\n                    return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;\n                };\n                /**\n     * Translates the bounds by the given vector.\n     * @method translate\n     * @param {bounds} bounds\n     * @param {vector} vector\n     */ Bounds.translate = function(bounds, vector) {\n                    bounds.min.x += vector.x;\n                    bounds.max.x += vector.x;\n                    bounds.min.y += vector.y;\n                    bounds.max.y += vector.y;\n                };\n                /**\n     * Shifts the bounds to the given position.\n     * @method shift\n     * @param {bounds} bounds\n     * @param {vector} position\n     */ Bounds.shift = function(bounds, position) {\n                    var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;\n                    bounds.min.x = position.x;\n                    bounds.max.x = position.x + deltaX;\n                    bounds.min.y = position.y;\n                    bounds.max.y = position.y + deltaY;\n                };\n            })();\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1) {\n            /**\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\n* Vectors are the basis of all the geometry related operations in the engine.\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vector\n*/ // TODO: consider params for reusing vector objects\n            var Vector = {};\n            module1.exports = Vector;\n            (function() {\n                /**\n     * Creates a new vector.\n     * @method create\n     * @param {number} x\n     * @param {number} y\n     * @return {vector} A new vector\n     */ Vector.create = function(x, y) {\n                    return {\n                        x: x || 0,\n                        y: y || 0\n                    };\n                };\n                /**\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\n     * @method clone\n     * @param {vector} vector\n     * @return {vector} A new cloned vector\n     */ Vector.clone = function(vector) {\n                    return {\n                        x: vector.x,\n                        y: vector.y\n                    };\n                };\n                /**\n     * Returns the magnitude (length) of a vector.\n     * @method magnitude\n     * @param {vector} vector\n     * @return {number} The magnitude of the vector\n     */ Vector.magnitude = function(vector) {\n                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n                };\n                /**\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\n     * @method magnitudeSquared\n     * @param {vector} vector\n     * @return {number} The squared magnitude of the vector\n     */ Vector.magnitudeSquared = function(vector) {\n                    return vector.x * vector.x + vector.y * vector.y;\n                };\n                /**\n     * Rotates the vector about (0, 0) by specified angle.\n     * @method rotate\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} [output]\n     * @return {vector} The vector rotated about (0, 0)\n     */ Vector.rotate = function(vector, angle, output) {\n                    var cos = Math.cos(angle), sin = Math.sin(angle);\n                    if (!output) output = {};\n                    var x = vector.x * cos - vector.y * sin;\n                    output.y = vector.x * sin + vector.y * cos;\n                    output.x = x;\n                    return output;\n                };\n                /**\n     * Rotates the vector about a specified point by specified angle.\n     * @method rotateAbout\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} point\n     * @param {vector} [output]\n     * @return {vector} A new vector rotated about the point\n     */ Vector.rotateAbout = function(vector, angle, point, output) {\n                    var cos = Math.cos(angle), sin = Math.sin(angle);\n                    if (!output) output = {};\n                    var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);\n                    output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);\n                    output.x = x;\n                    return output;\n                };\n                /**\n     * Normalises a vector (such that its magnitude is `1`).\n     * @method normalise\n     * @param {vector} vector\n     * @return {vector} A new vector normalised\n     */ Vector.normalise = function(vector) {\n                    var magnitude = Vector.magnitude(vector);\n                    if (magnitude === 0) return {\n                        x: 0,\n                        y: 0\n                    };\n                    return {\n                        x: vector.x / magnitude,\n                        y: vector.y / magnitude\n                    };\n                };\n                /**\n     * Returns the dot-product of two vectors.\n     * @method dot\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The dot product of the two vectors\n     */ Vector.dot = function(vectorA, vectorB) {\n                    return vectorA.x * vectorB.x + vectorA.y * vectorB.y;\n                };\n                /**\n     * Returns the cross-product of two vectors.\n     * @method cross\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The cross product of the two vectors\n     */ Vector.cross = function(vectorA, vectorB) {\n                    return vectorA.x * vectorB.y - vectorA.y * vectorB.x;\n                };\n                /**\n     * Returns the cross-product of three vectors.\n     * @method cross3\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} vectorC\n     * @return {number} The cross product of the three vectors\n     */ Vector.cross3 = function(vectorA, vectorB, vectorC) {\n                    return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);\n                };\n                /**\n     * Adds the two vectors.\n     * @method add\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB added\n     */ Vector.add = function(vectorA, vectorB, output) {\n                    if (!output) output = {};\n                    output.x = vectorA.x + vectorB.x;\n                    output.y = vectorA.y + vectorB.y;\n                    return output;\n                };\n                /**\n     * Subtracts the two vectors.\n     * @method sub\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB subtracted\n     */ Vector.sub = function(vectorA, vectorB, output) {\n                    if (!output) output = {};\n                    output.x = vectorA.x - vectorB.x;\n                    output.y = vectorA.y - vectorB.y;\n                    return output;\n                };\n                /**\n     * Multiplies a vector and a scalar.\n     * @method mult\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector multiplied by scalar\n     */ Vector.mult = function(vector, scalar) {\n                    return {\n                        x: vector.x * scalar,\n                        y: vector.y * scalar\n                    };\n                };\n                /**\n     * Divides a vector and a scalar.\n     * @method div\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector divided by scalar\n     */ Vector.div = function(vector, scalar) {\n                    return {\n                        x: vector.x / scalar,\n                        y: vector.y / scalar\n                    };\n                };\n                /**\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\n     * @method perp\n     * @param {vector} vector\n     * @param {bool} [negate=false]\n     * @return {vector} The perpendicular vector\n     */ Vector.perp = function(vector, negate) {\n                    negate = negate === true ? -1 : 1;\n                    return {\n                        x: negate * -vector.y,\n                        y: negate * vector.x\n                    };\n                };\n                /**\n     * Negates both components of a vector such that it points in the opposite direction.\n     * @method neg\n     * @param {vector} vector\n     * @return {vector} The negated vector\n     */ Vector.neg = function(vector) {\n                    return {\n                        x: -vector.x,\n                        y: -vector.y\n                    };\n                };\n                /**\n     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.\n     * @method angle\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The angle in radians\n     */ Vector.angle = function(vectorA, vectorB) {\n                    return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\n                };\n                /**\n     * Temporary vector pool (not thread-safe).\n     * @property _temp\n     * @type {vector[]}\n     * @private\n     */ Vector._temp = [\n                    Vector.create(),\n                    Vector.create(),\n                    Vector.create(),\n                    Vector.create(),\n                    Vector.create(),\n                    Vector.create()\n                ];\n            })();\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_41208__) {\n            /**\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vertices\n*/ var Vertices = {};\n            module1.exports = Vertices;\n            var Vector = __nested_webpack_require_41208__(2);\n            var Common = __nested_webpack_require_41208__(0);\n            (function() {\n                /**\n     * Creates a new set of `Matter.Body` compatible vertices.\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\n     * but with some additional references required for efficient collision detection routines.\n     *\n     * Vertices must be specified in clockwise order.\n     *\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\n     *\n     * @method create\n     * @param {vector[]} points\n     * @param {body} body\n     */ Vertices.create = function(points, body) {\n                    var vertices = [];\n                    for(var i = 0; i < points.length; i++){\n                        var point = points[i], vertex = {\n                            x: point.x,\n                            y: point.y,\n                            index: i,\n                            body: body,\n                            isInternal: false\n                        };\n                        vertices.push(vertex);\n                    }\n                    return vertices;\n                };\n                /**\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \n     * into a `Matter.Vertices` object for the given `Matter.Body`.\n     * For parsing SVG paths, see `Svg.pathToVertices`.\n     * @method fromPath\n     * @param {string} path\n     * @param {body} body\n     * @return {vertices} vertices\n     */ Vertices.fromPath = function(path, body) {\n                    var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig, points = [];\n                    path.replace(pathPattern, function(match, x, y) {\n                        points.push({\n                            x: parseFloat(x),\n                            y: parseFloat(y)\n                        });\n                    });\n                    return Vertices.create(points, body);\n                };\n                /**\n     * Returns the centre (centroid) of the set of vertices.\n     * @method centre\n     * @param {vertices} vertices\n     * @return {vector} The centre point\n     */ Vertices.centre = function(vertices) {\n                    var area = Vertices.area(vertices, true), centre = {\n                        x: 0,\n                        y: 0\n                    }, cross, temp, j;\n                    for(var i = 0; i < vertices.length; i++){\n                        j = (i + 1) % vertices.length;\n                        cross = Vector.cross(vertices[i], vertices[j]);\n                        temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n                        centre = Vector.add(centre, temp);\n                    }\n                    return Vector.div(centre, 6 * area);\n                };\n                /**\n     * Returns the average (mean) of the set of vertices.\n     * @method mean\n     * @param {vertices} vertices\n     * @return {vector} The average point\n     */ Vertices.mean = function(vertices) {\n                    var average = {\n                        x: 0,\n                        y: 0\n                    };\n                    for(var i = 0; i < vertices.length; i++){\n                        average.x += vertices[i].x;\n                        average.y += vertices[i].y;\n                    }\n                    return Vector.div(average, vertices.length);\n                };\n                /**\n     * Returns the area of the set of vertices.\n     * @method area\n     * @param {vertices} vertices\n     * @param {bool} signed\n     * @return {number} The area\n     */ Vertices.area = function(vertices, signed) {\n                    var area = 0, j = vertices.length - 1;\n                    for(var i = 0; i < vertices.length; i++){\n                        area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n                        j = i;\n                    }\n                    if (signed) return area / 2;\n                    return Math.abs(area) / 2;\n                };\n                /**\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\n     * @method inertia\n     * @param {vertices} vertices\n     * @param {number} mass\n     * @return {number} The polygon's moment of inertia\n     */ Vertices.inertia = function(vertices, mass) {\n                    var numerator = 0, denominator = 0, v = vertices, cross, j;\n                    // find the polygon's moment of inertia, using second moment of area\n                    // from equations at http://www.physicsforums.com/showthread.php?t=25293\n                    for(var n = 0; n < v.length; n++){\n                        j = (n + 1) % v.length;\n                        cross = Math.abs(Vector.cross(v[j], v[n]));\n                        numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n                        denominator += cross;\n                    }\n                    return mass / 6 * (numerator / denominator);\n                };\n                /**\n     * Translates the set of vertices in-place.\n     * @method translate\n     * @param {vertices} vertices\n     * @param {vector} vector\n     * @param {number} scalar\n     */ Vertices.translate = function(vertices, vector, scalar) {\n                    scalar = typeof scalar !== \"undefined\" ? scalar : 1;\n                    var verticesLength = vertices.length, translateX = vector.x * scalar, translateY = vector.y * scalar, i;\n                    for(i = 0; i < verticesLength; i++){\n                        vertices[i].x += translateX;\n                        vertices[i].y += translateY;\n                    }\n                    return vertices;\n                };\n                /**\n     * Rotates the set of vertices in-place.\n     * @method rotate\n     * @param {vertices} vertices\n     * @param {number} angle\n     * @param {vector} point\n     */ Vertices.rotate = function(vertices, angle, point) {\n                    if (angle === 0) return;\n                    var cos = Math.cos(angle), sin = Math.sin(angle), pointX = point.x, pointY = point.y, verticesLength = vertices.length, vertex, dx, dy, i;\n                    for(i = 0; i < verticesLength; i++){\n                        vertex = vertices[i];\n                        dx = vertex.x - pointX;\n                        dy = vertex.y - pointY;\n                        vertex.x = pointX + (dx * cos - dy * sin);\n                        vertex.y = pointY + (dx * sin + dy * cos);\n                    }\n                    return vertices;\n                };\n                /**\n     * Returns `true` if the `point` is inside the set of `vertices`.\n     * @method contains\n     * @param {vertices} vertices\n     * @param {vector} point\n     * @return {boolean} True if the vertices contains point, otherwise false\n     */ Vertices.contains = function(vertices, point) {\n                    var pointX = point.x, pointY = point.y, verticesLength = vertices.length, vertex = vertices[verticesLength - 1], nextVertex;\n                    for(var i = 0; i < verticesLength; i++){\n                        nextVertex = vertices[i];\n                        if ((pointX - vertex.x) * (nextVertex.y - vertex.y) + (pointY - vertex.y) * (vertex.x - nextVertex.x) > 0) {\n                            return false;\n                        }\n                        vertex = nextVertex;\n                    }\n                    return true;\n                };\n                /**\n     * Scales the vertices from a point (default is centre) in-place.\n     * @method scale\n     * @param {vertices} vertices\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     */ Vertices.scale = function(vertices, scaleX, scaleY, point) {\n                    if (scaleX === 1 && scaleY === 1) return vertices;\n                    point = point || Vertices.centre(vertices);\n                    var vertex, delta;\n                    for(var i = 0; i < vertices.length; i++){\n                        vertex = vertices[i];\n                        delta = Vector.sub(vertex, point);\n                        vertices[i].x = point.x + delta.x * scaleX;\n                        vertices[i].y = point.y + delta.y * scaleY;\n                    }\n                    return vertices;\n                };\n                /**\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\n     * @method chamfer\n     * @param {vertices} vertices\n     * @param {number[]} radius\n     * @param {number} quality\n     * @param {number} qualityMin\n     * @param {number} qualityMax\n     */ Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\n                    if (typeof radius === \"number\") {\n                        radius = [\n                            radius\n                        ];\n                    } else {\n                        radius = radius || [\n                            8\n                        ];\n                    }\n                    // quality defaults to -1, which is auto\n                    quality = typeof quality !== \"undefined\" ? quality : -1;\n                    qualityMin = qualityMin || 2;\n                    qualityMax = qualityMax || 14;\n                    var newVertices = [];\n                    for(var i = 0; i < vertices.length; i++){\n                        var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1], vertex = vertices[i], nextVertex = vertices[(i + 1) % vertices.length], currentRadius = radius[i < radius.length ? i : radius.length - 1];\n                        if (currentRadius === 0) {\n                            newVertices.push(vertex);\n                            continue;\n                        }\n                        var prevNormal = Vector.normalise({\n                            x: vertex.y - prevVertex.y,\n                            y: prevVertex.x - vertex.x\n                        });\n                        var nextNormal = Vector.normalise({\n                            x: nextVertex.y - vertex.y,\n                            y: vertex.x - nextVertex.x\n                        });\n                        var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n                        var precision = quality;\n                        if (quality === -1) {\n                            // automatically decide precision\n                            precision = Math.pow(currentRadius, 0.32) * 1.75;\n                        }\n                        precision = Common.clamp(precision, qualityMin, qualityMax);\n                        // use an even value for precision, more likely to reduce axes by using symmetry\n                        if (precision % 2 === 1) precision += 1;\n                        var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)), theta = alpha / precision;\n                        for(var j = 0; j < precision; j++){\n                            newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n                        }\n                    }\n                    return newVertices;\n                };\n                /**\n     * Sorts the input vertices into clockwise order in place.\n     * @method clockwiseSort\n     * @param {vertices} vertices\n     * @return {vertices} vertices\n     */ Vertices.clockwiseSort = function(vertices) {\n                    var centre = Vertices.mean(vertices);\n                    vertices.sort(function(vertexA, vertexB) {\n                        return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n                    });\n                    return vertices;\n                };\n                /**\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\n     * @method isConvex\n     * @param {vertices} vertices\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\n     */ Vertices.isConvex = function(vertices) {\n                    // http://paulbourke.net/geometry/polygonmesh/\n                    // Copyright (c) Paul Bourke (use permitted)\n                    var flag = 0, n = vertices.length, i, j, k, z;\n                    if (n < 3) return null;\n                    for(i = 0; i < n; i++){\n                        j = (i + 1) % n;\n                        k = (i + 2) % n;\n                        z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n                        z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n                        if (z < 0) {\n                            flag |= 1;\n                        } else if (z > 0) {\n                            flag |= 2;\n                        }\n                        if (flag === 3) {\n                            return false;\n                        }\n                    }\n                    if (flag !== 0) {\n                        return true;\n                    } else {\n                        return null;\n                    }\n                };\n                /**\n     * Returns the convex hull of the input vertices as a new array of points.\n     * @method hull\n     * @param {vertices} vertices\n     * @return [vertex] vertices\n     */ Vertices.hull = function(vertices) {\n                    // http://geomalgorithms.com/a10-_hull-1.html\n                    var upper = [], lower = [], vertex, i;\n                    // sort vertices on x-axis (y-axis for ties)\n                    vertices = vertices.slice(0);\n                    vertices.sort(function(vertexA, vertexB) {\n                        var dx = vertexA.x - vertexB.x;\n                        return dx !== 0 ? dx : vertexA.y - vertexB.y;\n                    });\n                    // build lower hull\n                    for(i = 0; i < vertices.length; i += 1){\n                        vertex = vertices[i];\n                        while(lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0){\n                            lower.pop();\n                        }\n                        lower.push(vertex);\n                    }\n                    // build upper hull\n                    for(i = vertices.length - 1; i >= 0; i -= 1){\n                        vertex = vertices[i];\n                        while(upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0){\n                            upper.pop();\n                        }\n                        upper.push(vertex);\n                    }\n                    // concatenation of the lower and upper hulls gives the convex hull\n                    // omit last points because they are repeated at the beginning of the other list\n                    upper.pop();\n                    lower.pop();\n                    return upper.concat(lower);\n                };\n            })();\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_57373__) {\n            /**\n* The `Matter.Body` module contains methods for creating and manipulating rigid bodies.\n* For creating bodies with common configurations such as rectangles, circles and other polygons see the module `Matter.Bodies`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n\n* @class Body\n*/ var Body = {};\n            module1.exports = Body;\n            var Vertices = __nested_webpack_require_57373__(3);\n            var Vector = __nested_webpack_require_57373__(2);\n            var Sleeping = __nested_webpack_require_57373__(7);\n            var Common = __nested_webpack_require_57373__(0);\n            var Bounds = __nested_webpack_require_57373__(1);\n            var Axes = __nested_webpack_require_57373__(11);\n            (function() {\n                Body._timeCorrection = true;\n                Body._inertiaScale = 4;\n                Body._nextCollidingGroupId = 1;\n                Body._nextNonCollidingGroupId = -1;\n                Body._nextCategory = 0x0001;\n                Body._baseDelta = 1000 / 60;\n                /**\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * Vertices must be specified in clockwise order.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {body} body\n     */ Body.create = function(options) {\n                    var defaults = {\n                        id: Common.nextId(),\n                        type: \"body\",\n                        label: \"Body\",\n                        parts: [],\n                        plugin: {},\n                        angle: 0,\n                        vertices: Vertices.fromPath(\"L 0 0 L 40 0 L 40 40 L 0 40\"),\n                        position: {\n                            x: 0,\n                            y: 0\n                        },\n                        force: {\n                            x: 0,\n                            y: 0\n                        },\n                        torque: 0,\n                        positionImpulse: {\n                            x: 0,\n                            y: 0\n                        },\n                        constraintImpulse: {\n                            x: 0,\n                            y: 0,\n                            angle: 0\n                        },\n                        totalContacts: 0,\n                        speed: 0,\n                        angularSpeed: 0,\n                        velocity: {\n                            x: 0,\n                            y: 0\n                        },\n                        angularVelocity: 0,\n                        isSensor: false,\n                        isStatic: false,\n                        isSleeping: false,\n                        motion: 0,\n                        sleepThreshold: 60,\n                        density: 0.001,\n                        restitution: 0,\n                        friction: 0.1,\n                        frictionStatic: 0.5,\n                        frictionAir: 0.01,\n                        collisionFilter: {\n                            category: 0x0001,\n                            mask: 0xFFFFFFFF,\n                            group: 0\n                        },\n                        slop: 0.05,\n                        timeScale: 1,\n                        render: {\n                            visible: true,\n                            opacity: 1,\n                            strokeStyle: null,\n                            fillStyle: null,\n                            lineWidth: null,\n                            sprite: {\n                                xScale: 1,\n                                yScale: 1,\n                                xOffset: 0,\n                                yOffset: 0\n                            }\n                        },\n                        events: null,\n                        bounds: null,\n                        chamfer: null,\n                        circleRadius: 0,\n                        positionPrev: null,\n                        anglePrev: 0,\n                        parent: null,\n                        axes: null,\n                        area: 0,\n                        mass: 0,\n                        inertia: 0,\n                        deltaTime: 1000 / 60,\n                        _original: null\n                    };\n                    var body = Common.extend(defaults, options);\n                    _initProperties(body, options);\n                    return body;\n                };\n                /**\n     * Returns the next unique group index for which bodies will collide.\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\n     * See `body.collisionFilter` for more information.\n     * @method nextGroup\n     * @param {bool} [isNonColliding=false]\n     * @return {Number} Unique group index\n     */ Body.nextGroup = function(isNonColliding) {\n                    if (isNonColliding) return Body._nextNonCollidingGroupId--;\n                    return Body._nextCollidingGroupId++;\n                };\n                /**\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\n     * There are 32 available. See `body.collisionFilter` for more information.\n     * @method nextCategory\n     * @return {Number} Unique category bitfield\n     */ Body.nextCategory = function() {\n                    Body._nextCategory = Body._nextCategory << 1;\n                    return Body._nextCategory;\n                };\n                /**\n     * Initialises body properties.\n     * @method _initProperties\n     * @private\n     * @param {body} body\n     * @param {} [options]\n     */ var _initProperties = function(body, options) {\n                    options = options || {};\n                    // init required properties (order is important)\n                    Body.set(body, {\n                        bounds: body.bounds || Bounds.create(body.vertices),\n                        positionPrev: body.positionPrev || Vector.clone(body.position),\n                        anglePrev: body.anglePrev || body.angle,\n                        vertices: body.vertices,\n                        parts: body.parts || [\n                            body\n                        ],\n                        isStatic: body.isStatic,\n                        isSleeping: body.isSleeping,\n                        parent: body.parent || body\n                    });\n                    Vertices.rotate(body.vertices, body.angle, body.position);\n                    Axes.rotate(body.axes, body.angle);\n                    Bounds.update(body.bounds, body.vertices, body.velocity);\n                    // allow options to override the automatically calculated properties\n                    Body.set(body, {\n                        axes: options.axes || body.axes,\n                        area: options.area || body.area,\n                        mass: options.mass || body.mass,\n                        inertia: options.inertia || body.inertia\n                    });\n                    // render properties\n                    var defaultFillStyle = body.isStatic ? \"#14151f\" : Common.choose([\n                        \"#f19648\",\n                        \"#f5d259\",\n                        \"#f55a3c\",\n                        \"#063e7b\",\n                        \"#ececd1\"\n                    ]), defaultStrokeStyle = body.isStatic ? \"#555\" : \"#ccc\", defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;\n                    body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n                    body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n                    body.render.lineWidth = body.render.lineWidth || defaultLineWidth;\n                    body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n                    body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n                };\n                /**\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\n     * Prefer to use the actual setter functions in performance critical situations.\n     * @method set\n     * @param {body} body\n     * @param {} settings A property name (or map of properties and values) to set on the body.\n     * @param {} value The value to set if `settings` is a single property name.\n     */ Body.set = function(body, settings, value) {\n                    var property;\n                    if (typeof settings === \"string\") {\n                        property = settings;\n                        settings = {};\n                        settings[property] = value;\n                    }\n                    for(property in settings){\n                        if (!Object.prototype.hasOwnProperty.call(settings, property)) continue;\n                        value = settings[property];\n                        switch(property){\n                            case \"isStatic\":\n                                Body.setStatic(body, value);\n                                break;\n                            case \"isSleeping\":\n                                Sleeping.set(body, value);\n                                break;\n                            case \"mass\":\n                                Body.setMass(body, value);\n                                break;\n                            case \"density\":\n                                Body.setDensity(body, value);\n                                break;\n                            case \"inertia\":\n                                Body.setInertia(body, value);\n                                break;\n                            case \"vertices\":\n                                Body.setVertices(body, value);\n                                break;\n                            case \"position\":\n                                Body.setPosition(body, value);\n                                break;\n                            case \"angle\":\n                                Body.setAngle(body, value);\n                                break;\n                            case \"velocity\":\n                                Body.setVelocity(body, value);\n                                break;\n                            case \"angularVelocity\":\n                                Body.setAngularVelocity(body, value);\n                                break;\n                            case \"speed\":\n                                Body.setSpeed(body, value);\n                                break;\n                            case \"angularSpeed\":\n                                Body.setAngularSpeed(body, value);\n                                break;\n                            case \"parts\":\n                                Body.setParts(body, value);\n                                break;\n                            case \"centre\":\n                                Body.setCentre(body, value);\n                                break;\n                            default:\n                                body[property] = value;\n                        }\n                    }\n                };\n                /**\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\n     * @method setStatic\n     * @param {body} body\n     * @param {bool} isStatic\n     */ Body.setStatic = function(body, isStatic) {\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        part.isStatic = isStatic;\n                        if (isStatic) {\n                            part._original = {\n                                restitution: part.restitution,\n                                friction: part.friction,\n                                mass: part.mass,\n                                inertia: part.inertia,\n                                density: part.density,\n                                inverseMass: part.inverseMass,\n                                inverseInertia: part.inverseInertia\n                            };\n                            part.restitution = 0;\n                            part.friction = 1;\n                            part.mass = part.inertia = part.density = Infinity;\n                            part.inverseMass = part.inverseInertia = 0;\n                            part.positionPrev.x = part.position.x;\n                            part.positionPrev.y = part.position.y;\n                            part.anglePrev = part.angle;\n                            part.angularVelocity = 0;\n                            part.speed = 0;\n                            part.angularSpeed = 0;\n                            part.motion = 0;\n                        } else if (part._original) {\n                            part.restitution = part._original.restitution;\n                            part.friction = part._original.friction;\n                            part.mass = part._original.mass;\n                            part.inertia = part._original.inertia;\n                            part.density = part._original.density;\n                            part.inverseMass = part._original.inverseMass;\n                            part.inverseInertia = part._original.inverseInertia;\n                            part._original = null;\n                        }\n                    }\n                };\n                /**\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\n     * @method setMass\n     * @param {body} body\n     * @param {number} mass\n     */ Body.setMass = function(body, mass) {\n                    var moment = body.inertia / (body.mass / 6);\n                    body.inertia = moment * (mass / 6);\n                    body.inverseInertia = 1 / body.inertia;\n                    body.mass = mass;\n                    body.inverseMass = 1 / body.mass;\n                    body.density = body.mass / body.area;\n                };\n                /**\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\n     * @method setDensity\n     * @param {body} body\n     * @param {number} density\n     */ Body.setDensity = function(body, density) {\n                    Body.setMass(body, density * body.area);\n                    body.density = density;\n                };\n                /**\n     * Sets the moment of inertia of the body. This is the second moment of area in two dimensions.\n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\n     * @method setInertia\n     * @param {body} body\n     * @param {number} inertia\n     */ Body.setInertia = function(body, inertia) {\n                    body.inertia = inertia;\n                    body.inverseInertia = 1 / body.inertia;\n                };\n                /**\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\n     * They are then automatically translated to world space based on `body.position`.\n     *\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\n     * Vertices must form a convex hull. Concave vertices must be decomposed into convex parts.\n     * \n     * @method setVertices\n     * @param {body} body\n     * @param {vector[]} vertices\n     */ Body.setVertices = function(body, vertices) {\n                    // change vertices\n                    if (vertices[0].body === body) {\n                        body.vertices = vertices;\n                    } else {\n                        body.vertices = Vertices.create(vertices, body);\n                    }\n                    // update properties\n                    body.axes = Axes.fromVertices(body.vertices);\n                    body.area = Vertices.area(body.vertices);\n                    Body.setMass(body, body.density * body.area);\n                    // orient vertices around the centre of mass at origin (0, 0)\n                    var centre = Vertices.centre(body.vertices);\n                    Vertices.translate(body.vertices, centre, -1);\n                    // update inertia while vertices are at origin (0, 0)\n                    Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\n                    // update geometry\n                    Vertices.translate(body.vertices, body.position);\n                    Bounds.update(body.bounds, body.vertices, body.velocity);\n                };\n                /**\n     * Sets the parts of the `body` and updates mass, inertia and centroid.\n     * Each part will have its parent set to `body`.\n     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\n     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\n     * @method setParts\n     * @param {body} body\n     * @param {body[]} parts\n     * @param {bool} [autoHull=true]\n     */ Body.setParts = function(body, parts, autoHull) {\n                    var i;\n                    // add all the parts, ensuring that the first part is always the parent body\n                    parts = parts.slice(0);\n                    body.parts.length = 0;\n                    body.parts.push(body);\n                    body.parent = body;\n                    for(i = 0; i < parts.length; i++){\n                        var part = parts[i];\n                        if (part !== body) {\n                            part.parent = body;\n                            body.parts.push(part);\n                        }\n                    }\n                    if (body.parts.length === 1) return;\n                    autoHull = typeof autoHull !== \"undefined\" ? autoHull : true;\n                    // find the convex hull of all parts to set on the parent body\n                    if (autoHull) {\n                        var vertices = [];\n                        for(i = 0; i < parts.length; i++){\n                            vertices = vertices.concat(parts[i].vertices);\n                        }\n                        Vertices.clockwiseSort(vertices);\n                        var hull = Vertices.hull(vertices), hullCentre = Vertices.centre(hull);\n                        Body.setVertices(body, hull);\n                        Vertices.translate(body.vertices, hullCentre);\n                    }\n                    // sum the properties of all compound parts of the parent body\n                    var total = Body._totalProperties(body);\n                    body.area = total.area;\n                    body.parent = body;\n                    body.position.x = total.centre.x;\n                    body.position.y = total.centre.y;\n                    body.positionPrev.x = total.centre.x;\n                    body.positionPrev.y = total.centre.y;\n                    Body.setMass(body, total.mass);\n                    Body.setInertia(body, total.inertia);\n                    Body.setPosition(body, total.centre);\n                };\n                /**\n     * Set the centre of mass of the body. \n     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\n     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\n     * This is equal to moving `body.position` but not the `body.vertices`.\n     * Invalid if the `centre` falls outside the body's convex hull.\n     * @method setCentre\n     * @param {body} body\n     * @param {vector} centre\n     * @param {bool} relative\n     */ Body.setCentre = function(body, centre, relative) {\n                    if (!relative) {\n                        body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\n                        body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\n                        body.position.x = centre.x;\n                        body.position.y = centre.y;\n                    } else {\n                        body.positionPrev.x += centre.x;\n                        body.positionPrev.y += centre.y;\n                        body.position.x += centre.x;\n                        body.position.y += centre.y;\n                    }\n                };\n                /**\n     * Sets the position of the body. By default velocity is unchanged.\n     * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n     * @method setPosition\n     * @param {body} body\n     * @param {vector} position\n     * @param {boolean} [updateVelocity=false]\n     */ Body.setPosition = function(body, position, updateVelocity) {\n                    var delta = Vector.sub(position, body.position);\n                    if (updateVelocity) {\n                        body.positionPrev.x = body.position.x;\n                        body.positionPrev.y = body.position.y;\n                        body.velocity.x = delta.x;\n                        body.velocity.y = delta.y;\n                        body.speed = Vector.magnitude(delta);\n                    } else {\n                        body.positionPrev.x += delta.x;\n                        body.positionPrev.y += delta.y;\n                    }\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        part.position.x += delta.x;\n                        part.position.y += delta.y;\n                        Vertices.translate(part.vertices, delta);\n                        Bounds.update(part.bounds, part.vertices, body.velocity);\n                    }\n                };\n                /**\n     * Sets the angle of the body. By default angular velocity is unchanged.\n     * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n     * @method setAngle\n     * @param {body} body\n     * @param {number} angle\n     * @param {boolean} [updateVelocity=false]\n     */ Body.setAngle = function(body, angle, updateVelocity) {\n                    var delta = angle - body.angle;\n                    if (updateVelocity) {\n                        body.anglePrev = body.angle;\n                        body.angularVelocity = delta;\n                        body.angularSpeed = Math.abs(delta);\n                    } else {\n                        body.anglePrev += delta;\n                    }\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        part.angle += delta;\n                        Vertices.rotate(part.vertices, delta, body.position);\n                        Axes.rotate(part.axes, delta);\n                        Bounds.update(part.bounds, part.vertices, body.velocity);\n                        if (i > 0) {\n                            Vector.rotateAbout(part.position, delta, body.position, part.position);\n                        }\n                    }\n                };\n                /**\n     * Sets the current linear velocity of the body.  \n     * Affects body speed.\n     * @method setVelocity\n     * @param {body} body\n     * @param {vector} velocity\n     */ Body.setVelocity = function(body, velocity) {\n                    var timeScale = body.deltaTime / Body._baseDelta;\n                    body.positionPrev.x = body.position.x - velocity.x * timeScale;\n                    body.positionPrev.y = body.position.y - velocity.y * timeScale;\n                    body.velocity.x = (body.position.x - body.positionPrev.x) / timeScale;\n                    body.velocity.y = (body.position.y - body.positionPrev.y) / timeScale;\n                    body.speed = Vector.magnitude(body.velocity);\n                };\n                /**\n     * Gets the current linear velocity of the body.\n     * @method getVelocity\n     * @param {body} body\n     * @return {vector} velocity\n     */ Body.getVelocity = function(body) {\n                    var timeScale = Body._baseDelta / body.deltaTime;\n                    return {\n                        x: (body.position.x - body.positionPrev.x) * timeScale,\n                        y: (body.position.y - body.positionPrev.y) * timeScale\n                    };\n                };\n                /**\n     * Gets the current linear speed of the body.  \n     * Equivalent to the magnitude of its velocity.\n     * @method getSpeed\n     * @param {body} body\n     * @return {number} speed\n     */ Body.getSpeed = function(body) {\n                    return Vector.magnitude(Body.getVelocity(body));\n                };\n                /**\n     * Sets the current linear speed of the body.  \n     * Direction is maintained. Affects body velocity.\n     * @method setSpeed\n     * @param {body} body\n     * @param {number} speed\n     */ Body.setSpeed = function(body, speed) {\n                    Body.setVelocity(body, Vector.mult(Vector.normalise(Body.getVelocity(body)), speed));\n                };\n                /**\n     * Sets the current rotational velocity of the body.  \n     * Affects body angular speed.\n     * @method setAngularVelocity\n     * @param {body} body\n     * @param {number} velocity\n     */ Body.setAngularVelocity = function(body, velocity) {\n                    var timeScale = body.deltaTime / Body._baseDelta;\n                    body.anglePrev = body.angle - velocity * timeScale;\n                    body.angularVelocity = (body.angle - body.anglePrev) / timeScale;\n                    body.angularSpeed = Math.abs(body.angularVelocity);\n                };\n                /**\n     * Gets the current rotational velocity of the body.\n     * @method getAngularVelocity\n     * @param {body} body\n     * @return {number} angular velocity\n     */ Body.getAngularVelocity = function(body) {\n                    return (body.angle - body.anglePrev) * Body._baseDelta / body.deltaTime;\n                };\n                /**\n     * Gets the current rotational speed of the body.  \n     * Equivalent to the magnitude of its angular velocity.\n     * @method getAngularSpeed\n     * @param {body} body\n     * @return {number} angular speed\n     */ Body.getAngularSpeed = function(body) {\n                    return Math.abs(Body.getAngularVelocity(body));\n                };\n                /**\n     * Sets the current rotational speed of the body.  \n     * Direction is maintained. Affects body angular velocity.\n     * @method setAngularSpeed\n     * @param {body} body\n     * @param {number} speed\n     */ Body.setAngularSpeed = function(body, speed) {\n                    Body.setAngularVelocity(body, Common.sign(Body.getAngularVelocity(body)) * speed);\n                };\n                /**\n     * Moves a body by a given vector relative to its current position. By default velocity is unchanged.\n     * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n     * @method translate\n     * @param {body} body\n     * @param {vector} translation\n     * @param {boolean} [updateVelocity=false]\n     */ Body.translate = function(body, translation, updateVelocity) {\n                    Body.setPosition(body, Vector.add(body.position, translation), updateVelocity);\n                };\n                /**\n     * Rotates a body by a given angle relative to its current angle. By default angular velocity is unchanged.\n     * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n     * @method rotate\n     * @param {body} body\n     * @param {number} rotation\n     * @param {vector} [point]\n     * @param {boolean} [updateVelocity=false]\n     */ Body.rotate = function(body, rotation, point, updateVelocity) {\n                    if (!point) {\n                        Body.setAngle(body, body.angle + rotation, updateVelocity);\n                    } else {\n                        var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;\n                        Body.setPosition(body, {\n                            x: point.x + (dx * cos - dy * sin),\n                            y: point.y + (dx * sin + dy * cos)\n                        }, updateVelocity);\n                        Body.setAngle(body, body.angle + rotation, updateVelocity);\n                    }\n                };\n                /**\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\n     * @method scale\n     * @param {body} body\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} [point]\n     */ Body.scale = function(body, scaleX, scaleY, point) {\n                    var totalArea = 0, totalInertia = 0;\n                    point = point || body.position;\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        // scale vertices\n                        Vertices.scale(part.vertices, scaleX, scaleY, point);\n                        // update properties\n                        part.axes = Axes.fromVertices(part.vertices);\n                        part.area = Vertices.area(part.vertices);\n                        Body.setMass(part, body.density * part.area);\n                        // update inertia (requires vertices to be at origin)\n                        Vertices.translate(part.vertices, {\n                            x: -part.position.x,\n                            y: -part.position.y\n                        });\n                        Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n                        Vertices.translate(part.vertices, {\n                            x: part.position.x,\n                            y: part.position.y\n                        });\n                        if (i > 0) {\n                            totalArea += part.area;\n                            totalInertia += part.inertia;\n                        }\n                        // scale position\n                        part.position.x = point.x + (part.position.x - point.x) * scaleX;\n                        part.position.y = point.y + (part.position.y - point.y) * scaleY;\n                        // update bounds\n                        Bounds.update(part.bounds, part.vertices, body.velocity);\n                    }\n                    // handle parent body\n                    if (body.parts.length > 1) {\n                        body.area = totalArea;\n                        if (!body.isStatic) {\n                            Body.setMass(body, body.density * totalArea);\n                            Body.setInertia(body, totalInertia);\n                        }\n                    }\n                    // handle circles\n                    if (body.circleRadius) {\n                        if (scaleX === scaleY) {\n                            body.circleRadius *= scaleX;\n                        } else {\n                            // body is no longer a circle\n                            body.circleRadius = null;\n                        }\n                    }\n                };\n                /**\n     * Performs an update by integrating the equations of motion on the `body`.\n     * This is applied every update by `Matter.Engine` automatically.\n     * @method update\n     * @param {body} body\n     * @param {number} [deltaTime=16.666]\n     */ Body.update = function(body, deltaTime) {\n                    deltaTime = (typeof deltaTime !== \"undefined\" ? deltaTime : 1000 / 60) * body.timeScale;\n                    var deltaTimeSquared = deltaTime * deltaTime, correction = Body._timeCorrection ? deltaTime / (body.deltaTime || deltaTime) : 1;\n                    // from the previous step\n                    var frictionAir = 1 - body.frictionAir * (deltaTime / Common._baseDelta), velocityPrevX = (body.position.x - body.positionPrev.x) * correction, velocityPrevY = (body.position.y - body.positionPrev.y) * correction;\n                    // update velocity with Verlet integration\n                    body.velocity.x = velocityPrevX * frictionAir + body.force.x / body.mass * deltaTimeSquared;\n                    body.velocity.y = velocityPrevY * frictionAir + body.force.y / body.mass * deltaTimeSquared;\n                    body.positionPrev.x = body.position.x;\n                    body.positionPrev.y = body.position.y;\n                    body.position.x += body.velocity.x;\n                    body.position.y += body.velocity.y;\n                    body.deltaTime = deltaTime;\n                    // update angular velocity with Verlet integration\n                    body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;\n                    body.anglePrev = body.angle;\n                    body.angle += body.angularVelocity;\n                    // transform the body geometry\n                    for(var i = 0; i < body.parts.length; i++){\n                        var part = body.parts[i];\n                        Vertices.translate(part.vertices, body.velocity);\n                        if (i > 0) {\n                            part.position.x += body.velocity.x;\n                            part.position.y += body.velocity.y;\n                        }\n                        if (body.angularVelocity !== 0) {\n                            Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n                            Axes.rotate(part.axes, body.angularVelocity);\n                            if (i > 0) {\n                                Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n                            }\n                        }\n                        Bounds.update(part.bounds, part.vertices, body.velocity);\n                    }\n                };\n                /**\n     * Updates properties `body.velocity`, `body.speed`, `body.angularVelocity` and `body.angularSpeed` which are normalised in relation to `Body._baseDelta`.\n     * @method updateVelocities\n     * @param {body} body\n     */ Body.updateVelocities = function(body) {\n                    var timeScale = Body._baseDelta / body.deltaTime, bodyVelocity = body.velocity;\n                    bodyVelocity.x = (body.position.x - body.positionPrev.x) * timeScale;\n                    bodyVelocity.y = (body.position.y - body.positionPrev.y) * timeScale;\n                    body.speed = Math.sqrt(bodyVelocity.x * bodyVelocity.x + bodyVelocity.y * bodyVelocity.y);\n                    body.angularVelocity = (body.angle - body.anglePrev) * timeScale;\n                    body.angularSpeed = Math.abs(body.angularVelocity);\n                };\n                /**\n     * Applies the `force` to the `body` from the force origin `position` in world-space, over a single timestep, including applying any resulting angular torque.\n     * \n     * Forces are useful for effects like gravity, wind or rocket thrust, but can be difficult in practice when precise control is needed. In these cases see `Body.setVelocity` and `Body.setPosition` as an alternative.\n     * \n     * The force from this function is only applied once for the duration of a single timestep, in other words the duration depends directly on the current engine update `delta` and the rate of calls to this function.\n     * \n     * Therefore to account for time, you should apply the force constantly over as many engine updates as equivalent to the intended duration.\n     * \n     * If all or part of the force duration is some fraction of a timestep, first multiply the force by `duration / timestep`.\n     * \n     * The force origin `position` in world-space must also be specified. Passing `body.position` will result in zero angular effect as the force origin would be at the centre of mass.\n     * \n     * The `body` will take time to accelerate under a force, the resulting effect depends on duration of the force, the body mass and other forces on the body including friction combined.\n     * @method applyForce\n     * @param {body} body\n     * @param {vector} position The force origin in world-space. Pass `body.position` to avoid angular torque.\n     * @param {vector} force\n     */ Body.applyForce = function(body, position, force) {\n                    var offset = {\n                        x: position.x - body.position.x,\n                        y: position.y - body.position.y\n                    };\n                    body.force.x += force.x;\n                    body.force.y += force.y;\n                    body.torque += offset.x * force.y - offset.y * force.x;\n                };\n                /**\n     * Returns the sums of the properties of all compound parts of the parent body.\n     * @method _totalProperties\n     * @private\n     * @param {body} body\n     * @return {}\n     */ Body._totalProperties = function(body) {\n                    // from equations at:\n                    // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n                    // http://output.to/sideway/default.asp?qno=121100087\n                    var properties = {\n                        mass: 0,\n                        area: 0,\n                        inertia: 0,\n                        centre: {\n                            x: 0,\n                            y: 0\n                        }\n                    };\n                    // sum the properties of all compound parts of the parent body\n                    for(var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++){\n                        var part = body.parts[i], mass = part.mass !== Infinity ? part.mass : 1;\n                        properties.mass += mass;\n                        properties.area += part.area;\n                        properties.inertia += part.inertia;\n                        properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n                    }\n                    properties.centre = Vector.div(properties.centre, properties.mass);\n                    return properties;\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired when a body starts sleeping (where `this` is the body).\n    *\n    * @event sleepStart\n    * @this {body} The body that has started sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when a body ends sleeping (where `this` is the body).\n    *\n    * @event sleepEnd\n    * @this {body} The body that has ended sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */ /**\n     * _Read only_. Set by `Body.create`.\n     * \n     * A `String` denoting the type of object.\n     *\n     * @readOnly\n     * @property type\n     * @type string\n     * @default \"body\"\n     */ /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Body\"\n     */ /**\n     * _Read only_. Use `Body.setParts` to set. \n     * \n     * An array of bodies that make up this body. \n     * The first body in the array must always be a self reference to the current body instance.\n     * All bodies in the `parts` array together form a single rigid compound body.\n     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\n     * Parts themselves should never be added to a `World`, only the parent body should be.\n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\n     *\n     * @readOnly\n     * @property parts\n     * @type body[]\n     */ /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */ /**\n     * _Read only_. Updated by `Body.setParts`.\n     * \n     * A reference to the body that this is a part of. See `body.parts`.\n     * This is a self reference if the body is not a part of another body.\n     *\n     * @readOnly\n     * @property parent\n     * @type body\n     */ /**\n     * A `Number` specifying the angle of the body, in radians.\n     *\n     * @property angle\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setVertices` or `Body.setParts` to set. See also `Bodies.fromVertices`.\n     * \n     * An array of `Vector` objects that specify the convex hull of the rigid body.\n     * These should be provided about the origin `(0, 0)`. E.g.\n     *\n     * `[{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]`\n     * \n     * Vertices must always be convex, in clockwise order and must not contain any duplicate points.\n     * \n     * Concave vertices should be decomposed into convex `parts`, see `Bodies.fromVertices` and `Body.setParts`.\n     *\n     * When set the vertices are translated such that `body.position` is at the centre of mass.\n     * Many other body properties are automatically calculated from these vertices when set including `density`, `area` and `inertia`.\n     * \n     * The module `Matter.Vertices` contains useful methods for working with vertices.\n     *\n     * @readOnly\n     * @property vertices\n     * @type vector[]\n     */ /**\n     * _Read only_. Use `Body.setPosition` to set. \n     * \n     * A `Vector` that specifies the current world-space position of the body.\n     * \n     * @readOnly\n     * @property position\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Vector` that accumulates the total force applied to the body for a single update.\n     * Force is zeroed after every `Engine.update`, so constant forces should be applied for every update they are needed. See also `Body.applyForce`.\n     * \n     * @property force\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Number` that accumulates the total torque (turning force) applied to the body for a single update. See also `Body.applyForce`.\n     * Torque is zeroed after every `Engine.update`, so constant torques should be applied for every update they are needed.\n     *\n     * Torques result in angular acceleration on every update, which depends on body inertia and the engine update delta.\n     * \n     * @property torque\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setSpeed` to set. \n     * \n     * See `Body.getSpeed` for details.\n     * \n     * Equivalent to the magnitude of `body.velocity` (always positive).\n     * \n     * @readOnly\n     * @property speed\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setVelocity` to set. \n     * \n     * See `Body.getVelocity` for details.\n     * \n     * Equivalent to the magnitude of `body.angularVelocity` (always positive).\n     * \n     * @readOnly\n     * @property velocity\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * _Read only_. Use `Body.setAngularSpeed` to set. \n     * \n     * See `Body.getAngularSpeed` for details.\n     * \n     * \n     * @readOnly\n     * @property angularSpeed\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setAngularVelocity` to set. \n     * \n     * See `Body.getAngularVelocity` for details.\n     * \n     *\n     * @readOnly\n     * @property angularVelocity\n     * @type number\n     * @default 0\n     */ /**\n     * _Read only_. Use `Body.setStatic` to set. \n     * \n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\n     *\n     * @readOnly\n     * @property isStatic\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\n     *\n     * @property isSensor\n     * @type boolean\n     * @default false\n     */ /**\n     * _Read only_. Use `Sleeping.set` to set. \n     * \n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\n     *\n     * @readOnly\n     * @property isSleeping\n     * @type boolean\n     * @default false\n     */ /**\n     * _Read only_. Calculated during engine update only when sleeping is enabled.\n     * \n     * A `Number` that loosely measures the amount of movement a body currently has.\n     *\n     * Derived from `body.speed^2 + body.angularSpeed^2`. See `Sleeping.update`.\n     * \n     * @readOnly\n     * @property motion\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that defines the length of time during which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\n     * \n     * @property sleepThreshold\n     * @type number\n     * @default 60\n     */ /**\n     * _Read only_. Use `Body.setDensity` to set. \n     * \n     * A `Number` that defines the density of the body (mass per unit area).\n     * \n     * Mass will also be updated when set.\n     *\n     * @readOnly\n     * @property density\n     * @type number\n     * @default 0.001\n     */ /**\n     * _Read only_. Use `Body.setMass` to set. \n     * \n     * A `Number` that defines the mass of the body.\n     * \n     * Density will also be updated when set.\n     * \n     * @readOnly\n     * @property mass\n     * @type number\n     */ /**\n     * _Read only_. Use `Body.setMass` to set. \n     * \n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\n     *\n     * @readOnly\n     * @property inverseMass\n     * @type number\n     */ /**\n     * _Read only_. Automatically calculated when vertices, mass or density are set or set through `Body.setInertia`.\n     * \n     * A `Number` that defines the moment of inertia of the body. This is the second moment of area in two dimensions.\n     * \n     * Can be manually set to `Infinity` to prevent rotation of the body. See `Body.setInertia`.\n     * \n     * @readOnly\n     * @property inertia\n     * @type number\n     */ /**\n     * _Read only_. Automatically calculated when vertices, mass or density are set or calculated by `Body.setInertia`.\n     * \n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\n     * \n     * @readOnly\n     * @property inverseInertia\n     * @type number\n     */ /**\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\n     *\n     * `Math.max(bodyA.restitution, bodyB.restitution)`\n     *\n     * @property restitution\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means that the body may slide indefinitely.\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\n     *\n     * The effects of the value may be non-linear. \n     * High values may be unstable depending on the body.\n     * The engine uses a Coulomb friction model including static and kinetic friction.\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\n     *\n     * `Math.min(bodyA.friction, bodyB.friction)`\n     *\n     * @property friction\n     * @type number\n     * @default 0.1\n     */ /**\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\n     *\n     * @property frictionStatic\n     * @type number\n     * @default 0.5\n     */ /**\n     * A `Number` that defines the air friction of the body (air resistance). \n     * A value of `0` means the body will never slow as it moves through space.\n     * The higher the value, the faster a body slows when moving through space.\n     * The effects of the value are non-linear. \n     *\n     * @property frictionAir\n     * @type number\n     * @default 0.01\n     */ /**\n     * An `Object` that specifies the collision filtering properties of this body.\n     *\n     * Collisions between two bodies will obey the following rules:\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\n     *   they will always collide if the value is positive, and they will never collide\n     *   if the value is negative.\n     * - If the two bodies have different values of `collisionFilter.group` or if one\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\n     *\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\n     * value is used as a bit field and the category should have only one bit set, meaning that\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\n     * different collision categories available.\n     *\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\n     *\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\n     * are both true.\n     *\n     * @property collisionFilter\n     * @type object\n     */ /**\n     * An Integer `Number`, that specifies the collision group this body belongs to.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.group\n     * @type object\n     * @default 0\n     */ /**\n     * A bit field that specifies the collision category this body belongs to.\n     * The category value should have only one bit set, for example `0x0001`.\n     * This means there are up to 32 unique collision categories available.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.category\n     * @type object\n     * @default 1\n     */ /**\n     * A bit mask that specifies the collision categories this body may collide with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.mask\n     * @type object\n     * @default -1\n     */ /**\n     * A `Number` that specifies a thin boundary around the body where it is allowed to slightly sink into other bodies.\n     * \n     * This is required for proper collision response, including friction and restitution effects.\n     * \n     * The default should generally suffice in most cases. You may need to decrease this value for very small bodies that are nearing the default value in scale.\n     *\n     * @property slop\n     * @type number\n     * @default 0.05\n     */ /**\n     * A `Number` that specifies per-body time scaling.\n     *\n     * @property timeScale\n     * @type number\n     * @default 1\n     */ /**\n     * _Read only_. Updated during engine update.\n     * \n     * A `Number` that records the last delta time value used to update this body.\n     * Used to calculate speed and velocity.\n     *\n     * @readOnly\n     * @property deltaTime\n     * @type number\n     * @default 1000 / 60\n     */ /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */ /**\n     * A flag that indicates if the body should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */ /**\n     * Sets the opacity to use when rendering.\n     *\n     * @property render.opacity\n     * @type number\n     * @default 1\n    */ /**\n     * An `Object` that defines the sprite properties to use when rendering, if any.\n     *\n     * @property render.sprite\n     * @type object\n     */ /**\n     * An `String` that defines the path to the image to use as the sprite texture, if any.\n     *\n     * @property render.sprite.texture\n     * @type string\n     */ /**\n     * A `Number` that defines the scaling in the x-axis for the sprite, if any.\n     *\n     * @property render.sprite.xScale\n     * @type number\n     * @default 1\n     */ /**\n     * A `Number` that defines the scaling in the y-axis for the sprite, if any.\n     *\n     * @property render.sprite.yScale\n     * @type number\n     * @default 1\n     */ /**\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\n      *\n      * @property render.sprite.xOffset\n      * @type number\n      * @default 0\n      */ /**\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\n      *\n      * @property render.sprite.yOffset\n      * @type number\n      * @default 0\n      */ /**\n     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 0\n     */ /**\n     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.fillStyle\n     * @type string\n     * @default a random colour\n     */ /**\n     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */ /**\n     * _Read only_. Calculated automatically when vertices are set.\n     * \n     * An array of unique axis vectors (edge normals) used for collision detection.\n     * These are automatically calculated when vertices are set.\n     * They are constantly updated by `Body.update` during the simulation.\n     *\n     * @readOnly\n     * @property axes\n     * @type vector[]\n     */ /**\n     * _Read only_. Calculated automatically when vertices are set.\n     * \n     * A `Number` that measures the area of the body's convex hull.\n     * \n     * @readOnly\n     * @property area\n     * @type string\n     * @default \n     */ /**\n     * A `Bounds` object that defines the AABB region for the body.\n     * It is automatically calculated when vertices are set and constantly updated by `Body.update` during simulation.\n     * \n     * @property bounds\n     * @type bounds\n     */ })();\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_113326__) {\n            /**\n* The `Matter.Events` module contains methods to fire and listen to events on other objects.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Events\n*/ var Events = {};\n            module1.exports = Events;\n            var Common = __nested_webpack_require_113326__(0);\n            (function() {\n                /**\n     * Subscribes a callback function to the given object's `eventName`.\n     * @method on\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */ Events.on = function(object, eventNames, callback) {\n                    var names = eventNames.split(\" \"), name;\n                    for(var i = 0; i < names.length; i++){\n                        name = names[i];\n                        object.events = object.events || {};\n                        object.events[name] = object.events[name] || [];\n                        object.events[name].push(callback);\n                    }\n                    return callback;\n                };\n                /**\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\n     * @method off\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */ Events.off = function(object, eventNames, callback) {\n                    if (!eventNames) {\n                        object.events = {};\n                        return;\n                    }\n                    // handle Events.off(object, callback)\n                    if (typeof eventNames === \"function\") {\n                        callback = eventNames;\n                        eventNames = Common.keys(object.events).join(\" \");\n                    }\n                    var names = eventNames.split(\" \");\n                    for(var i = 0; i < names.length; i++){\n                        var callbacks = object.events[names[i]], newCallbacks = [];\n                        if (callback && callbacks) {\n                            for(var j = 0; j < callbacks.length; j++){\n                                if (callbacks[j] !== callback) newCallbacks.push(callbacks[j]);\n                            }\n                        }\n                        object.events[names[i]] = newCallbacks;\n                    }\n                };\n                /**\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\n     * @method trigger\n     * @param {} object\n     * @param {string} eventNames\n     * @param {} event\n     */ Events.trigger = function(object, eventNames, event) {\n                    var names, name, callbacks, eventClone;\n                    var events = object.events;\n                    if (events && Common.keys(events).length > 0) {\n                        if (!event) event = {};\n                        names = eventNames.split(\" \");\n                        for(var i = 0; i < names.length; i++){\n                            name = names[i];\n                            callbacks = events[name];\n                            if (callbacks) {\n                                eventClone = Common.clone(event, false);\n                                eventClone.name = name;\n                                eventClone.source = object;\n                                for(var j = 0; j < callbacks.length; j++){\n                                    callbacks[j].apply(object, [\n                                        eventClone\n                                    ]);\n                                }\n                            }\n                        }\n                    }\n                };\n            })();\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_117133__) {\n            /**\n* A composite is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite` objects.\n*\n* They are a container that can represent complex objects made of multiple parts, even if they are not physically connected.\n* A composite could contain anything from a single body all the way up to a whole world.\n* \n* When making any changes to composites, use the included functions rather than changing their properties directly.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composite\n*/ var Composite = {};\n            module1.exports = Composite;\n            var Events = __nested_webpack_require_117133__(5);\n            var Common = __nested_webpack_require_117133__(0);\n            var Bounds = __nested_webpack_require_117133__(1);\n            var Body = __nested_webpack_require_117133__(4);\n            (function() {\n                /**\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} [options]\n     * @return {composite} A new composite\n     */ Composite.create = function(options) {\n                    return Common.extend({\n                        id: Common.nextId(),\n                        type: \"composite\",\n                        parent: null,\n                        isModified: false,\n                        bodies: [],\n                        constraints: [],\n                        composites: [],\n                        label: \"Composite\",\n                        plugin: {},\n                        cache: {\n                            allBodies: null,\n                            allConstraints: null,\n                            allComposites: null\n                        }\n                    }, options);\n                };\n                /**\n     * Sets the composite's `isModified` flag. \n     * If `updateParents` is true, all parents will be set (default: false).\n     * If `updateChildren` is true, all children will be set (default: false).\n     * @private\n     * @method setModified\n     * @param {composite} composite\n     * @param {boolean} isModified\n     * @param {boolean} [updateParents=false]\n     * @param {boolean} [updateChildren=false]\n     */ Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\n                    composite.isModified = isModified;\n                    if (isModified && composite.cache) {\n                        composite.cache.allBodies = null;\n                        composite.cache.allConstraints = null;\n                        composite.cache.allComposites = null;\n                    }\n                    if (updateParents && composite.parent) {\n                        Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n                    }\n                    if (updateChildren) {\n                        for(var i = 0; i < composite.composites.length; i++){\n                            var childComposite = composite.composites[i];\n                            Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n                        }\n                    }\n                };\n                /**\n     * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\n     * @method add\n     * @param {composite} composite\n     * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s)\n     * @return {composite} The original composite with the objects added\n     */ Composite.add = function(composite, object) {\n                    var objects = [].concat(object);\n                    Events.trigger(composite, \"beforeAdd\", {\n                        object: object\n                    });\n                    for(var i = 0; i < objects.length; i++){\n                        var obj = objects[i];\n                        switch(obj.type){\n                            case \"body\":\n                                // skip adding compound parts\n                                if (obj.parent !== obj) {\n                                    Common.warn(\"Composite.add: skipped adding a compound body part (you must add its parent instead)\");\n                                    break;\n                                }\n                                Composite.addBody(composite, obj);\n                                break;\n                            case \"constraint\":\n                                Composite.addConstraint(composite, obj);\n                                break;\n                            case \"composite\":\n                                Composite.addComposite(composite, obj);\n                                break;\n                            case \"mouseConstraint\":\n                                Composite.addConstraint(composite, obj.constraint);\n                                break;\n                        }\n                    }\n                    Events.trigger(composite, \"afterAdd\", {\n                        object: object\n                    });\n                    return composite;\n                };\n                /**\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\n     * Optionally searching its children recursively.\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\n     * @method remove\n     * @param {composite} composite\n     * @param {object|array} object\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the objects removed\n     */ Composite.remove = function(composite, object, deep) {\n                    var objects = [].concat(object);\n                    Events.trigger(composite, \"beforeRemove\", {\n                        object: object\n                    });\n                    for(var i = 0; i < objects.length; i++){\n                        var obj = objects[i];\n                        switch(obj.type){\n                            case \"body\":\n                                Composite.removeBody(composite, obj, deep);\n                                break;\n                            case \"constraint\":\n                                Composite.removeConstraint(composite, obj, deep);\n                                break;\n                            case \"composite\":\n                                Composite.removeComposite(composite, obj, deep);\n                                break;\n                            case \"mouseConstraint\":\n                                Composite.removeConstraint(composite, obj.constraint);\n                                break;\n                        }\n                    }\n                    Events.trigger(composite, \"afterRemove\", {\n                        object: object\n                    });\n                    return composite;\n                };\n                /**\n     * Adds a composite to the given composite.\n     * @private\n     * @method addComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @return {composite} The original compositeA with the objects from compositeB added\n     */ Composite.addComposite = function(compositeA, compositeB) {\n                    compositeA.composites.push(compositeB);\n                    compositeB.parent = compositeA;\n                    Composite.setModified(compositeA, true, true, false);\n                    return compositeA;\n                };\n                /**\n     * Removes a composite from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @param {boolean} [deep=false]\n     * @return {composite} The original compositeA with the composite removed\n     */ Composite.removeComposite = function(compositeA, compositeB, deep) {\n                    var position = Common.indexOf(compositeA.composites, compositeB);\n                    if (position !== -1) {\n                        Composite.removeCompositeAt(compositeA, position);\n                    }\n                    if (deep) {\n                        for(var i = 0; i < compositeA.composites.length; i++){\n                            Composite.removeComposite(compositeA.composites[i], compositeB, true);\n                        }\n                    }\n                    return compositeA;\n                };\n                /**\n     * Removes a composite from the given composite.\n     * @private\n     * @method removeCompositeAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the composite removed\n     */ Composite.removeCompositeAt = function(composite, position) {\n                    composite.composites.splice(position, 1);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Adds a body to the given composite.\n     * @private\n     * @method addBody\n     * @param {composite} composite\n     * @param {body} body\n     * @return {composite} The original composite with the body added\n     */ Composite.addBody = function(composite, body) {\n                    composite.bodies.push(body);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Removes a body from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeBody\n     * @param {composite} composite\n     * @param {body} body\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the body removed\n     */ Composite.removeBody = function(composite, body, deep) {\n                    var position = Common.indexOf(composite.bodies, body);\n                    if (position !== -1) {\n                        Composite.removeBodyAt(composite, position);\n                    }\n                    if (deep) {\n                        for(var i = 0; i < composite.composites.length; i++){\n                            Composite.removeBody(composite.composites[i], body, true);\n                        }\n                    }\n                    return composite;\n                };\n                /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeBodyAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the body removed\n     */ Composite.removeBodyAt = function(composite, position) {\n                    composite.bodies.splice(position, 1);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Adds a constraint to the given composite.\n     * @private\n     * @method addConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @return {composite} The original composite with the constraint added\n     */ Composite.addConstraint = function(composite, constraint) {\n                    composite.constraints.push(constraint);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the constraint removed\n     */ Composite.removeConstraint = function(composite, constraint, deep) {\n                    var position = Common.indexOf(composite.constraints, constraint);\n                    if (position !== -1) {\n                        Composite.removeConstraintAt(composite, position);\n                    }\n                    if (deep) {\n                        for(var i = 0; i < composite.composites.length; i++){\n                            Composite.removeConstraint(composite.composites[i], constraint, true);\n                        }\n                    }\n                    return composite;\n                };\n                /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeConstraintAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the constraint removed\n     */ Composite.removeConstraintAt = function(composite, position) {\n                    composite.constraints.splice(position, 1);\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Removes all bodies, constraints and composites from the given composite.\n     * Optionally clearing its children recursively.\n     * @method clear\n     * @param {composite} composite\n     * @param {boolean} keepStatic\n     * @param {boolean} [deep=false]\n     */ Composite.clear = function(composite, keepStatic, deep) {\n                    if (deep) {\n                        for(var i = 0; i < composite.composites.length; i++){\n                            Composite.clear(composite.composites[i], keepStatic, true);\n                        }\n                    }\n                    if (keepStatic) {\n                        composite.bodies = composite.bodies.filter(function(body) {\n                            return body.isStatic;\n                        });\n                    } else {\n                        composite.bodies.length = 0;\n                    }\n                    composite.constraints.length = 0;\n                    composite.composites.length = 0;\n                    Composite.setModified(composite, true, true, false);\n                    return composite;\n                };\n                /**\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\n     * @method allBodies\n     * @param {composite} composite\n     * @return {body[]} All the bodies\n     */ Composite.allBodies = function(composite) {\n                    if (composite.cache && composite.cache.allBodies) {\n                        return composite.cache.allBodies;\n                    }\n                    var bodies = [].concat(composite.bodies);\n                    for(var i = 0; i < composite.composites.length; i++)bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n                    if (composite.cache) {\n                        composite.cache.allBodies = bodies;\n                    }\n                    return bodies;\n                };\n                /**\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\n     * @method allConstraints\n     * @param {composite} composite\n     * @return {constraint[]} All the constraints\n     */ Composite.allConstraints = function(composite) {\n                    if (composite.cache && composite.cache.allConstraints) {\n                        return composite.cache.allConstraints;\n                    }\n                    var constraints = [].concat(composite.constraints);\n                    for(var i = 0; i < composite.composites.length; i++)constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n                    if (composite.cache) {\n                        composite.cache.allConstraints = constraints;\n                    }\n                    return constraints;\n                };\n                /**\n     * Returns all composites in the given composite, including all composites in its children, recursively.\n     * @method allComposites\n     * @param {composite} composite\n     * @return {composite[]} All the composites\n     */ Composite.allComposites = function(composite) {\n                    if (composite.cache && composite.cache.allComposites) {\n                        return composite.cache.allComposites;\n                    }\n                    var composites = [].concat(composite.composites);\n                    for(var i = 0; i < composite.composites.length; i++)composites = composites.concat(Composite.allComposites(composite.composites[i]));\n                    if (composite.cache) {\n                        composite.cache.allComposites = composites;\n                    }\n                    return composites;\n                };\n                /**\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\n     * @method get\n     * @param {composite} composite\n     * @param {number} id\n     * @param {string} type\n     * @return {object} The requested object, if found\n     */ Composite.get = function(composite, id, type) {\n                    var objects, object;\n                    switch(type){\n                        case \"body\":\n                            objects = Composite.allBodies(composite);\n                            break;\n                        case \"constraint\":\n                            objects = Composite.allConstraints(composite);\n                            break;\n                        case \"composite\":\n                            objects = Composite.allComposites(composite).concat(composite);\n                            break;\n                    }\n                    if (!objects) return null;\n                    object = objects.filter(function(object) {\n                        return object.id.toString() === id.toString();\n                    });\n                    return object.length === 0 ? null : object[0];\n                };\n                /**\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\n     * @method move\n     * @param {compositeA} compositeA\n     * @param {object[]} objects\n     * @param {compositeB} compositeB\n     * @return {composite} Returns compositeA\n     */ Composite.move = function(compositeA, objects, compositeB) {\n                    Composite.remove(compositeA, objects);\n                    Composite.add(compositeB, objects);\n                    return compositeA;\n                };\n                /**\n     * Assigns new ids for all objects in the composite, recursively.\n     * @method rebase\n     * @param {composite} composite\n     * @return {composite} Returns composite\n     */ Composite.rebase = function(composite) {\n                    var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));\n                    for(var i = 0; i < objects.length; i++){\n                        objects[i].id = Common.nextId();\n                    }\n                    return composite;\n                };\n                /**\n     * Translates all children in the composite by a given vector relative to their current positions, \n     * without imparting any velocity.\n     * @method translate\n     * @param {composite} composite\n     * @param {vector} translation\n     * @param {bool} [recursive=true]\n     */ Composite.translate = function(composite, translation, recursive) {\n                    var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n                    for(var i = 0; i < bodies.length; i++){\n                        Body.translate(bodies[i], translation);\n                    }\n                    return composite;\n                };\n                /**\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\n     * @method rotate\n     * @param {composite} composite\n     * @param {number} rotation\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */ Composite.rotate = function(composite, rotation, point, recursive) {\n                    var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;\n                        Body.setPosition(body, {\n                            x: point.x + (dx * cos - dy * sin),\n                            y: point.y + (dx * sin + dy * cos)\n                        });\n                        Body.rotate(body, rotation);\n                    }\n                    return composite;\n                };\n                /**\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\n     * @method scale\n     * @param {composite} composite\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */ Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\n                    var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;\n                        Body.setPosition(body, {\n                            x: point.x + dx * scaleX,\n                            y: point.y + dy * scaleY\n                        });\n                        Body.scale(body, scaleX, scaleY);\n                    }\n                    return composite;\n                };\n                /**\n     * Returns the union of the bounds of all of the composite's bodies.\n     * @method bounds\n     * @param {composite} composite The composite.\n     * @returns {bounds} The composite bounds.\n     */ Composite.bounds = function(composite) {\n                    var bodies = Composite.allBodies(composite), vertices = [];\n                    for(var i = 0; i < bodies.length; i += 1){\n                        var body = bodies[i];\n                        vertices.push(body.bounds.min, body.bounds.max);\n                    }\n                    return Bounds.create(vertices);\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired when a call to `Composite.add` is made, before objects have been added.\n    *\n    * @event beforeAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when a call to `Composite.add` is made, after objects have been added.\n    *\n    * @event afterAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\n    *\n    * @event beforeRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\n    *\n    * @event afterRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */ /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"composite\"\n     * @readOnly\n     */ /**\n     * An arbitrary `String` name to help the user identify and manage composites.\n     *\n     * @property label\n     * @type string\n     * @default \"Composite\"\n     */ /**\n     * A flag that specifies whether the composite has been modified during the current step.\n     * This is automatically managed when bodies, constraints or composites are added or removed.\n     *\n     * @property isModified\n     * @type boolean\n     * @default false\n     */ /**\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\n     *\n     * @property parent\n     * @type composite\n     * @default null\n     */ /**\n     * An array of `Body` that are _direct_ children of this composite.\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\n     *\n     * @property bodies\n     * @type body[]\n     * @default []\n     */ /**\n     * An array of `Constraint` that are _direct_ children of this composite.\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\n     *\n     * @property constraints\n     * @type constraint[]\n     * @default []\n     */ /**\n     * An array of `Composite` that are _direct_ children of this composite.\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\n     *\n     * @property composites\n     * @type composite[]\n     * @default []\n     */ /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */ /**\n     * An object used for storing cached results for performance reasons.\n     * This is used internally only and is automatically managed.\n     *\n     * @private\n     * @property cache\n     * @type {}\n     */ })();\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_144048__) {\n            /**\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\n*\n* @class Sleeping\n*/ var Sleeping = {};\n            module1.exports = Sleeping;\n            var Body = __nested_webpack_require_144048__(4);\n            var Events = __nested_webpack_require_144048__(5);\n            var Common = __nested_webpack_require_144048__(0);\n            (function() {\n                Sleeping._motionWakeThreshold = 0.18;\n                Sleeping._motionSleepThreshold = 0.08;\n                Sleeping._minBias = 0.9;\n                /**\n     * Puts bodies to sleep or wakes them up depending on their motion.\n     * @method update\n     * @param {body[]} bodies\n     * @param {number} delta\n     */ Sleeping.update = function(bodies, delta) {\n                    var timeScale = delta / Common._baseDelta, motionSleepThreshold = Sleeping._motionSleepThreshold;\n                    // update bodies sleeping status\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], speed = Body.getSpeed(body), angularSpeed = Body.getAngularSpeed(body), motion = speed * speed + angularSpeed * angularSpeed;\n                        // wake up bodies if they have a force applied\n                        if (body.force.x !== 0 || body.force.y !== 0) {\n                            Sleeping.set(body, false);\n                            continue;\n                        }\n                        var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);\n                        // biased average motion estimation between frames\n                        body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n                        if (body.sleepThreshold > 0 && body.motion < motionSleepThreshold) {\n                            body.sleepCounter += 1;\n                            if (body.sleepCounter >= body.sleepThreshold / timeScale) {\n                                Sleeping.set(body, true);\n                            }\n                        } else if (body.sleepCounter > 0) {\n                            body.sleepCounter -= 1;\n                        }\n                    }\n                };\n                /**\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\n     * @method afterCollisions\n     * @param {pair[]} pairs\n     */ Sleeping.afterCollisions = function(pairs) {\n                    var motionSleepThreshold = Sleeping._motionSleepThreshold;\n                    // wake up bodies involved in collisions\n                    for(var i = 0; i < pairs.length; i++){\n                        var pair = pairs[i];\n                        // don't wake inactive pairs\n                        if (!pair.isActive) continue;\n                        var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;\n                        // don't wake if at least one body is static\n                        if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic) continue;\n                        if (bodyA.isSleeping || bodyB.isSleeping) {\n                            var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n                            if (!sleepingBody.isStatic && movingBody.motion > motionSleepThreshold) {\n                                Sleeping.set(sleepingBody, false);\n                            }\n                        }\n                    }\n                };\n                /**\n     * Set a body as sleeping or awake.\n     * @method set\n     * @param {body} body\n     * @param {boolean} isSleeping\n     */ Sleeping.set = function(body, isSleeping) {\n                    var wasSleeping = body.isSleeping;\n                    if (isSleeping) {\n                        body.isSleeping = true;\n                        body.sleepCounter = body.sleepThreshold;\n                        body.positionImpulse.x = 0;\n                        body.positionImpulse.y = 0;\n                        body.positionPrev.x = body.position.x;\n                        body.positionPrev.y = body.position.y;\n                        body.anglePrev = body.angle;\n                        body.speed = 0;\n                        body.angularSpeed = 0;\n                        body.motion = 0;\n                        if (!wasSleeping) {\n                            Events.trigger(body, \"sleepStart\");\n                        }\n                    } else {\n                        body.isSleeping = false;\n                        body.sleepCounter = 0;\n                        if (wasSleeping) {\n                            Events.trigger(body, \"sleepEnd\");\n                        }\n                    }\n                };\n            })();\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_148936__) {\n            /**\n* The `Matter.Collision` module contains methods for detecting collisions between a given pair of bodies.\n*\n* For efficient detection between a list of bodies, see `Matter.Detector` and `Matter.Query`.\n*\n* See `Matter.Engine` for collision events.\n*\n* @class Collision\n*/ var Collision = {};\n            module1.exports = Collision;\n            var Vertices = __nested_webpack_require_148936__(3);\n            var Pair = __nested_webpack_require_148936__(9);\n            (function() {\n                var _supports = [];\n                var _overlapAB = {\n                    overlap: 0,\n                    axis: null\n                };\n                var _overlapBA = {\n                    overlap: 0,\n                    axis: null\n                };\n                /**\n     * Creates a new collision record.\n     * @method create\n     * @param {body} bodyA The first body part represented by the collision record\n     * @param {body} bodyB The second body part represented by the collision record\n     * @return {collision} A new collision record\n     */ Collision.create = function(bodyA, bodyB) {\n                    return {\n                        pair: null,\n                        collided: false,\n                        bodyA: bodyA,\n                        bodyB: bodyB,\n                        parentA: bodyA.parent,\n                        parentB: bodyB.parent,\n                        depth: 0,\n                        normal: {\n                            x: 0,\n                            y: 0\n                        },\n                        tangent: {\n                            x: 0,\n                            y: 0\n                        },\n                        penetration: {\n                            x: 0,\n                            y: 0\n                        },\n                        supports: []\n                    };\n                };\n                /**\n     * Detect collision between two bodies.\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {pairs} [pairs] Optionally reuse collision records from existing pairs.\n     * @return {collision|null} A collision record if detected, otherwise null\n     */ Collision.collides = function(bodyA, bodyB, pairs) {\n                    Collision._overlapAxes(_overlapAB, bodyA.vertices, bodyB.vertices, bodyA.axes);\n                    if (_overlapAB.overlap <= 0) {\n                        return null;\n                    }\n                    Collision._overlapAxes(_overlapBA, bodyB.vertices, bodyA.vertices, bodyB.axes);\n                    if (_overlapBA.overlap <= 0) {\n                        return null;\n                    }\n                    // reuse collision records for gc efficiency\n                    var pair = pairs && pairs.table[Pair.id(bodyA, bodyB)], collision;\n                    if (!pair) {\n                        collision = Collision.create(bodyA, bodyB);\n                        collision.collided = true;\n                        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n                        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n                        collision.parentA = collision.bodyA.parent;\n                        collision.parentB = collision.bodyB.parent;\n                    } else {\n                        collision = pair.collision;\n                    }\n                    bodyA = collision.bodyA;\n                    bodyB = collision.bodyB;\n                    var minOverlap;\n                    if (_overlapAB.overlap < _overlapBA.overlap) {\n                        minOverlap = _overlapAB;\n                    } else {\n                        minOverlap = _overlapBA;\n                    }\n                    var normal = collision.normal, supports = collision.supports, minAxis = minOverlap.axis, minAxisX = minAxis.x, minAxisY = minAxis.y;\n                    // ensure normal is facing away from bodyA\n                    if (minAxisX * (bodyB.position.x - bodyA.position.x) + minAxisY * (bodyB.position.y - bodyA.position.y) < 0) {\n                        normal.x = minAxisX;\n                        normal.y = minAxisY;\n                    } else {\n                        normal.x = -minAxisX;\n                        normal.y = -minAxisY;\n                    }\n                    collision.tangent.x = -normal.y;\n                    collision.tangent.y = normal.x;\n                    collision.depth = minOverlap.overlap;\n                    collision.penetration.x = normal.x * collision.depth;\n                    collision.penetration.y = normal.y * collision.depth;\n                    // find support points, there is always either exactly one or two\n                    var supportsB = Collision._findSupports(bodyA, bodyB, normal, 1), supportCount = 0;\n                    // find the supports from bodyB that are inside bodyA\n                    if (Vertices.contains(bodyA.vertices, supportsB[0])) {\n                        supports[supportCount++] = supportsB[0];\n                    }\n                    if (Vertices.contains(bodyA.vertices, supportsB[1])) {\n                        supports[supportCount++] = supportsB[1];\n                    }\n                    // find the supports from bodyA that are inside bodyB\n                    if (supportCount < 2) {\n                        var supportsA = Collision._findSupports(bodyB, bodyA, normal, -1);\n                        if (Vertices.contains(bodyB.vertices, supportsA[0])) {\n                            supports[supportCount++] = supportsA[0];\n                        }\n                        if (supportCount < 2 && Vertices.contains(bodyB.vertices, supportsA[1])) {\n                            supports[supportCount++] = supportsA[1];\n                        }\n                    }\n                    // account for the edge case of overlapping but no vertex containment\n                    if (supportCount === 0) {\n                        supports[supportCount++] = supportsB[0];\n                    }\n                    // update supports array size\n                    supports.length = supportCount;\n                    return collision;\n                };\n                /**\n     * Find the overlap between two sets of vertices.\n     * @method _overlapAxes\n     * @private\n     * @param {object} result\n     * @param {vertices} verticesA\n     * @param {vertices} verticesB\n     * @param {axes} axes\n     */ Collision._overlapAxes = function(result, verticesA, verticesB, axes) {\n                    var verticesALength = verticesA.length, verticesBLength = verticesB.length, verticesAX = verticesA[0].x, verticesAY = verticesA[0].y, verticesBX = verticesB[0].x, verticesBY = verticesB[0].y, axesLength = axes.length, overlapMin = Number.MAX_VALUE, overlapAxisNumber = 0, overlap, overlapAB, overlapBA, dot, i, j;\n                    for(i = 0; i < axesLength; i++){\n                        var axis = axes[i], axisX = axis.x, axisY = axis.y, minA = verticesAX * axisX + verticesAY * axisY, minB = verticesBX * axisX + verticesBY * axisY, maxA = minA, maxB = minB;\n                        for(j = 1; j < verticesALength; j += 1){\n                            dot = verticesA[j].x * axisX + verticesA[j].y * axisY;\n                            if (dot > maxA) {\n                                maxA = dot;\n                            } else if (dot < minA) {\n                                minA = dot;\n                            }\n                        }\n                        for(j = 1; j < verticesBLength; j += 1){\n                            dot = verticesB[j].x * axisX + verticesB[j].y * axisY;\n                            if (dot > maxB) {\n                                maxB = dot;\n                            } else if (dot < minB) {\n                                minB = dot;\n                            }\n                        }\n                        overlapAB = maxA - minB;\n                        overlapBA = maxB - minA;\n                        overlap = overlapAB < overlapBA ? overlapAB : overlapBA;\n                        if (overlap < overlapMin) {\n                            overlapMin = overlap;\n                            overlapAxisNumber = i;\n                            if (overlap <= 0) {\n                                break;\n                            }\n                        }\n                    }\n                    result.axis = axes[overlapAxisNumber];\n                    result.overlap = overlapMin;\n                };\n                /**\n     * Projects vertices on an axis and returns an interval.\n     * @method _projectToAxis\n     * @private\n     * @param {} projection\n     * @param {} vertices\n     * @param {} axis\n     */ Collision._projectToAxis = function(projection, vertices, axis) {\n                    var min = vertices[0].x * axis.x + vertices[0].y * axis.y, max = min;\n                    for(var i = 1; i < vertices.length; i += 1){\n                        var dot = vertices[i].x * axis.x + vertices[i].y * axis.y;\n                        if (dot > max) {\n                            max = dot;\n                        } else if (dot < min) {\n                            min = dot;\n                        }\n                    }\n                    projection.min = min;\n                    projection.max = max;\n                };\n                /**\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\n     * @method _findSupports\n     * @private\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {vector} normal\n     * @param {number} direction\n     * @return [vector]\n     */ Collision._findSupports = function(bodyA, bodyB, normal, direction) {\n                    var vertices = bodyB.vertices, verticesLength = vertices.length, bodyAPositionX = bodyA.position.x, bodyAPositionY = bodyA.position.y, normalX = normal.x * direction, normalY = normal.y * direction, nearestDistance = Number.MAX_VALUE, vertexA, vertexB, vertexC, distance, j;\n                    // find deepest vertex relative to the axis\n                    for(j = 0; j < verticesLength; j += 1){\n                        vertexB = vertices[j];\n                        distance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y);\n                        // convex hill-climbing\n                        if (distance < nearestDistance) {\n                            nearestDistance = distance;\n                            vertexA = vertexB;\n                        }\n                    }\n                    // measure next vertex\n                    vertexC = vertices[(verticesLength + vertexA.index - 1) % verticesLength];\n                    nearestDistance = normalX * (bodyAPositionX - vertexC.x) + normalY * (bodyAPositionY - vertexC.y);\n                    // compare with previous vertex\n                    vertexB = vertices[(vertexA.index + 1) % verticesLength];\n                    if (normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y) < nearestDistance) {\n                        _supports[0] = vertexA;\n                        _supports[1] = vertexB;\n                        return _supports;\n                    }\n                    _supports[0] = vertexA;\n                    _supports[1] = vertexC;\n                    return _supports;\n                };\n            /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * A reference to the pair using this collision record, if there is one.\n     *\n     * @property pair\n     * @type {pair|null}\n     * @default null\n     */ /**\n     * A flag that indicates if the bodies were colliding when the collision was last updated.\n     * \n     * @property collided\n     * @type boolean\n     * @default false\n     */ /**\n     * The first body part represented by the collision (see also `collision.parentA`).\n     * \n     * @property bodyA\n     * @type body\n     */ /**\n     * The second body part represented by the collision (see also `collision.parentB`).\n     * \n     * @property bodyB\n     * @type body\n     */ /**\n     * The first body represented by the collision (i.e. `collision.bodyA.parent`).\n     * \n     * @property parentA\n     * @type body\n     */ /**\n     * The second body represented by the collision (i.e. `collision.bodyB.parent`).\n     * \n     * @property parentB\n     * @type body\n     */ /**\n     * A `Number` that represents the minimum separating distance between the bodies along the collision normal.\n     *\n     * @readOnly\n     * @property depth\n     * @type number\n     * @default 0\n     */ /**\n     * A normalised `Vector` that represents the direction between the bodies that provides the minimum separating distance.\n     *\n     * @property normal\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A normalised `Vector` that is the tangent direction to the collision normal.\n     *\n     * @property tangent\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Vector` that represents the direction and depth of the collision.\n     *\n     * @property penetration\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * An array of body vertices that represent the support points in the collision.\n     * These are the deepest vertices (along the collision normal) of each body that are contained by the other body's vertices.\n     *\n     * @property supports\n     * @type vector[]\n     * @default []\n     */ })();\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __nested_webpack_require_162469__) {\n            /**\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\n*\n* @class Pair\n*/ var Pair = {};\n            module1.exports = Pair;\n            var Contact = __nested_webpack_require_162469__(16);\n            (function() {\n                /**\n     * Creates a pair.\n     * @method create\n     * @param {collision} collision\n     * @param {number} timestamp\n     * @return {pair} A new pair\n     */ Pair.create = function(collision, timestamp) {\n                    var bodyA = collision.bodyA, bodyB = collision.bodyB;\n                    var pair = {\n                        id: Pair.id(bodyA, bodyB),\n                        bodyA: bodyA,\n                        bodyB: bodyB,\n                        collision: collision,\n                        contacts: [],\n                        activeContacts: [],\n                        separation: 0,\n                        isActive: true,\n                        confirmedActive: true,\n                        isSensor: bodyA.isSensor || bodyB.isSensor,\n                        timeCreated: timestamp,\n                        timeUpdated: timestamp,\n                        inverseMass: 0,\n                        friction: 0,\n                        frictionStatic: 0,\n                        restitution: 0,\n                        slop: 0\n                    };\n                    Pair.update(pair, collision, timestamp);\n                    return pair;\n                };\n                /**\n     * Updates a pair given a collision.\n     * @method update\n     * @param {pair} pair\n     * @param {collision} collision\n     * @param {number} timestamp\n     */ Pair.update = function(pair, collision, timestamp) {\n                    var contacts = pair.contacts, supports = collision.supports, activeContacts = pair.activeContacts, parentA = collision.parentA, parentB = collision.parentB, parentAVerticesLength = parentA.vertices.length;\n                    pair.isActive = true;\n                    pair.timeUpdated = timestamp;\n                    pair.collision = collision;\n                    pair.separation = collision.depth;\n                    pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n                    pair.friction = parentA.friction < parentB.friction ? parentA.friction : parentB.friction;\n                    pair.frictionStatic = parentA.frictionStatic > parentB.frictionStatic ? parentA.frictionStatic : parentB.frictionStatic;\n                    pair.restitution = parentA.restitution > parentB.restitution ? parentA.restitution : parentB.restitution;\n                    pair.slop = parentA.slop > parentB.slop ? parentA.slop : parentB.slop;\n                    collision.pair = pair;\n                    activeContacts.length = 0;\n                    for(var i = 0; i < supports.length; i++){\n                        var support = supports[i], contactId = support.body === parentA ? support.index : parentAVerticesLength + support.index, contact = contacts[contactId];\n                        if (contact) {\n                            activeContacts.push(contact);\n                        } else {\n                            activeContacts.push(contacts[contactId] = Contact.create(support));\n                        }\n                    }\n                };\n                /**\n     * Set a pair as active or inactive.\n     * @method setActive\n     * @param {pair} pair\n     * @param {bool} isActive\n     * @param {number} timestamp\n     */ Pair.setActive = function(pair, isActive, timestamp) {\n                    if (isActive) {\n                        pair.isActive = true;\n                        pair.timeUpdated = timestamp;\n                    } else {\n                        pair.isActive = false;\n                        pair.activeContacts.length = 0;\n                    }\n                };\n                /**\n     * Get the id for the given pair.\n     * @method id\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {string} Unique pairId\n     */ Pair.id = function(bodyA, bodyB) {\n                    if (bodyA.id < bodyB.id) {\n                        return \"A\" + bodyA.id + \"B\" + bodyB.id;\n                    } else {\n                        return \"A\" + bodyB.id + \"B\" + bodyA.id;\n                    }\n                };\n            })();\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __nested_webpack_require_166869__) {\n            /**\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\n* The stiffness of constraints can be modified to create springs or elastic.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Constraint\n*/ var Constraint = {};\n            module1.exports = Constraint;\n            var Vertices = __nested_webpack_require_166869__(3);\n            var Vector = __nested_webpack_require_166869__(2);\n            var Sleeping = __nested_webpack_require_166869__(7);\n            var Bounds = __nested_webpack_require_166869__(1);\n            var Axes = __nested_webpack_require_166869__(11);\n            var Common = __nested_webpack_require_166869__(0);\n            (function() {\n                Constraint._warming = 0.4;\n                Constraint._torqueDampen = 1;\n                Constraint._minLength = 0.000001;\n                /**\n     * Creates a new constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\n     * For compound bodies, constraints must be applied to the parent body (not one of its parts).\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {constraint} constraint\n     */ Constraint.create = function(options) {\n                    var constraint = options;\n                    // if bodies defined but no points, use body centre\n                    if (constraint.bodyA && !constraint.pointA) constraint.pointA = {\n                        x: 0,\n                        y: 0\n                    };\n                    if (constraint.bodyB && !constraint.pointB) constraint.pointB = {\n                        x: 0,\n                        y: 0\n                    };\n                    // calculate static length using initial world space points\n                    var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\n                    constraint.length = typeof constraint.length !== \"undefined\" ? constraint.length : length;\n                    // option defaults\n                    constraint.id = constraint.id || Common.nextId();\n                    constraint.label = constraint.label || \"Constraint\";\n                    constraint.type = \"constraint\";\n                    constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);\n                    constraint.damping = constraint.damping || 0;\n                    constraint.angularStiffness = constraint.angularStiffness || 0;\n                    constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\n                    constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\n                    constraint.plugin = {};\n                    // render\n                    var render = {\n                        visible: true,\n                        lineWidth: 2,\n                        strokeStyle: \"#ffffff\",\n                        type: \"line\",\n                        anchors: true\n                    };\n                    if (constraint.length === 0 && constraint.stiffness > 0.1) {\n                        render.type = \"pin\";\n                        render.anchors = false;\n                    } else if (constraint.stiffness < 0.9) {\n                        render.type = \"spring\";\n                    }\n                    constraint.render = Common.extend(render, constraint.render);\n                    return constraint;\n                };\n                /**\n     * Prepares for solving by constraint warming.\n     * @private\n     * @method preSolveAll\n     * @param {body[]} bodies\n     */ Constraint.preSolveAll = function(bodies) {\n                    for(var i = 0; i < bodies.length; i += 1){\n                        var body = bodies[i], impulse = body.constraintImpulse;\n                        if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {\n                            continue;\n                        }\n                        body.position.x += impulse.x;\n                        body.position.y += impulse.y;\n                        body.angle += impulse.angle;\n                    }\n                };\n                /**\n     * Solves all constraints in a list of collisions.\n     * @private\n     * @method solveAll\n     * @param {constraint[]} constraints\n     * @param {number} delta\n     */ Constraint.solveAll = function(constraints, delta) {\n                    var timeScale = Common.clamp(delta / Common._baseDelta, 0, 1);\n                    // Solve fixed constraints first.\n                    for(var i = 0; i < constraints.length; i += 1){\n                        var constraint = constraints[i], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;\n                        if (fixedA || fixedB) {\n                            Constraint.solve(constraints[i], timeScale);\n                        }\n                    }\n                    // Solve free constraints last.\n                    for(i = 0; i < constraints.length; i += 1){\n                        constraint = constraints[i];\n                        fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;\n                        fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;\n                        if (!fixedA && !fixedB) {\n                            Constraint.solve(constraints[i], timeScale);\n                        }\n                    }\n                };\n                /**\n     * Solves a distance constraint with Gauss-Siedel method.\n     * @private\n     * @method solve\n     * @param {constraint} constraint\n     * @param {number} timeScale\n     */ Constraint.solve = function(constraint, timeScale) {\n                    var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;\n                    if (!bodyA && !bodyB) return;\n                    // update reference angle\n                    if (bodyA && !bodyA.isStatic) {\n                        Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);\n                        constraint.angleA = bodyA.angle;\n                    }\n                    // update reference angle\n                    if (bodyB && !bodyB.isStatic) {\n                        Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);\n                        constraint.angleB = bodyB.angle;\n                    }\n                    var pointAWorld = pointA, pointBWorld = pointB;\n                    if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\n                    if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\n                    if (!pointAWorld || !pointBWorld) return;\n                    var delta = Vector.sub(pointAWorld, pointBWorld), currentLength = Vector.magnitude(delta);\n                    // prevent singularity\n                    if (currentLength < Constraint._minLength) {\n                        currentLength = Constraint._minLength;\n                    }\n                    // solve distance constraint with Gauss-Siedel method\n                    var difference = (currentLength - constraint.length) / currentLength, isRigid = constraint.stiffness >= 1 || constraint.length === 0, stiffness = isRigid ? constraint.stiffness * timeScale : constraint.stiffness * timeScale * timeScale, damping = constraint.damping * timeScale, force = Vector.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;\n                    if (damping > 0) {\n                        var zero = Vector.create();\n                        normal = Vector.div(delta, currentLength);\n                        relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);\n                        normalVelocity = Vector.dot(normal, relativeVelocity);\n                    }\n                    if (bodyA && !bodyA.isStatic) {\n                        share = bodyA.inverseMass / massTotal;\n                        // keep track of applied impulses for post solving\n                        bodyA.constraintImpulse.x -= force.x * share;\n                        bodyA.constraintImpulse.y -= force.y * share;\n                        // apply forces\n                        bodyA.position.x -= force.x * share;\n                        bodyA.position.y -= force.y * share;\n                        // apply damping\n                        if (damping > 0) {\n                            bodyA.positionPrev.x -= damping * normal.x * normalVelocity * share;\n                            bodyA.positionPrev.y -= damping * normal.y * normalVelocity * share;\n                        }\n                        // apply torque\n                        torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);\n                        bodyA.constraintImpulse.angle -= torque;\n                        bodyA.angle -= torque;\n                    }\n                    if (bodyB && !bodyB.isStatic) {\n                        share = bodyB.inverseMass / massTotal;\n                        // keep track of applied impulses for post solving\n                        bodyB.constraintImpulse.x += force.x * share;\n                        bodyB.constraintImpulse.y += force.y * share;\n                        // apply forces\n                        bodyB.position.x += force.x * share;\n                        bodyB.position.y += force.y * share;\n                        // apply damping\n                        if (damping > 0) {\n                            bodyB.positionPrev.x += damping * normal.x * normalVelocity * share;\n                            bodyB.positionPrev.y += damping * normal.y * normalVelocity * share;\n                        }\n                        // apply torque\n                        torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);\n                        bodyB.constraintImpulse.angle += torque;\n                        bodyB.angle += torque;\n                    }\n                };\n                /**\n     * Performs body updates required after solving constraints.\n     * @private\n     * @method postSolveAll\n     * @param {body[]} bodies\n     */ Constraint.postSolveAll = function(bodies) {\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], impulse = body.constraintImpulse;\n                        if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {\n                            continue;\n                        }\n                        Sleeping.set(body, false);\n                        // update geometry and reset\n                        for(var j = 0; j < body.parts.length; j++){\n                            var part = body.parts[j];\n                            Vertices.translate(part.vertices, impulse);\n                            if (j > 0) {\n                                part.position.x += impulse.x;\n                                part.position.y += impulse.y;\n                            }\n                            if (impulse.angle !== 0) {\n                                Vertices.rotate(part.vertices, impulse.angle, body.position);\n                                Axes.rotate(part.axes, impulse.angle);\n                                if (j > 0) {\n                                    Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);\n                                }\n                            }\n                            Bounds.update(part.bounds, part.vertices, body.velocity);\n                        }\n                        // dampen the cached impulse for warming next step\n                        impulse.angle *= Constraint._warming;\n                        impulse.x *= Constraint._warming;\n                        impulse.y *= Constraint._warming;\n                    }\n                };\n                /**\n     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.\n     * @method pointAWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */ Constraint.pointAWorld = function(constraint) {\n                    return {\n                        x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + (constraint.pointA ? constraint.pointA.x : 0),\n                        y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + (constraint.pointA ? constraint.pointA.y : 0)\n                    };\n                };\n                /**\n     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.\n     * @method pointBWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */ Constraint.pointBWorld = function(constraint) {\n                    return {\n                        x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + (constraint.pointB ? constraint.pointB.x : 0),\n                        y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + (constraint.pointB ? constraint.pointB.y : 0)\n                    };\n                };\n            /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */ /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */ /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Constraint\"\n     */ /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */ /**\n     * A flag that indicates if the constraint should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */ /**\n     * A `Number` that defines the line width to use when rendering the constraint outline.\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 2\n     */ /**\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */ /**\n     * A `String` that defines the constraint rendering type. \n     * The possible values are 'line', 'pin', 'spring'.\n     * An appropriate render type will be automatically chosen unless one is given in options.\n     *\n     * @property render.type\n     * @type string\n     * @default 'line'\n     */ /**\n     * A `Boolean` that defines if the constraint's anchor points should be rendered.\n     *\n     * @property render.anchors\n     * @type boolean\n     * @default true\n     */ /**\n     * The first possible `Body` that this constraint is attached to.\n     *\n     * @property bodyA\n     * @type body\n     * @default null\n     */ /**\n     * The second possible `Body` that this constraint is attached to.\n     *\n     * @property bodyB\n     * @type body\n     * @default null\n     */ /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n     *\n     * @property pointA\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.\n     *\n     * @property pointB\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */ /**\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\n     * A value of `1` means the constraint should be very stiff.\n     * A value of `0.2` means the constraint acts like a soft spring.\n     *\n     * @property stiffness\n     * @type number\n     * @default 1\n     */ /**\n     * A `Number` that specifies the damping of the constraint, \n     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\n     * Damping will only be apparent when the constraint also has a very low `stiffness`.\n     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\n     * A value of `0` means the constraint will apply no damping.\n     *\n     * @property damping\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that specifies the target resting length of the constraint. \n     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     *\n     * @property length\n     * @type number\n     */ /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */ })();\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __nested_webpack_require_185293__) {\n            /**\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\n*\n* @class Axes\n*/ var Axes = {};\n            module1.exports = Axes;\n            var Vector = __nested_webpack_require_185293__(2);\n            var Common = __nested_webpack_require_185293__(0);\n            (function() {\n                /**\n     * Creates a new set of axes from the given vertices.\n     * @method fromVertices\n     * @param {vertices} vertices\n     * @return {axes} A new axes from the given vertices\n     */ Axes.fromVertices = function(vertices) {\n                    var axes = {};\n                    // find the unique axes, using edge normal gradients\n                    for(var i = 0; i < vertices.length; i++){\n                        var j = (i + 1) % vertices.length, normal = Vector.normalise({\n                            x: vertices[j].y - vertices[i].y,\n                            y: vertices[i].x - vertices[j].x\n                        }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;\n                        // limit precision\n                        gradient = gradient.toFixed(3).toString();\n                        axes[gradient] = normal;\n                    }\n                    return Common.values(axes);\n                };\n                /**\n     * Rotates a set of axes by the given angle.\n     * @method rotate\n     * @param {axes} axes\n     * @param {number} angle\n     */ Axes.rotate = function(axes, angle) {\n                    if (angle === 0) return;\n                    var cos = Math.cos(angle), sin = Math.sin(angle);\n                    for(var i = 0; i < axes.length; i++){\n                        var axis = axes[i], xx;\n                        xx = axis.x * cos - axis.y * sin;\n                        axis.y = axis.x * sin + axis.y * cos;\n                        axis.x = xx;\n                    }\n                };\n            })();\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_187273__) {\n            /**\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \n* with commonly used body configurations (such as rectangles, circles and other polygons).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Bodies\n*/ // TODO: true circle bodies\n            var Bodies = {};\n            module1.exports = Bodies;\n            var Vertices = __nested_webpack_require_187273__(3);\n            var Common = __nested_webpack_require_187273__(0);\n            var Body = __nested_webpack_require_187273__(4);\n            var Bounds = __nested_webpack_require_187273__(1);\n            var Vector = __nested_webpack_require_187273__(2);\n            (function() {\n                /**\n     * Creates a new rigid body model with a rectangle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method rectangle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {object} [options]\n     * @return {body} A new rectangle body\n     */ Bodies.rectangle = function(x, y, width, height, options) {\n                    options = options || {};\n                    var rectangle = {\n                        label: \"Rectangle Body\",\n                        position: {\n                            x: x,\n                            y: y\n                        },\n                        vertices: Vertices.fromPath(\"L 0 0 L \" + width + \" 0 L \" + width + \" \" + height + \" L 0 \" + height)\n                    };\n                    if (options.chamfer) {\n                        var chamfer = options.chamfer;\n                        rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n                        delete options.chamfer;\n                    }\n                    return Body.create(Common.extend({}, rectangle, options));\n                };\n                /**\n     * Creates a new rigid body model with a trapezoid hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method trapezoid\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} slope\n     * @param {object} [options]\n     * @return {body} A new trapezoid body\n     */ Bodies.trapezoid = function(x, y, width, height, slope, options) {\n                    options = options || {};\n                    slope *= 0.5;\n                    var roof = (1 - slope * 2) * width;\n                    var x1 = width * slope, x2 = x1 + roof, x3 = x2 + x1, verticesPath;\n                    if (slope < 0.5) {\n                        verticesPath = \"L 0 0 L \" + x1 + \" \" + -height + \" L \" + x2 + \" \" + -height + \" L \" + x3 + \" 0\";\n                    } else {\n                        verticesPath = \"L 0 0 L \" + x2 + \" \" + -height + \" L \" + x3 + \" 0\";\n                    }\n                    var trapezoid = {\n                        label: \"Trapezoid Body\",\n                        position: {\n                            x: x,\n                            y: y\n                        },\n                        vertices: Vertices.fromPath(verticesPath)\n                    };\n                    if (options.chamfer) {\n                        var chamfer = options.chamfer;\n                        trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n                        delete options.chamfer;\n                    }\n                    return Body.create(Common.extend({}, trapezoid, options));\n                };\n                /**\n     * Creates a new rigid body model with a circle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {object} [options]\n     * @param {number} [maxSides]\n     * @return {body} A new circle body\n     */ Bodies.circle = function(x, y, radius, options, maxSides) {\n                    options = options || {};\n                    var circle = {\n                        label: \"Circle Body\",\n                        circleRadius: radius\n                    };\n                    // approximate circles with polygons until true circles implemented in SAT\n                    maxSides = maxSides || 25;\n                    var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\n                    // optimisation: always use even number of sides (half the number of unique axes)\n                    if (sides % 2 === 1) sides += 1;\n                    return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n                };\n                /**\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method polygon\n     * @param {number} x\n     * @param {number} y\n     * @param {number} sides\n     * @param {number} radius\n     * @param {object} [options]\n     * @return {body} A new regular polygon body\n     */ Bodies.polygon = function(x, y, sides, radius, options) {\n                    options = options || {};\n                    if (sides < 3) return Bodies.circle(x, y, radius, options);\n                    var theta = 2 * Math.PI / sides, path = \"\", offset = theta * 0.5;\n                    for(var i = 0; i < sides; i += 1){\n                        var angle = offset + i * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;\n                        path += \"L \" + xx.toFixed(3) + \" \" + yy.toFixed(3) + \" \";\n                    }\n                    var polygon = {\n                        label: \"Polygon Body\",\n                        position: {\n                            x: x,\n                            y: y\n                        },\n                        vertices: Vertices.fromPath(path)\n                    };\n                    if (options.chamfer) {\n                        var chamfer = options.chamfer;\n                        polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n                        delete options.chamfer;\n                    }\n                    return Body.create(Common.extend({}, polygon, options));\n                };\n                /**\n     * Utility to create a compound body based on set(s) of vertices.\n     * \n     * _Note:_ To optionally enable automatic concave vertices decomposition the [poly-decomp](https://github.com/schteppe/poly-decomp.js) \n     * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.\n     * \n     * The resulting vertices are reorientated about their centre of mass,\n     * and offset such that `body.position` corresponds to this point.\n     * \n     * The resulting offset may be found if needed by subtracting `body.bounds` from the original input bounds.\n     * To later move the centre of mass see `Body.setCentre`.\n     * \n     * Note that automatic conconcave decomposition results are not always optimal. \n     * For best results, simplify the input vertices as much as possible first.\n     * By default this function applies some addtional simplification to help.\n     * \n     * Some outputs may also require further manual processing afterwards to be robust.\n     * In particular some parts may need to be overlapped to avoid collision gaps.\n     * Thin parts and sharp points should be avoided or removed where possible.\n     *\n     * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults.\n     * \n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method fromVertices\n     * @param {number} x\n     * @param {number} y\n     * @param {array} vertexSets One or more arrays of vertex points e.g. `[[{ x: 0, y: 0 }...], ...]`.\n     * @param {object} [options] The body options.\n     * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`.\n     * @param {number} [removeCollinear=0.01] Threshold when simplifying vertices along the same edge.\n     * @param {number} [minimumArea=10] Threshold when removing small parts.\n     * @param {number} [removeDuplicatePoints=0.01] Threshold when simplifying nearby vertices.\n     * @return {body}\n     */ Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {\n                    var decomp = Common.getDecomp(), canDecomp, body, parts, isConvex, isConcave, vertices, i, j, k, v, z;\n                    // check decomp is as expected\n                    canDecomp = Boolean(decomp && decomp.quickDecomp);\n                    options = options || {};\n                    parts = [];\n                    flagInternal = typeof flagInternal !== \"undefined\" ? flagInternal : false;\n                    removeCollinear = typeof removeCollinear !== \"undefined\" ? removeCollinear : 0.01;\n                    minimumArea = typeof minimumArea !== \"undefined\" ? minimumArea : 10;\n                    removeDuplicatePoints = typeof removeDuplicatePoints !== \"undefined\" ? removeDuplicatePoints : 0.01;\n                    // ensure vertexSets is an array of arrays\n                    if (!Common.isArray(vertexSets[0])) {\n                        vertexSets = [\n                            vertexSets\n                        ];\n                    }\n                    for(v = 0; v < vertexSets.length; v += 1){\n                        vertices = vertexSets[v];\n                        isConvex = Vertices.isConvex(vertices);\n                        isConcave = !isConvex;\n                        if (isConcave && !canDecomp) {\n                            Common.warnOnce(\"Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices.\");\n                        }\n                        if (isConvex || !canDecomp) {\n                            if (isConvex) {\n                                vertices = Vertices.clockwiseSort(vertices);\n                            } else {\n                                // fallback to convex hull when decomposition is not possible\n                                vertices = Vertices.hull(vertices);\n                            }\n                            parts.push({\n                                position: {\n                                    x: x,\n                                    y: y\n                                },\n                                vertices: vertices\n                            });\n                        } else {\n                            // initialise a decomposition\n                            var concave = vertices.map(function(vertex) {\n                                return [\n                                    vertex.x,\n                                    vertex.y\n                                ];\n                            });\n                            // vertices are concave and simple, we can decompose into parts\n                            decomp.makeCCW(concave);\n                            if (removeCollinear !== false) decomp.removeCollinearPoints(concave, removeCollinear);\n                            if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints) decomp.removeDuplicatePoints(concave, removeDuplicatePoints);\n                            // use the quick decomposition algorithm (Bayazit)\n                            var decomposed = decomp.quickDecomp(concave);\n                            // for each decomposed chunk\n                            for(i = 0; i < decomposed.length; i++){\n                                var chunk = decomposed[i];\n                                // convert vertices into the correct structure\n                                var chunkVertices = chunk.map(function(vertices) {\n                                    return {\n                                        x: vertices[0],\n                                        y: vertices[1]\n                                    };\n                                });\n                                // skip small chunks\n                                if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea) continue;\n                                // create a compound part\n                                parts.push({\n                                    position: Vertices.centre(chunkVertices),\n                                    vertices: chunkVertices\n                                });\n                            }\n                        }\n                    }\n                    // create body parts\n                    for(i = 0; i < parts.length; i++){\n                        parts[i] = Body.create(Common.extend(parts[i], options));\n                    }\n                    // flag internal edges (coincident part edges)\n                    if (flagInternal) {\n                        var coincident_max_dist = 5;\n                        for(i = 0; i < parts.length; i++){\n                            var partA = parts[i];\n                            for(j = i + 1; j < parts.length; j++){\n                                var partB = parts[j];\n                                if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n                                    var pav = partA.vertices, pbv = partB.vertices;\n                                    // iterate vertices of both parts\n                                    for(k = 0; k < partA.vertices.length; k++){\n                                        for(z = 0; z < partB.vertices.length; z++){\n                                            // find distances between the vertices\n                                            var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])), db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\n                                            // if both vertices are very close, consider the edge concident (internal)\n                                            if (da < coincident_max_dist && db < coincident_max_dist) {\n                                                pav[k].isInternal = true;\n                                                pbv[z].isInternal = true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (parts.length > 1) {\n                        // create the parent body to be returned, that contains generated compound parts\n                        body = Body.create(Common.extend({\n                            parts: parts.slice(0)\n                        }, options));\n                        // offset such that body.position is at the centre off mass\n                        Body.setPosition(body, {\n                            x: x,\n                            y: y\n                        });\n                        return body;\n                    } else {\n                        return parts[0];\n                    }\n                };\n            })();\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __nested_webpack_require_203501__) {\n            /**\n* The `Matter.Detector` module contains methods for efficiently detecting collisions between a list of bodies using a broadphase algorithm.\n*\n* @class Detector\n*/ var Detector = {};\n            module1.exports = Detector;\n            var Common = __nested_webpack_require_203501__(0);\n            var Collision = __nested_webpack_require_203501__(8);\n            (function() {\n                /**\n     * Creates a new collision detector.\n     * @method create\n     * @param {} options\n     * @return {detector} A new collision detector\n     */ Detector.create = function(options) {\n                    var defaults = {\n                        bodies: [],\n                        pairs: null\n                    };\n                    return Common.extend(defaults, options);\n                };\n                /**\n     * Sets the list of bodies in the detector.\n     * @method setBodies\n     * @param {detector} detector\n     * @param {body[]} bodies\n     */ Detector.setBodies = function(detector, bodies) {\n                    detector.bodies = bodies.slice(0);\n                };\n                /**\n     * Clears the detector including its list of bodies.\n     * @method clear\n     * @param {detector} detector\n     */ Detector.clear = function(detector) {\n                    detector.bodies = [];\n                };\n                /**\n     * Efficiently finds all collisions among all the bodies in `detector.bodies` using a broadphase algorithm.\n     * \n     * _Note:_ The specific ordering of collisions returned is not guaranteed between releases and may change for performance reasons.\n     * If a specific ordering is required then apply a sort to the resulting array.\n     * @method collisions\n     * @param {detector} detector\n     * @return {collision[]} collisions\n     */ Detector.collisions = function(detector) {\n                    var collisions = [], pairs = detector.pairs, bodies = detector.bodies, bodiesLength = bodies.length, canCollide = Detector.canCollide, collides = Collision.collides, i, j;\n                    bodies.sort(Detector._compareBoundsX);\n                    for(i = 0; i < bodiesLength; i++){\n                        var bodyA = bodies[i], boundsA = bodyA.bounds, boundXMax = bodyA.bounds.max.x, boundYMax = bodyA.bounds.max.y, boundYMin = bodyA.bounds.min.y, bodyAStatic = bodyA.isStatic || bodyA.isSleeping, partsALength = bodyA.parts.length, partsASingle = partsALength === 1;\n                        for(j = i + 1; j < bodiesLength; j++){\n                            var bodyB = bodies[j], boundsB = bodyB.bounds;\n                            if (boundsB.min.x > boundXMax) {\n                                break;\n                            }\n                            if (boundYMax < boundsB.min.y || boundYMin > boundsB.max.y) {\n                                continue;\n                            }\n                            if (bodyAStatic && (bodyB.isStatic || bodyB.isSleeping)) {\n                                continue;\n                            }\n                            if (!canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) {\n                                continue;\n                            }\n                            var partsBLength = bodyB.parts.length;\n                            if (partsASingle && partsBLength === 1) {\n                                var collision = collides(bodyA, bodyB, pairs);\n                                if (collision) {\n                                    collisions.push(collision);\n                                }\n                            } else {\n                                var partsAStart = partsALength > 1 ? 1 : 0, partsBStart = partsBLength > 1 ? 1 : 0;\n                                for(var k = partsAStart; k < partsALength; k++){\n                                    var partA = bodyA.parts[k], boundsA = partA.bounds;\n                                    for(var z = partsBStart; z < partsBLength; z++){\n                                        var partB = bodyB.parts[z], boundsB = partB.bounds;\n                                        if (boundsA.min.x > boundsB.max.x || boundsA.max.x < boundsB.min.x || boundsA.max.y < boundsB.min.y || boundsA.min.y > boundsB.max.y) {\n                                            continue;\n                                        }\n                                        var collision = collides(partA, partB, pairs);\n                                        if (collision) {\n                                            collisions.push(collision);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return collisions;\n                };\n                /**\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\n     * See `body.collisionFilter` for more information.\n     * @method canCollide\n     * @param {} filterA\n     * @param {} filterB\n     * @return {bool} `true` if collision can occur\n     */ Detector.canCollide = function(filterA, filterB) {\n                    if (filterA.group === filterB.group && filterA.group !== 0) return filterA.group > 0;\n                    return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n                };\n                /**\n     * The comparison function used in the broadphase algorithm.\n     * Returns the signed delta of the bodies bounds on the x-axis.\n     * @private\n     * @method _sortCompare\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {number} The signed delta used for sorting\n     */ Detector._compareBoundsX = function(bodyA, bodyB) {\n                    return bodyA.bounds.min.x - bodyB.bounds.min.x;\n                };\n            /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * The array of `Matter.Body` between which the detector finds collisions.\n     * \n     * _Note:_ The order of bodies in this array _is not fixed_ and will be continually managed by the detector.\n     * @property bodies\n     * @type body[]\n     * @default []\n     */ /**\n     * Optional. A `Matter.Pairs` object from which previous collision objects may be reused. Intended for internal `Matter.Engine` usage.\n     * @property pairs\n     * @type {pairs|null}\n     * @default null\n     */ })();\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __nested_webpack_require_209972__) {\n            /**\n* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.\n*\n* @class Mouse\n*/ var Mouse = {};\n            module1.exports = Mouse;\n            var Common = __nested_webpack_require_209972__(0);\n            (function() {\n                /**\n     * Creates a mouse input.\n     * @method create\n     * @param {HTMLElement} element\n     * @return {mouse} A new mouse\n     */ Mouse.create = function(element) {\n                    var mouse = {};\n                    if (!element) {\n                        Common.log(\"Mouse.create: element was undefined, defaulting to document.body\", \"warn\");\n                    }\n                    mouse.element = element || document.body;\n                    mouse.absolute = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.position = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.mousedownPosition = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.mouseupPosition = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.offset = {\n                        x: 0,\n                        y: 0\n                    };\n                    mouse.scale = {\n                        x: 1,\n                        y: 1\n                    };\n                    mouse.wheelDelta = 0;\n                    mouse.button = -1;\n                    mouse.pixelRatio = parseInt(mouse.element.getAttribute(\"data-pixel-ratio\"), 10) || 1;\n                    mouse.sourceEvents = {\n                        mousemove: null,\n                        mousedown: null,\n                        mouseup: null,\n                        mousewheel: null\n                    };\n                    mouse.mousemove = function(event) {\n                        var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;\n                        if (touches) {\n                            mouse.button = 0;\n                            event.preventDefault();\n                        }\n                        mouse.absolute.x = position.x;\n                        mouse.absolute.y = position.y;\n                        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                        mouse.sourceEvents.mousemove = event;\n                    };\n                    mouse.mousedown = function(event) {\n                        var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;\n                        if (touches) {\n                            mouse.button = 0;\n                            event.preventDefault();\n                        } else {\n                            mouse.button = event.button;\n                        }\n                        mouse.absolute.x = position.x;\n                        mouse.absolute.y = position.y;\n                        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                        mouse.mousedownPosition.x = mouse.position.x;\n                        mouse.mousedownPosition.y = mouse.position.y;\n                        mouse.sourceEvents.mousedown = event;\n                    };\n                    mouse.mouseup = function(event) {\n                        var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio), touches = event.changedTouches;\n                        if (touches) {\n                            event.preventDefault();\n                        }\n                        mouse.button = -1;\n                        mouse.absolute.x = position.x;\n                        mouse.absolute.y = position.y;\n                        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                        mouse.mouseupPosition.x = mouse.position.x;\n                        mouse.mouseupPosition.y = mouse.position.y;\n                        mouse.sourceEvents.mouseup = event;\n                    };\n                    mouse.mousewheel = function(event) {\n                        mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n                        event.preventDefault();\n                    };\n                    Mouse.setElement(mouse, mouse.element);\n                    return mouse;\n                };\n                /**\n     * Sets the element the mouse is bound to (and relative to).\n     * @method setElement\n     * @param {mouse} mouse\n     * @param {HTMLElement} element\n     */ Mouse.setElement = function(mouse, element) {\n                    mouse.element = element;\n                    element.addEventListener(\"mousemove\", mouse.mousemove);\n                    element.addEventListener(\"mousedown\", mouse.mousedown);\n                    element.addEventListener(\"mouseup\", mouse.mouseup);\n                    element.addEventListener(\"mousewheel\", mouse.mousewheel);\n                    element.addEventListener(\"DOMMouseScroll\", mouse.mousewheel);\n                    element.addEventListener(\"touchmove\", mouse.mousemove);\n                    element.addEventListener(\"touchstart\", mouse.mousedown);\n                    element.addEventListener(\"touchend\", mouse.mouseup);\n                };\n                /**\n     * Clears all captured source events.\n     * @method clearSourceEvents\n     * @param {mouse} mouse\n     */ Mouse.clearSourceEvents = function(mouse) {\n                    mouse.sourceEvents.mousemove = null;\n                    mouse.sourceEvents.mousedown = null;\n                    mouse.sourceEvents.mouseup = null;\n                    mouse.sourceEvents.mousewheel = null;\n                    mouse.wheelDelta = 0;\n                };\n                /**\n     * Sets the mouse position offset.\n     * @method setOffset\n     * @param {mouse} mouse\n     * @param {vector} offset\n     */ Mouse.setOffset = function(mouse, offset) {\n                    mouse.offset.x = offset.x;\n                    mouse.offset.y = offset.y;\n                    mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                    mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                };\n                /**\n     * Sets the mouse position scale.\n     * @method setScale\n     * @param {mouse} mouse\n     * @param {vector} scale\n     */ Mouse.setScale = function(mouse, scale) {\n                    mouse.scale.x = scale.x;\n                    mouse.scale.y = scale.y;\n                    mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n                    mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n                };\n                /**\n     * Gets the mouse position relative to an element given a screen pixel ratio.\n     * @method _getRelativeMousePosition\n     * @private\n     * @param {} event\n     * @param {} element\n     * @param {number} pixelRatio\n     * @return {}\n     */ Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {\n                    var elementBounds = element.getBoundingClientRect(), rootNode = document.documentElement || document.body.parentNode || document.body, scrollX = window.pageXOffset !== undefined ? window.pageXOffset : rootNode.scrollLeft, scrollY = window.pageYOffset !== undefined ? window.pageYOffset : rootNode.scrollTop, touches = event.changedTouches, x, y;\n                    if (touches) {\n                        x = touches[0].pageX - elementBounds.left - scrollX;\n                        y = touches[0].pageY - elementBounds.top - scrollY;\n                    } else {\n                        x = event.pageX - elementBounds.left - scrollX;\n                        y = event.pageY - elementBounds.top - scrollY;\n                    }\n                    return {\n                        x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),\n                        y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)\n                    };\n                };\n            })();\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_218591__) {\n            /**\n* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\n*\n* @class Plugin\n*/ var Plugin = {};\n            module1.exports = Plugin;\n            var Common = __nested_webpack_require_218591__(0);\n            (function() {\n                Plugin._registry = {};\n                /**\n     * Registers a plugin object so it can be resolved later by name.\n     * @method register\n     * @param plugin {} The plugin to register.\n     * @return {object} The plugin.\n     */ Plugin.register = function(plugin) {\n                    if (!Plugin.isPlugin(plugin)) {\n                        Common.warn(\"Plugin.register:\", Plugin.toString(plugin), \"does not implement all required fields.\");\n                    }\n                    if (plugin.name in Plugin._registry) {\n                        var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;\n                        if (pluginVersion > registeredVersion) {\n                            Common.warn(\"Plugin.register:\", Plugin.toString(registered), \"was upgraded to\", Plugin.toString(plugin));\n                            Plugin._registry[plugin.name] = plugin;\n                        } else if (pluginVersion < registeredVersion) {\n                            Common.warn(\"Plugin.register:\", Plugin.toString(registered), \"can not be downgraded to\", Plugin.toString(plugin));\n                        } else if (plugin !== registered) {\n                            Common.warn(\"Plugin.register:\", Plugin.toString(plugin), \"is already registered to different plugin object\");\n                        }\n                    } else {\n                        Plugin._registry[plugin.name] = plugin;\n                    }\n                    return plugin;\n                };\n                /**\n     * Resolves a dependency to a plugin object from the registry if it exists. \n     * The `dependency` may contain a version, but only the name matters when resolving.\n     * @method resolve\n     * @param dependency {string} The dependency.\n     * @return {object} The plugin if resolved, otherwise `undefined`.\n     */ Plugin.resolve = function(dependency) {\n                    return Plugin._registry[Plugin.dependencyParse(dependency).name];\n                };\n                /**\n     * Returns a pretty printed plugin name and version.\n     * @method toString\n     * @param plugin {} The plugin.\n     * @return {string} Pretty printed plugin name and version.\n     */ Plugin.toString = function(plugin) {\n                    return typeof plugin === \"string\" ? plugin : (plugin.name || \"anonymous\") + \"@\" + (plugin.version || plugin.range || \"0.0.0\");\n                };\n                /**\n     * Returns `true` if the object meets the minimum standard to be considered a plugin.\n     * This means it must define the following properties:\n     * - `name`\n     * - `version`\n     * - `install`\n     * @method isPlugin\n     * @param obj {} The obj to test.\n     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\n     */ Plugin.isPlugin = function(obj) {\n                    return obj && obj.name && obj.version && obj.install;\n                };\n                /**\n     * Returns `true` if a plugin with the given `name` been installed on `module`.\n     * @method isUsed\n     * @param module {} The module.\n     * @param name {string} The plugin name.\n     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\n     */ Plugin.isUsed = function(module1, name) {\n                    return module1.used.indexOf(name) > -1;\n                };\n                /**\n     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\n     * If `plugin.for` is not specified then it is assumed to be applicable.\n     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\n     * @method isFor\n     * @param plugin {} The plugin.\n     * @param module {} The module.\n     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\n     */ Plugin.isFor = function(plugin, module1) {\n                    var parsed = plugin.for && Plugin.dependencyParse(plugin.for);\n                    return !plugin.for || module1.name === parsed.name && Plugin.versionSatisfies(module1.version, parsed.range);\n                };\n                /**\n     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\n     * For installing plugins on `Matter` see the convenience function `Matter.use`.\n     * Plugins may be specified either by their name or a reference to the plugin object.\n     * Plugins themselves may specify further dependencies, but each plugin is installed only once.\n     * Order is important, a topological sort is performed to find the best resulting order of installation.\n     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\n     * This function logs the resulting status of each dependency in the console, along with any warnings.\n     * - A green tick ✅ indicates a dependency was resolved and installed.\n     * - An orange diamond 🔶 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\n     * - A red cross ❌ indicates a dependency could not be resolved.\n     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\n     * @method use\n     * @param module {} The module install plugins on.\n     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\n     */ Plugin.use = function(module1, plugins) {\n                    module1.uses = (module1.uses || []).concat(plugins || []);\n                    if (module1.uses.length === 0) {\n                        Common.warn(\"Plugin.use:\", Plugin.toString(module1), \"does not specify any dependencies to install.\");\n                        return;\n                    }\n                    var dependencies = Plugin.dependencies(module1), sortedDependencies = Common.topologicalSort(dependencies), status = [];\n                    for(var i = 0; i < sortedDependencies.length; i += 1){\n                        if (sortedDependencies[i] === module1.name) {\n                            continue;\n                        }\n                        var plugin = Plugin.resolve(sortedDependencies[i]);\n                        if (!plugin) {\n                            status.push(\"❌ \" + sortedDependencies[i]);\n                            continue;\n                        }\n                        if (Plugin.isUsed(module1, plugin.name)) {\n                            continue;\n                        }\n                        if (!Plugin.isFor(plugin, module1)) {\n                            Common.warn(\"Plugin.use:\", Plugin.toString(plugin), \"is for\", plugin.for, \"but installed on\", Plugin.toString(module1) + \".\");\n                            plugin._warned = true;\n                        }\n                        if (plugin.install) {\n                            plugin.install(module1);\n                        } else {\n                            Common.warn(\"Plugin.use:\", Plugin.toString(plugin), \"does not specify an install function.\");\n                            plugin._warned = true;\n                        }\n                        if (plugin._warned) {\n                            status.push(\"\\uD83D\\uDD36 \" + Plugin.toString(plugin));\n                            delete plugin._warned;\n                        } else {\n                            status.push(\"✅ \" + Plugin.toString(plugin));\n                        }\n                        module1.used.push(plugin.name);\n                    }\n                    if (status.length > 0) {\n                        Common.info(status.join(\"  \"));\n                    }\n                };\n                /**\n     * Recursively finds all of a module's dependencies and returns a flat dependency graph.\n     * @method dependencies\n     * @param module {} The module.\n     * @return {object} A dependency graph.\n     */ Plugin.dependencies = function(module1, tracked) {\n                    var parsedBase = Plugin.dependencyParse(module1), name = parsedBase.name;\n                    tracked = tracked || {};\n                    if (name in tracked) {\n                        return;\n                    }\n                    module1 = Plugin.resolve(module1) || module1;\n                    tracked[name] = Common.map(module1.uses || [], function(dependency) {\n                        if (Plugin.isPlugin(dependency)) {\n                            Plugin.register(dependency);\n                        }\n                        var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);\n                        if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {\n                            Common.warn(\"Plugin.dependencies:\", Plugin.toString(resolved), \"does not satisfy\", Plugin.toString(parsed), \"used by\", Plugin.toString(parsedBase) + \".\");\n                            resolved._warned = true;\n                            module1._warned = true;\n                        } else if (!resolved) {\n                            Common.warn(\"Plugin.dependencies:\", Plugin.toString(dependency), \"used by\", Plugin.toString(parsedBase), \"could not be resolved.\");\n                            module1._warned = true;\n                        }\n                        return parsed.name;\n                    });\n                    for(var i = 0; i < tracked[name].length; i += 1){\n                        Plugin.dependencies(tracked[name][i], tracked);\n                    }\n                    return tracked;\n                };\n                /**\n     * Parses a dependency string into its components.\n     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * This function can also handle dependencies that are already resolved (e.g. a module object).\n     * @method dependencyParse\n     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\n     * @return {object} The dependency parsed into its components.\n     */ Plugin.dependencyParse = function(dependency) {\n                    if (Common.isString(dependency)) {\n                        var pattern = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-+]+)?))?$/;\n                        if (!pattern.test(dependency)) {\n                            Common.warn(\"Plugin.dependencyParse:\", dependency, \"is not a valid dependency string.\");\n                        }\n                        return {\n                            name: dependency.split(\"@\")[0],\n                            range: dependency.split(\"@\")[1] || \"*\"\n                        };\n                    }\n                    return {\n                        name: dependency.name,\n                        range: dependency.range || dependency.version\n                    };\n                };\n                /**\n     * Parses a version string into its components.  \n     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\n     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\n     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\n     * Only the following range types are supported:\n     * - Tilde ranges e.g. `~1.2.3`\n     * - Caret ranges e.g. `^1.2.3`\n     * - Greater than ranges e.g. `>1.2.3`\n     * - Greater than or equal ranges e.g. `>=1.2.3`\n     * - Exact version e.g. `1.2.3`\n     * - Any version `*`\n     * @method versionParse\n     * @param range {string} The version string.\n     * @return {object} The version range parsed into its components.\n     */ Plugin.versionParse = function(range) {\n                    var pattern = /^(\\*)|(\\^|~|>=|>)?\\s*((\\d+)\\.(\\d+)\\.(\\d+))(-[0-9A-Za-z-+]+)?$/;\n                    if (!pattern.test(range)) {\n                        Common.warn(\"Plugin.versionParse:\", range, \"is not a valid version or range.\");\n                    }\n                    var parts = pattern.exec(range);\n                    var major = Number(parts[4]);\n                    var minor = Number(parts[5]);\n                    var patch = Number(parts[6]);\n                    return {\n                        isRange: Boolean(parts[1] || parts[2]),\n                        version: parts[3],\n                        range: range,\n                        operator: parts[1] || parts[2] || \"\",\n                        major: major,\n                        minor: minor,\n                        patch: patch,\n                        parts: [\n                            major,\n                            minor,\n                            patch\n                        ],\n                        prerelease: parts[7],\n                        number: major * 1e8 + minor * 1e4 + patch\n                    };\n                };\n                /**\n     * Returns `true` if `version` satisfies the given `range`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\n     * @method versionSatisfies\n     * @param version {string} The version string.\n     * @param range {string} The range string.\n     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\n     */ Plugin.versionSatisfies = function(version, range) {\n                    range = range || \"*\";\n                    var r = Plugin.versionParse(range), v = Plugin.versionParse(version);\n                    if (r.isRange) {\n                        if (r.operator === \"*\" || version === \"*\") {\n                            return true;\n                        }\n                        if (r.operator === \">\") {\n                            return v.number > r.number;\n                        }\n                        if (r.operator === \">=\") {\n                            return v.number >= r.number;\n                        }\n                        if (r.operator === \"~\") {\n                            return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;\n                        }\n                        if (r.operator === \"^\") {\n                            if (r.major > 0) {\n                                return v.major === r.major && v.number >= r.number;\n                            }\n                            if (r.minor > 0) {\n                                return v.minor === r.minor && v.patch >= r.patch;\n                            }\n                            return v.patch === r.patch;\n                        }\n                    }\n                    return version === range || version === \"*\";\n                };\n            })();\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1) {\n            /**\n* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.\n*\n* @class Contact\n*/ var Contact = {};\n            module1.exports = Contact;\n            (function() {\n                /**\n     * Creates a new contact.\n     * @method create\n     * @param {vertex} vertex\n     * @return {contact} A new contact\n     */ Contact.create = function(vertex) {\n                    return {\n                        vertex: vertex,\n                        normalImpulse: 0,\n                        tangentImpulse: 0\n                    };\n                };\n            })();\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_234572__) {\n            /**\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\n* An engine is a controller that manages updating the simulation of the world.\n* See `Matter.Runner` for an optional game loop utility.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Engine\n*/ var Engine = {};\n            module1.exports = Engine;\n            var Sleeping = __nested_webpack_require_234572__(7);\n            var Resolver = __nested_webpack_require_234572__(18);\n            var Detector = __nested_webpack_require_234572__(13);\n            var Pairs = __nested_webpack_require_234572__(19);\n            var Events = __nested_webpack_require_234572__(5);\n            var Composite = __nested_webpack_require_234572__(6);\n            var Constraint = __nested_webpack_require_234572__(10);\n            var Common = __nested_webpack_require_234572__(0);\n            var Body = __nested_webpack_require_234572__(4);\n            (function() {\n                /**\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {engine} engine\n     */ Engine.create = function(options) {\n                    options = options || {};\n                    var defaults = {\n                        positionIterations: 6,\n                        velocityIterations: 4,\n                        constraintIterations: 2,\n                        enableSleeping: false,\n                        events: [],\n                        plugin: {},\n                        gravity: {\n                            x: 0,\n                            y: 1,\n                            scale: 0.001\n                        },\n                        timing: {\n                            timestamp: 0,\n                            timeScale: 1,\n                            lastDelta: 0,\n                            lastElapsed: 0\n                        }\n                    };\n                    var engine = Common.extend(defaults, options);\n                    engine.world = options.world || Composite.create({\n                        label: \"World\"\n                    });\n                    engine.pairs = options.pairs || Pairs.create();\n                    engine.detector = options.detector || Detector.create();\n                    // for temporary back compatibility only\n                    engine.grid = {\n                        buckets: []\n                    };\n                    engine.world.gravity = engine.gravity;\n                    engine.broadphase = engine.grid;\n                    engine.metrics = {};\n                    return engine;\n                };\n                /**\n     * Moves the simulation forward in time by `delta` milliseconds.\n     * Triggers `beforeUpdate` and `afterUpdate` events.\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\n     * @method update\n     * @param {engine} engine\n     * @param {number} [delta=16.666]\n     */ Engine.update = function(engine, delta) {\n                    var startTime = Common.now();\n                    var world = engine.world, detector = engine.detector, pairs = engine.pairs, timing = engine.timing, timestamp = timing.timestamp, i;\n                    delta = typeof delta !== \"undefined\" ? delta : Common._baseDelta;\n                    delta *= timing.timeScale;\n                    // increment timestamp\n                    timing.timestamp += delta;\n                    timing.lastDelta = delta;\n                    // create an event object\n                    var event = {\n                        timestamp: timing.timestamp,\n                        delta: delta\n                    };\n                    Events.trigger(engine, \"beforeUpdate\", event);\n                    // get all bodies and all constraints in the world\n                    var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world);\n                    // if the world has changed\n                    if (world.isModified) {\n                        // update the detector bodies\n                        Detector.setBodies(detector, allBodies);\n                        // reset all composite modified flags\n                        Composite.setModified(world, false, false, true);\n                    }\n                    // update sleeping if enabled\n                    if (engine.enableSleeping) Sleeping.update(allBodies, delta);\n                    // apply gravity to all bodies\n                    Engine._bodiesApplyGravity(allBodies, engine.gravity);\n                    // update all body position and rotation by integration\n                    if (delta > 0) {\n                        Engine._bodiesUpdate(allBodies, delta);\n                    }\n                    // update all constraints (first pass)\n                    Constraint.preSolveAll(allBodies);\n                    for(i = 0; i < engine.constraintIterations; i++){\n                        Constraint.solveAll(allConstraints, delta);\n                    }\n                    Constraint.postSolveAll(allBodies);\n                    // find all collisions\n                    detector.pairs = engine.pairs;\n                    var collisions = Detector.collisions(detector);\n                    // update collision pairs\n                    Pairs.update(pairs, collisions, timestamp);\n                    // wake up bodies involved in collisions\n                    if (engine.enableSleeping) Sleeping.afterCollisions(pairs.list);\n                    // trigger collision events\n                    if (pairs.collisionStart.length > 0) Events.trigger(engine, \"collisionStart\", {\n                        pairs: pairs.collisionStart\n                    });\n                    // iteratively resolve position between collisions\n                    var positionDamping = Common.clamp(20 / engine.positionIterations, 0, 1);\n                    Resolver.preSolvePosition(pairs.list);\n                    for(i = 0; i < engine.positionIterations; i++){\n                        Resolver.solvePosition(pairs.list, delta, positionDamping);\n                    }\n                    Resolver.postSolvePosition(allBodies);\n                    // update all constraints (second pass)\n                    Constraint.preSolveAll(allBodies);\n                    for(i = 0; i < engine.constraintIterations; i++){\n                        Constraint.solveAll(allConstraints, delta);\n                    }\n                    Constraint.postSolveAll(allBodies);\n                    // iteratively resolve velocity between collisions\n                    Resolver.preSolveVelocity(pairs.list);\n                    for(i = 0; i < engine.velocityIterations; i++){\n                        Resolver.solveVelocity(pairs.list, delta);\n                    }\n                    // update body speed and velocity properties\n                    Engine._bodiesUpdateVelocities(allBodies);\n                    // trigger collision events\n                    if (pairs.collisionActive.length > 0) Events.trigger(engine, \"collisionActive\", {\n                        pairs: pairs.collisionActive\n                    });\n                    if (pairs.collisionEnd.length > 0) Events.trigger(engine, \"collisionEnd\", {\n                        pairs: pairs.collisionEnd\n                    });\n                    // clear force buffers\n                    Engine._bodiesClearForces(allBodies);\n                    Events.trigger(engine, \"afterUpdate\", event);\n                    // log the time elapsed computing this update\n                    engine.timing.lastElapsed = Common.now() - startTime;\n                    return engine;\n                };\n                /**\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\n     * @method merge\n     * @param {engine} engineA\n     * @param {engine} engineB\n     */ Engine.merge = function(engineA, engineB) {\n                    Common.extend(engineA, engineB);\n                    if (engineB.world) {\n                        engineA.world = engineB.world;\n                        Engine.clear(engineA);\n                        var bodies = Composite.allBodies(engineA.world);\n                        for(var i = 0; i < bodies.length; i++){\n                            var body = bodies[i];\n                            Sleeping.set(body, false);\n                            body.id = Common.nextId();\n                        }\n                    }\n                };\n                /**\n     * Clears the engine pairs and detector.\n     * @method clear\n     * @param {engine} engine\n     */ Engine.clear = function(engine) {\n                    Pairs.clear(engine.pairs);\n                    Detector.clear(engine.detector);\n                };\n                /**\n     * Zeroes the `body.force` and `body.torque` force buffers.\n     * @method _bodiesClearForces\n     * @private\n     * @param {body[]} bodies\n     */ Engine._bodiesClearForces = function(bodies) {\n                    var bodiesLength = bodies.length;\n                    for(var i = 0; i < bodiesLength; i++){\n                        var body = bodies[i];\n                        // reset force buffers\n                        body.force.x = 0;\n                        body.force.y = 0;\n                        body.torque = 0;\n                    }\n                };\n                /**\n     * Applies gravitational acceleration to all `bodies`.\n     * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet.\n     * \n     * @method _bodiesApplyGravity\n     * @private\n     * @param {body[]} bodies\n     * @param {vector} gravity\n     */ Engine._bodiesApplyGravity = function(bodies, gravity) {\n                    var gravityScale = typeof gravity.scale !== \"undefined\" ? gravity.scale : 0.001, bodiesLength = bodies.length;\n                    if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {\n                        return;\n                    }\n                    for(var i = 0; i < bodiesLength; i++){\n                        var body = bodies[i];\n                        if (body.isStatic || body.isSleeping) continue;\n                        // add the resultant force of gravity\n                        body.force.y += body.mass * gravity.y * gravityScale;\n                        body.force.x += body.mass * gravity.x * gravityScale;\n                    }\n                };\n                /**\n     * Applies `Body.update` to all given `bodies`.\n     * @method _bodiesUpdate\n     * @private\n     * @param {body[]} bodies\n     * @param {number} delta The amount of time elapsed between updates\n     */ Engine._bodiesUpdate = function(bodies, delta) {\n                    var bodiesLength = bodies.length;\n                    for(var i = 0; i < bodiesLength; i++){\n                        var body = bodies[i];\n                        if (body.isStatic || body.isSleeping) continue;\n                        Body.update(body, delta);\n                    }\n                };\n                /**\n     * Applies `Body.updateVelocities` to all given `bodies`.\n     * @method _bodiesUpdateVelocities\n     * @private\n     * @param {body[]} bodies\n     */ Engine._bodiesUpdateVelocities = function(bodies) {\n                    var bodiesLength = bodies.length;\n                    for(var i = 0; i < bodiesLength; i++){\n                        Body.updateVelocities(bodies[i]);\n                    }\n                };\n            /**\n     * A deprecated alias for `Runner.run`, use `Matter.Runner.run(engine)` instead and see `Matter.Runner` for more information.\n     * @deprecated use Matter.Runner.run(engine) instead\n     * @method run\n     * @param {engine} engine\n     */ /**\n    * Fired just before an update\n    *\n    * @event beforeUpdate\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after engine update and all collision events\n    *\n    * @event afterUpdate\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\n    *\n    * @event collisionStart\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\n    *\n    * @event collisionActive\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /**\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\n    *\n    * @event collisionEnd\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * An integer `Number` that specifies the number of position iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property positionIterations\n     * @type number\n     * @default 6\n     */ /**\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property velocityIterations\n     * @type number\n     * @default 4\n     */ /**\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     * The default value of `2` is usually very adequate.\n     *\n     * @property constraintIterations\n     * @type number\n     * @default 2\n     */ /**\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\n     *\n     * @property enableSleeping\n     * @type boolean\n     * @default false\n     */ /**\n     * An `Object` containing properties regarding the timing systems of the engine. \n     *\n     * @property timing\n     * @type object\n     */ /**\n     * A `Number` that specifies the global scaling factor of time for all bodies.\n     * A value of `0` freezes the simulation.\n     * A value of `0.1` gives a slow-motion effect.\n     * A value of `1.2` gives a speed-up effect.\n     *\n     * @property timing.timeScale\n     * @type number\n     * @default 1\n     */ /**\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \n     * It is incremented on every `Engine.update` by the given `delta` argument. \n     * \n     * @property timing.timestamp\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that represents the total execution time elapsed during the last `Engine.update` in milliseconds.\n     * It is updated by timing from the start of the last `Engine.update` call until it ends.\n     *\n     * This value will also include the total execution time of all event handlers directly or indirectly triggered by the engine update.\n     * \n     * @property timing.lastElapsed\n     * @type number\n     * @default 0\n     */ /**\n     * A `Number` that represents the `delta` value used in the last engine update.\n     * \n     * @property timing.lastDelta\n     * @type number\n     * @default 0\n     */ /**\n     * A `Matter.Detector` instance.\n     *\n     * @property detector\n     * @type detector\n     * @default a Matter.Detector instance\n     */ /**\n     * A `Matter.Grid` instance.\n     *\n     * @deprecated replaced by `engine.detector`\n     * @property grid\n     * @type grid\n     * @default a Matter.Grid instance\n     */ /**\n     * Replaced by and now alias for `engine.grid`.\n     *\n     * @deprecated replaced by `engine.detector`\n     * @property broadphase\n     * @type grid\n     * @default a Matter.Grid instance\n     */ /**\n     * The root `Matter.Composite` instance that will contain all bodies, constraints and other composites to be simulated by this engine.\n     *\n     * @property world\n     * @type composite\n     * @default a Matter.Composite instance\n     */ /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */ /**\n     * An optional gravitational acceleration applied to all bodies in `engine.world` on every update.\n     * \n     * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet. For gravity in other contexts, disable this and apply forces as needed.\n     * \n     * To disable set the `scale` component to `0`.\n     * \n     * This is split into three components for ease of use:  \n     * a normalised direction (`x` and `y`) and magnitude (`scale`).\n     *\n     * @property gravity\n     * @type object\n     */ /**\n     * The gravitational direction normal `x` component, to be multiplied by `gravity.scale`.\n     * \n     * @property gravity.x\n     * @type object\n     * @default 0\n     */ /**\n     * The gravitational direction normal `y` component, to be multiplied by `gravity.scale`.\n     *\n     * @property gravity.y\n     * @type object\n     * @default 1\n     */ /**\n     * The magnitude of the gravitational acceleration.\n     * \n     * @property gravity.scale\n     * @type object\n     * @default 0.001\n     */ })();\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_253845__) {\n            /**\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\n*\n* @class Resolver\n*/ var Resolver = {};\n            module1.exports = Resolver;\n            var Vertices = __nested_webpack_require_253845__(3);\n            var Common = __nested_webpack_require_253845__(0);\n            var Bounds = __nested_webpack_require_253845__(1);\n            (function() {\n                Resolver._restingThresh = 2;\n                Resolver._restingThreshTangent = Math.sqrt(6);\n                Resolver._positionDampen = 0.9;\n                Resolver._positionWarming = 0.8;\n                Resolver._frictionNormalMultiplier = 5;\n                Resolver._frictionMaxStatic = Number.MAX_VALUE;\n                /**\n     * Prepare pairs for position solving.\n     * @method preSolvePosition\n     * @param {pair[]} pairs\n     */ Resolver.preSolvePosition = function(pairs) {\n                    var i, pair, activeCount, pairsLength = pairs.length;\n                    // find total contacts on each body\n                    for(i = 0; i < pairsLength; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive) continue;\n                        activeCount = pair.activeContacts.length;\n                        pair.collision.parentA.totalContacts += activeCount;\n                        pair.collision.parentB.totalContacts += activeCount;\n                    }\n                };\n                /**\n     * Find a solution for pair positions.\n     * @method solvePosition\n     * @param {pair[]} pairs\n     * @param {number} delta\n     * @param {number} [damping=1]\n     */ Resolver.solvePosition = function(pairs, delta, damping) {\n                    var i, pair, collision, bodyA, bodyB, normal, contactShare, positionImpulse, positionDampen = Resolver._positionDampen * (damping || 1), slopDampen = Common.clamp(delta / Common._baseDelta, 0, 1), pairsLength = pairs.length;\n                    // find impulses required to resolve penetration\n                    for(i = 0; i < pairsLength; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive || pair.isSensor) continue;\n                        collision = pair.collision;\n                        bodyA = collision.parentA;\n                        bodyB = collision.parentB;\n                        normal = collision.normal;\n                        // get current separation between body edges involved in collision\n                        pair.separation = normal.x * (bodyB.positionImpulse.x + collision.penetration.x - bodyA.positionImpulse.x) + normal.y * (bodyB.positionImpulse.y + collision.penetration.y - bodyA.positionImpulse.y);\n                    }\n                    for(i = 0; i < pairsLength; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive || pair.isSensor) continue;\n                        collision = pair.collision;\n                        bodyA = collision.parentA;\n                        bodyB = collision.parentB;\n                        normal = collision.normal;\n                        positionImpulse = pair.separation - pair.slop * slopDampen;\n                        if (bodyA.isStatic || bodyB.isStatic) positionImpulse *= 2;\n                        if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                            contactShare = positionDampen / bodyA.totalContacts;\n                            bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;\n                            bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;\n                        }\n                        if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                            contactShare = positionDampen / bodyB.totalContacts;\n                            bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;\n                            bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;\n                        }\n                    }\n                };\n                /**\n     * Apply position resolution.\n     * @method postSolvePosition\n     * @param {body[]} bodies\n     */ Resolver.postSolvePosition = function(bodies) {\n                    var positionWarming = Resolver._positionWarming, bodiesLength = bodies.length, verticesTranslate = Vertices.translate, boundsUpdate = Bounds.update;\n                    for(var i = 0; i < bodiesLength; i++){\n                        var body = bodies[i], positionImpulse = body.positionImpulse, positionImpulseX = positionImpulse.x, positionImpulseY = positionImpulse.y, velocity = body.velocity;\n                        // reset contact count\n                        body.totalContacts = 0;\n                        if (positionImpulseX !== 0 || positionImpulseY !== 0) {\n                            // update body geometry\n                            for(var j = 0; j < body.parts.length; j++){\n                                var part = body.parts[j];\n                                verticesTranslate(part.vertices, positionImpulse);\n                                boundsUpdate(part.bounds, part.vertices, velocity);\n                                part.position.x += positionImpulseX;\n                                part.position.y += positionImpulseY;\n                            }\n                            // move the body without changing velocity\n                            body.positionPrev.x += positionImpulseX;\n                            body.positionPrev.y += positionImpulseY;\n                            if (positionImpulseX * velocity.x + positionImpulseY * velocity.y < 0) {\n                                // reset cached impulse if the body has velocity along it\n                                positionImpulse.x = 0;\n                                positionImpulse.y = 0;\n                            } else {\n                                // warm the next iteration\n                                positionImpulse.x *= positionWarming;\n                                positionImpulse.y *= positionWarming;\n                            }\n                        }\n                    }\n                };\n                /**\n     * Prepare pairs for velocity solving.\n     * @method preSolveVelocity\n     * @param {pair[]} pairs\n     */ Resolver.preSolveVelocity = function(pairs) {\n                    var pairsLength = pairs.length, i, j;\n                    for(i = 0; i < pairsLength; i++){\n                        var pair = pairs[i];\n                        if (!pair.isActive || pair.isSensor) continue;\n                        var contacts = pair.activeContacts, contactsLength = contacts.length, collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent;\n                        // resolve each contact\n                        for(j = 0; j < contactsLength; j++){\n                            var contact = contacts[j], contactVertex = contact.vertex, normalImpulse = contact.normalImpulse, tangentImpulse = contact.tangentImpulse;\n                            if (normalImpulse !== 0 || tangentImpulse !== 0) {\n                                // total impulse from contact\n                                var impulseX = normal.x * normalImpulse + tangent.x * tangentImpulse, impulseY = normal.y * normalImpulse + tangent.y * tangentImpulse;\n                                // apply impulse from contact\n                                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                                    bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                                    bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                                    bodyA.anglePrev += bodyA.inverseInertia * ((contactVertex.x - bodyA.position.x) * impulseY - (contactVertex.y - bodyA.position.y) * impulseX);\n                                }\n                                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                                    bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                                    bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                                    bodyB.anglePrev -= bodyB.inverseInertia * ((contactVertex.x - bodyB.position.x) * impulseY - (contactVertex.y - bodyB.position.y) * impulseX);\n                                }\n                            }\n                        }\n                    }\n                };\n                /**\n     * Find a solution for pair velocities.\n     * @method solveVelocity\n     * @param {pair[]} pairs\n     * @param {number} delta\n     */ Resolver.solveVelocity = function(pairs, delta) {\n                    var timeScale = delta / Common._baseDelta, timeScaleSquared = timeScale * timeScale, timeScaleCubed = timeScaleSquared * timeScale, restingThresh = -Resolver._restingThresh * timeScale, restingThreshTangent = Resolver._restingThreshTangent, frictionNormalMultiplier = Resolver._frictionNormalMultiplier * timeScale, frictionMaxStatic = Resolver._frictionMaxStatic, pairsLength = pairs.length, tangentImpulse, maxFriction, i, j;\n                    for(i = 0; i < pairsLength; i++){\n                        var pair = pairs[i];\n                        if (!pair.isActive || pair.isSensor) continue;\n                        var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, bodyAVelocity = bodyA.velocity, bodyBVelocity = bodyB.velocity, normalX = collision.normal.x, normalY = collision.normal.y, tangentX = collision.tangent.x, tangentY = collision.tangent.y, contacts = pair.activeContacts, contactsLength = contacts.length, contactShare = 1 / contactsLength, inverseMassTotal = bodyA.inverseMass + bodyB.inverseMass, friction = pair.friction * pair.frictionStatic * frictionNormalMultiplier;\n                        // update body velocities\n                        bodyAVelocity.x = bodyA.position.x - bodyA.positionPrev.x;\n                        bodyAVelocity.y = bodyA.position.y - bodyA.positionPrev.y;\n                        bodyBVelocity.x = bodyB.position.x - bodyB.positionPrev.x;\n                        bodyBVelocity.y = bodyB.position.y - bodyB.positionPrev.y;\n                        bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n                        bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\n                        // resolve each contact\n                        for(j = 0; j < contactsLength; j++){\n                            var contact = contacts[j], contactVertex = contact.vertex;\n                            var offsetAX = contactVertex.x - bodyA.position.x, offsetAY = contactVertex.y - bodyA.position.y, offsetBX = contactVertex.x - bodyB.position.x, offsetBY = contactVertex.y - bodyB.position.y;\n                            var velocityPointAX = bodyAVelocity.x - offsetAY * bodyA.angularVelocity, velocityPointAY = bodyAVelocity.y + offsetAX * bodyA.angularVelocity, velocityPointBX = bodyBVelocity.x - offsetBY * bodyB.angularVelocity, velocityPointBY = bodyBVelocity.y + offsetBX * bodyB.angularVelocity;\n                            var relativeVelocityX = velocityPointAX - velocityPointBX, relativeVelocityY = velocityPointAY - velocityPointBY;\n                            var normalVelocity = normalX * relativeVelocityX + normalY * relativeVelocityY, tangentVelocity = tangentX * relativeVelocityX + tangentY * relativeVelocityY;\n                            // coulomb friction\n                            var normalOverlap = pair.separation + normalVelocity;\n                            var normalForce = Math.min(normalOverlap, 1);\n                            normalForce = normalOverlap < 0 ? 0 : normalForce;\n                            var frictionLimit = normalForce * friction;\n                            if (tangentVelocity < -frictionLimit || tangentVelocity > frictionLimit) {\n                                maxFriction = tangentVelocity > 0 ? tangentVelocity : -tangentVelocity;\n                                tangentImpulse = pair.friction * (tangentVelocity > 0 ? 1 : -1) * timeScaleCubed;\n                                if (tangentImpulse < -maxFriction) {\n                                    tangentImpulse = -maxFriction;\n                                } else if (tangentImpulse > maxFriction) {\n                                    tangentImpulse = maxFriction;\n                                }\n                            } else {\n                                tangentImpulse = tangentVelocity;\n                                maxFriction = frictionMaxStatic;\n                            }\n                            // account for mass, inertia and contact offset\n                            var oAcN = offsetAX * normalY - offsetAY * normalX, oBcN = offsetBX * normalY - offsetBY * normalX, share = contactShare / (inverseMassTotal + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);\n                            // raw impulses\n                            var normalImpulse = (1 + pair.restitution) * normalVelocity * share;\n                            tangentImpulse *= share;\n                            // handle high velocity and resting collisions separately\n                            if (normalVelocity < restingThresh) {\n                                // high normal velocity so clear cached contact normal impulse\n                                contact.normalImpulse = 0;\n                            } else {\n                                // solve resting collision constraints using Erin Catto's method (GDC08)\n                                // impulse constraint tends to 0\n                                var contactNormalImpulse = contact.normalImpulse;\n                                contact.normalImpulse += normalImpulse;\n                                if (contact.normalImpulse > 0) contact.normalImpulse = 0;\n                                normalImpulse = contact.normalImpulse - contactNormalImpulse;\n                            }\n                            // handle high velocity and resting collisions separately\n                            if (tangentVelocity < -restingThreshTangent || tangentVelocity > restingThreshTangent) {\n                                // high tangent velocity so clear cached contact tangent impulse\n                                contact.tangentImpulse = 0;\n                            } else {\n                                // solve resting collision constraints using Erin Catto's method (GDC08)\n                                // tangent impulse tends to -tangentSpeed or +tangentSpeed\n                                var contactTangentImpulse = contact.tangentImpulse;\n                                contact.tangentImpulse += tangentImpulse;\n                                if (contact.tangentImpulse < -maxFriction) contact.tangentImpulse = -maxFriction;\n                                if (contact.tangentImpulse > maxFriction) contact.tangentImpulse = maxFriction;\n                                tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n                            }\n                            // total impulse from contact\n                            var impulseX = normalX * normalImpulse + tangentX * tangentImpulse, impulseY = normalY * normalImpulse + tangentY * tangentImpulse;\n                            // apply impulse from contact\n                            if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                                bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                                bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                                bodyA.anglePrev += (offsetAX * impulseY - offsetAY * impulseX) * bodyA.inverseInertia;\n                            }\n                            if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                                bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                                bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                                bodyB.anglePrev -= (offsetBX * impulseY - offsetBY * impulseX) * bodyB.inverseInertia;\n                            }\n                        }\n                    }\n                };\n            })();\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_270164__) {\n            /**\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\n*\n* @class Pairs\n*/ var Pairs = {};\n            module1.exports = Pairs;\n            var Pair = __nested_webpack_require_270164__(9);\n            var Common = __nested_webpack_require_270164__(0);\n            (function() {\n                /**\n     * Creates a new pairs structure.\n     * @method create\n     * @param {object} options\n     * @return {pairs} A new pairs structure\n     */ Pairs.create = function(options) {\n                    return Common.extend({\n                        table: {},\n                        list: [],\n                        collisionStart: [],\n                        collisionActive: [],\n                        collisionEnd: []\n                    }, options);\n                };\n                /**\n     * Updates pairs given a list of collisions.\n     * @method update\n     * @param {object} pairs\n     * @param {collision[]} collisions\n     * @param {number} timestamp\n     */ Pairs.update = function(pairs, collisions, timestamp) {\n                    var pairsList = pairs.list, pairsListLength = pairsList.length, pairsTable = pairs.table, collisionsLength = collisions.length, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collision, pairIndex, pair, i;\n                    // clear collision state arrays, but maintain old reference\n                    collisionStart.length = 0;\n                    collisionEnd.length = 0;\n                    collisionActive.length = 0;\n                    for(i = 0; i < pairsListLength; i++){\n                        pairsList[i].confirmedActive = false;\n                    }\n                    for(i = 0; i < collisionsLength; i++){\n                        collision = collisions[i];\n                        pair = collision.pair;\n                        if (pair) {\n                            // pair already exists (but may or may not be active)\n                            if (pair.isActive) {\n                                // pair exists and is active\n                                collisionActive.push(pair);\n                            } else {\n                                // pair exists but was inactive, so a collision has just started again\n                                collisionStart.push(pair);\n                            }\n                            // update the pair\n                            Pair.update(pair, collision, timestamp);\n                            pair.confirmedActive = true;\n                        } else {\n                            // pair did not exist, create a new pair\n                            pair = Pair.create(collision, timestamp);\n                            pairsTable[pair.id] = pair;\n                            // push the new pair\n                            collisionStart.push(pair);\n                            pairsList.push(pair);\n                        }\n                    }\n                    // find pairs that are no longer active\n                    var removePairIndex = [];\n                    pairsListLength = pairsList.length;\n                    for(i = 0; i < pairsListLength; i++){\n                        pair = pairsList[i];\n                        if (!pair.confirmedActive) {\n                            Pair.setActive(pair, false, timestamp);\n                            collisionEnd.push(pair);\n                            if (!pair.collision.bodyA.isSleeping && !pair.collision.bodyB.isSleeping) {\n                                removePairIndex.push(i);\n                            }\n                        }\n                    }\n                    // remove inactive pairs\n                    for(i = 0; i < removePairIndex.length; i++){\n                        pairIndex = removePairIndex[i] - i;\n                        pair = pairsList[pairIndex];\n                        pairsList.splice(pairIndex, 1);\n                        delete pairsTable[pair.id];\n                    }\n                };\n                /**\n     * Clears the given pairs structure.\n     * @method clear\n     * @param {pairs} pairs\n     * @return {pairs} pairs\n     */ Pairs.clear = function(pairs) {\n                    pairs.table = {};\n                    pairs.list.length = 0;\n                    pairs.collisionStart.length = 0;\n                    pairs.collisionActive.length = 0;\n                    pairs.collisionEnd.length = 0;\n                    return pairs;\n                };\n            })();\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_274783__) {\n            var Matter = module1.exports = __nested_webpack_require_274783__(21);\n            Matter.Axes = __nested_webpack_require_274783__(11);\n            Matter.Bodies = __nested_webpack_require_274783__(12);\n            Matter.Body = __nested_webpack_require_274783__(4);\n            Matter.Bounds = __nested_webpack_require_274783__(1);\n            Matter.Collision = __nested_webpack_require_274783__(8);\n            Matter.Common = __nested_webpack_require_274783__(0);\n            Matter.Composite = __nested_webpack_require_274783__(6);\n            Matter.Composites = __nested_webpack_require_274783__(22);\n            Matter.Constraint = __nested_webpack_require_274783__(10);\n            Matter.Contact = __nested_webpack_require_274783__(16);\n            Matter.Detector = __nested_webpack_require_274783__(13);\n            Matter.Engine = __nested_webpack_require_274783__(17);\n            Matter.Events = __nested_webpack_require_274783__(5);\n            Matter.Grid = __nested_webpack_require_274783__(23);\n            Matter.Mouse = __nested_webpack_require_274783__(14);\n            Matter.MouseConstraint = __nested_webpack_require_274783__(24);\n            Matter.Pair = __nested_webpack_require_274783__(9);\n            Matter.Pairs = __nested_webpack_require_274783__(19);\n            Matter.Plugin = __nested_webpack_require_274783__(15);\n            Matter.Query = __nested_webpack_require_274783__(25);\n            Matter.Render = __nested_webpack_require_274783__(26);\n            Matter.Resolver = __nested_webpack_require_274783__(18);\n            Matter.Runner = __nested_webpack_require_274783__(27);\n            Matter.SAT = __nested_webpack_require_274783__(28);\n            Matter.Sleeping = __nested_webpack_require_274783__(7);\n            Matter.Svg = __nested_webpack_require_274783__(29);\n            Matter.Vector = __nested_webpack_require_274783__(2);\n            Matter.Vertices = __nested_webpack_require_274783__(3);\n            Matter.World = __nested_webpack_require_274783__(30);\n            // temporary back compatibility\n            Matter.Engine.run = Matter.Runner.run;\n            Matter.Common.deprecated(Matter.Engine, \"run\", \"Engine.run ➤ use Matter.Runner.run(engine) instead\");\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1, __nested_webpack_require_276692__) {\n            /**\r\n* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n*\r\n* @class Matter\r\n*/ var Matter = {};\n            module1.exports = Matter;\n            var Plugin = __nested_webpack_require_276692__(15);\n            var Common = __nested_webpack_require_276692__(0);\n            (function() {\n                /**\r\n     * The library name.\r\n     * @property name\r\n     * @readOnly\r\n     * @type {String}\r\n     */ Matter.name = \"matter-js\";\n                /**\r\n     * The library version.\r\n     * @property version\r\n     * @readOnly\r\n     * @type {String}\r\n     */ Matter.version =  true ? \"0.19.0\" : 0;\n                /**\r\n     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n     * @property uses\r\n     * @type {Array}\r\n     */ Matter.uses = [];\n                /**\r\n     * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n     * @property used\r\n     * @readOnly\r\n     * @type {Array}\r\n     */ Matter.used = [];\n                /**\r\n     * Installs the given plugins on the `Matter` namespace.\r\n     * This is a short-hand for `Plugin.use`, see it for more information.\r\n     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n     * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n     */ Matter.use = function() {\n                    Plugin.use(Matter, Array.prototype.slice.call(arguments));\n                };\n                /**\r\n     * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method before\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */ Matter.before = function(path, func) {\n                    path = path.replace(/^Matter./, \"\");\n                    return Common.chainPathBefore(Matter, path, func);\n                };\n                /**\r\n     * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method after\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */ Matter.after = function(path, func) {\n                    path = path.replace(/^Matter./, \"\");\n                    return Common.chainPathAfter(Matter, path, func);\n                };\n            })();\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_279784__) {\n            /**\n* The `Matter.Composites` module contains factory methods for creating composite bodies\n* with commonly used configurations (such as stacks and chains).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composites\n*/ var Composites = {};\n            module1.exports = Composites;\n            var Composite = __nested_webpack_require_279784__(6);\n            var Constraint = __nested_webpack_require_279784__(10);\n            var Common = __nested_webpack_require_279784__(0);\n            var Body = __nested_webpack_require_279784__(4);\n            var Bodies = __nested_webpack_require_279784__(12);\n            var deprecated = Common.deprecated;\n            (function() {\n                /**\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method stack\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */ Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n                    var stack = Composite.create({\n                        label: \"Stack\"\n                    }), x = xx, y = yy, lastBody, i = 0;\n                    for(var row = 0; row < rows; row++){\n                        var maxHeight = 0;\n                        for(var column = 0; column < columns; column++){\n                            var body = callback(x, y, column, row, lastBody, i);\n                            if (body) {\n                                var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;\n                                if (bodyHeight > maxHeight) maxHeight = bodyHeight;\n                                Body.translate(body, {\n                                    x: bodyWidth * 0.5,\n                                    y: bodyHeight * 0.5\n                                });\n                                x = body.bounds.max.x + columnGap;\n                                Composite.addBody(stack, body);\n                                lastBody = body;\n                                i += 1;\n                            } else {\n                                x += columnGap;\n                            }\n                        }\n                        y += maxHeight + rowGap;\n                        x = xx;\n                    }\n                    return stack;\n                };\n                /**\n     * Chains all bodies in the given composite together using constraints.\n     * @method chain\n     * @param {composite} composite\n     * @param {number} xOffsetA\n     * @param {number} yOffsetA\n     * @param {number} xOffsetB\n     * @param {number} yOffsetB\n     * @param {object} options\n     * @return {composite} A new composite containing objects chained together with constraints\n     */ Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n                    var bodies = composite.bodies;\n                    for(var i = 1; i < bodies.length; i++){\n                        var bodyA = bodies[i - 1], bodyB = bodies[i], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n                        var defaults = {\n                            bodyA: bodyA,\n                            pointA: {\n                                x: bodyAWidth * xOffsetA,\n                                y: bodyAHeight * yOffsetA\n                            },\n                            bodyB: bodyB,\n                            pointB: {\n                                x: bodyBWidth * xOffsetB,\n                                y: bodyBHeight * yOffsetB\n                            }\n                        };\n                        var constraint = Common.extend(defaults, options);\n                        Composite.addConstraint(composite, Constraint.create(constraint));\n                    }\n                    composite.label += \" Chain\";\n                    return composite;\n                };\n                /**\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\n     * @method mesh\n     * @param {composite} composite\n     * @param {number} columns\n     * @param {number} rows\n     * @param {boolean} crossBrace\n     * @param {object} options\n     * @return {composite} The composite containing objects meshed together with constraints\n     */ Composites.mesh = function(composite, columns, rows, crossBrace, options) {\n                    var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;\n                    for(row = 0; row < rows; row++){\n                        for(col = 1; col < columns; col++){\n                            bodyA = bodies[col - 1 + row * columns];\n                            bodyB = bodies[col + row * columns];\n                            Composite.addConstraint(composite, Constraint.create(Common.extend({\n                                bodyA: bodyA,\n                                bodyB: bodyB\n                            }, options)));\n                        }\n                        if (row > 0) {\n                            for(col = 0; col < columns; col++){\n                                bodyA = bodies[col + (row - 1) * columns];\n                                bodyB = bodies[col + row * columns];\n                                Composite.addConstraint(composite, Constraint.create(Common.extend({\n                                    bodyA: bodyA,\n                                    bodyB: bodyB\n                                }, options)));\n                                if (crossBrace && col > 0) {\n                                    bodyC = bodies[col - 1 + (row - 1) * columns];\n                                    Composite.addConstraint(composite, Constraint.create(Common.extend({\n                                        bodyA: bodyC,\n                                        bodyB: bodyB\n                                    }, options)));\n                                }\n                                if (crossBrace && col < columns - 1) {\n                                    bodyC = bodies[col + 1 + (row - 1) * columns];\n                                    Composite.addConstraint(composite, Constraint.create(Common.extend({\n                                        bodyA: bodyC,\n                                        bodyB: bodyB\n                                    }, options)));\n                                }\n                            }\n                        }\n                    }\n                    composite.label += \" Mesh\";\n                    return composite;\n                };\n                /**\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method pyramid\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */ Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n                    return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {\n                        var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n                        if (row > actualRows) return;\n                        // reverse row order\n                        row = actualRows - row;\n                        var start = row, end = columns - 1 - row;\n                        if (column < start || column > end) return;\n                        // retroactively fix the first body's position, since width was unknown\n                        if (i === 1) {\n                            Body.translate(lastBody, {\n                                x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth,\n                                y: 0\n                            });\n                        }\n                        var xOffset = lastBody ? column * lastBodyWidth : 0;\n                        return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\n                    });\n                };\n                /**\n     * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to newtonsCradle example\n     * @method newtonsCradle\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} number\n     * @param {number} size\n     * @param {number} length\n     * @return {composite} A new composite newtonsCradle body\n     */ Composites.newtonsCradle = function(xx, yy, number, size, length) {\n                    var newtonsCradle = Composite.create({\n                        label: \"Newtons Cradle\"\n                    });\n                    for(var i = 0; i < number; i++){\n                        var separation = 1.9, circle = Bodies.circle(xx + i * (size * separation), yy + length, size, {\n                            inertia: Infinity,\n                            restitution: 1,\n                            friction: 0,\n                            frictionAir: 0.0001,\n                            slop: 1\n                        }), constraint = Constraint.create({\n                            pointA: {\n                                x: xx + i * (size * separation),\n                                y: yy\n                            },\n                            bodyB: circle\n                        });\n                        Composite.addBody(newtonsCradle, circle);\n                        Composite.addConstraint(newtonsCradle, constraint);\n                    }\n                    return newtonsCradle;\n                };\n                deprecated(Composites, \"newtonsCradle\", \"Composites.newtonsCradle ➤ moved to newtonsCradle example\");\n                /**\n     * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to car example\n     * @method car\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} width\n     * @param {number} height\n     * @param {number} wheelSize\n     * @return {composite} A new composite car body\n     */ Composites.car = function(xx, yy, width, height, wheelSize) {\n                    var group = Body.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;\n                    var car = Composite.create({\n                        label: \"Car\"\n                    }), body = Bodies.rectangle(xx, yy, width, height, {\n                        collisionFilter: {\n                            group: group\n                        },\n                        chamfer: {\n                            radius: height * 0.5\n                        },\n                        density: 0.0002\n                    });\n                    var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {\n                        collisionFilter: {\n                            group: group\n                        },\n                        friction: 0.8\n                    });\n                    var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {\n                        collisionFilter: {\n                            group: group\n                        },\n                        friction: 0.8\n                    });\n                    var axelA = Constraint.create({\n                        bodyB: body,\n                        pointB: {\n                            x: wheelAOffset,\n                            y: wheelYOffset\n                        },\n                        bodyA: wheelA,\n                        stiffness: 1,\n                        length: 0\n                    });\n                    var axelB = Constraint.create({\n                        bodyB: body,\n                        pointB: {\n                            x: wheelBOffset,\n                            y: wheelYOffset\n                        },\n                        bodyA: wheelB,\n                        stiffness: 1,\n                        length: 0\n                    });\n                    Composite.addBody(car, body);\n                    Composite.addBody(car, wheelA);\n                    Composite.addBody(car, wheelB);\n                    Composite.addConstraint(car, axelA);\n                    Composite.addConstraint(car, axelB);\n                    return car;\n                };\n                deprecated(Composites, \"car\", \"Composites.car ➤ moved to car example\");\n                /**\n     * This has now moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)\n     * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js), follow those instead as this function is deprecated here.\n     * @deprecated moved to softBody and cloth examples\n     * @method softBody\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {boolean} crossBrace\n     * @param {number} particleRadius\n     * @param {} particleOptions\n     * @param {} constraintOptions\n     * @return {composite} A new composite softBody\n     */ Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n                    particleOptions = Common.extend({\n                        inertia: Infinity\n                    }, particleOptions);\n                    constraintOptions = Common.extend({\n                        stiffness: 0.2,\n                        render: {\n                            type: \"line\",\n                            anchors: false\n                        }\n                    }, constraintOptions);\n                    var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {\n                        return Bodies.circle(x, y, particleRadius, particleOptions);\n                    });\n                    Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n                    softBody.label = \"Soft Body\";\n                    return softBody;\n                };\n                deprecated(Composites, \"softBody\", \"Composites.softBody ➤ moved to softBody and cloth examples\");\n            })();\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_295069__) {\n            /**\n* This module has now been replaced by `Matter.Detector`.\n*\n* All usage should be migrated to `Matter.Detector` or another alternative.\n* For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n*\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\n*\n* @class Grid\n* @deprecated\n*/ var Grid = {};\n            module1.exports = Grid;\n            var Pair = __nested_webpack_require_295069__(9);\n            var Common = __nested_webpack_require_295069__(0);\n            var deprecated = Common.deprecated;\n            (function() {\n                /**\n     * Creates a new grid.\n     * @deprecated replaced by Matter.Detector\n     * @method create\n     * @param {} options\n     * @return {grid} A new grid\n     */ Grid.create = function(options) {\n                    var defaults = {\n                        buckets: {},\n                        pairs: {},\n                        pairsList: [],\n                        bucketWidth: 48,\n                        bucketHeight: 48\n                    };\n                    return Common.extend(defaults, options);\n                };\n                /**\n     * The width of a single grid bucket.\n     *\n     * @property bucketWidth\n     * @type number\n     * @default 48\n     */ /**\n     * The height of a single grid bucket.\n     *\n     * @property bucketHeight\n     * @type number\n     * @default 48\n     */ /**\n     * Updates the grid.\n     * @deprecated replaced by Matter.Detector\n     * @method update\n     * @param {grid} grid\n     * @param {body[]} bodies\n     * @param {engine} engine\n     * @param {boolean} forceUpdate\n     */ Grid.update = function(grid, bodies, engine, forceUpdate) {\n                    var i, col, row, world = engine.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;\n                    for(i = 0; i < bodies.length; i++){\n                        var body = bodies[i];\n                        if (body.isSleeping && !forceUpdate) continue;\n                        // temporary back compatibility bounds check\n                        if (world.bounds && (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)) continue;\n                        var newRegion = Grid._getRegion(grid, body);\n                        // if the body has changed grid region\n                        if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n                            if (!body.region || forceUpdate) body.region = newRegion;\n                            var union = Grid._regionUnion(newRegion, body.region);\n                            // update grid buckets affected by region change\n                            // iterate over the union of both regions\n                            for(col = union.startCol; col <= union.endCol; col++){\n                                for(row = union.startRow; row <= union.endRow; row++){\n                                    bucketId = Grid._getBucketId(col, row);\n                                    bucket = buckets[bucketId];\n                                    var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;\n                                    var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;\n                                    // remove from old region buckets\n                                    if (!isInsideNewRegion && isInsideOldRegion) {\n                                        if (isInsideOldRegion) {\n                                            if (bucket) Grid._bucketRemoveBody(grid, bucket, body);\n                                        }\n                                    }\n                                    // add to new region buckets\n                                    if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {\n                                        if (!bucket) bucket = Grid._createBucket(buckets, bucketId);\n                                        Grid._bucketAddBody(grid, bucket, body);\n                                    }\n                                }\n                            }\n                            // set the new region\n                            body.region = newRegion;\n                            // flag changes so we can update pairs\n                            gridChanged = true;\n                        }\n                    }\n                    // update pairs list only if pairs changed (i.e. a body changed region)\n                    if (gridChanged) grid.pairsList = Grid._createActivePairsList(grid);\n                };\n                deprecated(Grid, \"update\", \"Grid.update ➤ replaced by Matter.Detector\");\n                /**\n     * Clears the grid.\n     * @deprecated replaced by Matter.Detector\n     * @method clear\n     * @param {grid} grid\n     */ Grid.clear = function(grid) {\n                    grid.buckets = {};\n                    grid.pairs = {};\n                    grid.pairsList = [];\n                };\n                deprecated(Grid, \"clear\", \"Grid.clear ➤ replaced by Matter.Detector\");\n                /**\n     * Finds the union of two regions.\n     * @method _regionUnion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} regionA\n     * @param {} regionB\n     * @return {} region\n     */ Grid._regionUnion = function(regionA, regionB) {\n                    var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);\n                    return Grid._createRegion(startCol, endCol, startRow, endRow);\n                };\n                /**\n     * Gets the region a given body falls in for a given grid.\n     * @method _getRegion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} body\n     * @return {} region\n     */ Grid._getRegion = function(grid, body) {\n                    var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n                    return Grid._createRegion(startCol, endCol, startRow, endRow);\n                };\n                /**\n     * Creates a region.\n     * @method _createRegion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} startCol\n     * @param {} endCol\n     * @param {} startRow\n     * @param {} endRow\n     * @return {} region\n     */ Grid._createRegion = function(startCol, endCol, startRow, endRow) {\n                    return {\n                        id: startCol + \",\" + endCol + \",\" + startRow + \",\" + endRow,\n                        startCol: startCol,\n                        endCol: endCol,\n                        startRow: startRow,\n                        endRow: endRow\n                    };\n                };\n                /**\n     * Gets the bucket id at the given position.\n     * @method _getBucketId\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} column\n     * @param {} row\n     * @return {string} bucket id\n     */ Grid._getBucketId = function(column, row) {\n                    return \"C\" + column + \"R\" + row;\n                };\n                /**\n     * Creates a bucket.\n     * @method _createBucket\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} buckets\n     * @param {} bucketId\n     * @return {} bucket\n     */ Grid._createBucket = function(buckets, bucketId) {\n                    var bucket = buckets[bucketId] = [];\n                    return bucket;\n                };\n                /**\n     * Adds a body to a bucket.\n     * @method _bucketAddBody\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */ Grid._bucketAddBody = function(grid, bucket, body) {\n                    var gridPairs = grid.pairs, pairId = Pair.id, bucketLength = bucket.length, i;\n                    // add new pairs\n                    for(i = 0; i < bucketLength; i++){\n                        var bodyB = bucket[i];\n                        if (body.id === bodyB.id || body.isStatic && bodyB.isStatic) continue;\n                        // keep track of the number of buckets the pair exists in\n                        // important for Grid.update to work\n                        var id = pairId(body, bodyB), pair = gridPairs[id];\n                        if (pair) {\n                            pair[2] += 1;\n                        } else {\n                            gridPairs[id] = [\n                                body,\n                                bodyB,\n                                1\n                            ];\n                        }\n                    }\n                    // add to bodies (after pairs, otherwise pairs with self)\n                    bucket.push(body);\n                };\n                /**\n     * Removes a body from a bucket.\n     * @method _bucketRemoveBody\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */ Grid._bucketRemoveBody = function(grid, bucket, body) {\n                    var gridPairs = grid.pairs, pairId = Pair.id, i;\n                    // remove from bucket\n                    bucket.splice(Common.indexOf(bucket, body), 1);\n                    var bucketLength = bucket.length;\n                    // update pair counts\n                    for(i = 0; i < bucketLength; i++){\n                        // keep track of the number of buckets the pair exists in\n                        // important for _createActivePairsList to work\n                        var pair = gridPairs[pairId(body, bucket[i])];\n                        if (pair) pair[2] -= 1;\n                    }\n                };\n                /**\n     * Generates a list of the active pairs in the grid.\n     * @method _createActivePairsList\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @return [] pairs\n     */ Grid._createActivePairsList = function(grid) {\n                    var pair, gridPairs = grid.pairs, pairKeys = Common.keys(gridPairs), pairKeysLength = pairKeys.length, pairs = [], k;\n                    // iterate over grid.pairs\n                    for(k = 0; k < pairKeysLength; k++){\n                        pair = gridPairs[pairKeys[k]];\n                        // if pair exists in at least one bucket\n                        // it is a pair that needs further collision testing so push it\n                        if (pair[2] > 0) {\n                            pairs.push(pair);\n                        } else {\n                            delete gridPairs[pairKeys[k]];\n                        }\n                    }\n                    return pairs;\n                };\n            })();\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __nested_webpack_require_306484__) {\n            /**\n* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.\n* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class MouseConstraint\n*/ var MouseConstraint = {};\n            module1.exports = MouseConstraint;\n            var Vertices = __nested_webpack_require_306484__(3);\n            var Sleeping = __nested_webpack_require_306484__(7);\n            var Mouse = __nested_webpack_require_306484__(14);\n            var Events = __nested_webpack_require_306484__(5);\n            var Detector = __nested_webpack_require_306484__(13);\n            var Constraint = __nested_webpack_require_306484__(10);\n            var Composite = __nested_webpack_require_306484__(6);\n            var Common = __nested_webpack_require_306484__(0);\n            var Bounds = __nested_webpack_require_306484__(1);\n            (function() {\n                /**\n     * Creates a new mouse constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {engine} engine\n     * @param {} options\n     * @return {MouseConstraint} A new MouseConstraint\n     */ MouseConstraint.create = function(engine, options) {\n                    var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);\n                    if (!mouse) {\n                        if (engine && engine.render && engine.render.canvas) {\n                            mouse = Mouse.create(engine.render.canvas);\n                        } else if (options && options.element) {\n                            mouse = Mouse.create(options.element);\n                        } else {\n                            mouse = Mouse.create();\n                            Common.warn(\"MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected\");\n                        }\n                    }\n                    var constraint = Constraint.create({\n                        label: \"Mouse Constraint\",\n                        pointA: mouse.position,\n                        pointB: {\n                            x: 0,\n                            y: 0\n                        },\n                        length: 0.01,\n                        stiffness: 0.1,\n                        angularStiffness: 1,\n                        render: {\n                            strokeStyle: \"#90EE90\",\n                            lineWidth: 3\n                        }\n                    });\n                    var defaults = {\n                        type: \"mouseConstraint\",\n                        mouse: mouse,\n                        element: null,\n                        body: null,\n                        constraint: constraint,\n                        collisionFilter: {\n                            category: 0x0001,\n                            mask: 0xFFFFFFFF,\n                            group: 0\n                        }\n                    };\n                    var mouseConstraint = Common.extend(defaults, options);\n                    Events.on(engine, \"beforeUpdate\", function() {\n                        var allBodies = Composite.allBodies(engine.world);\n                        MouseConstraint.update(mouseConstraint, allBodies);\n                        MouseConstraint._triggerEvents(mouseConstraint);\n                    });\n                    return mouseConstraint;\n                };\n                /**\n     * Updates the given mouse constraint.\n     * @private\n     * @method update\n     * @param {MouseConstraint} mouseConstraint\n     * @param {body[]} bodies\n     */ MouseConstraint.update = function(mouseConstraint, bodies) {\n                    var mouse = mouseConstraint.mouse, constraint = mouseConstraint.constraint, body = mouseConstraint.body;\n                    if (mouse.button === 0) {\n                        if (!constraint.bodyB) {\n                            for(var i = 0; i < bodies.length; i++){\n                                body = bodies[i];\n                                if (Bounds.contains(body.bounds, mouse.position) && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {\n                                    for(var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++){\n                                        var part = body.parts[j];\n                                        if (Vertices.contains(part.vertices, mouse.position)) {\n                                            constraint.pointA = mouse.position;\n                                            constraint.bodyB = mouseConstraint.body = body;\n                                            constraint.pointB = {\n                                                x: mouse.position.x - body.position.x,\n                                                y: mouse.position.y - body.position.y\n                                            };\n                                            constraint.angleB = body.angle;\n                                            Sleeping.set(body, false);\n                                            Events.trigger(mouseConstraint, \"startdrag\", {\n                                                mouse: mouse,\n                                                body: body\n                                            });\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            Sleeping.set(constraint.bodyB, false);\n                            constraint.pointA = mouse.position;\n                        }\n                    } else {\n                        constraint.bodyB = mouseConstraint.body = null;\n                        constraint.pointB = null;\n                        if (body) Events.trigger(mouseConstraint, \"enddrag\", {\n                            mouse: mouse,\n                            body: body\n                        });\n                    }\n                };\n                /**\n     * Triggers mouse constraint events.\n     * @method _triggerEvents\n     * @private\n     * @param {mouse} mouseConstraint\n     */ MouseConstraint._triggerEvents = function(mouseConstraint) {\n                    var mouse = mouseConstraint.mouse, mouseEvents = mouse.sourceEvents;\n                    if (mouseEvents.mousemove) Events.trigger(mouseConstraint, \"mousemove\", {\n                        mouse: mouse\n                    });\n                    if (mouseEvents.mousedown) Events.trigger(mouseConstraint, \"mousedown\", {\n                        mouse: mouse\n                    });\n                    if (mouseEvents.mouseup) Events.trigger(mouseConstraint, \"mouseup\", {\n                        mouse: mouse\n                    });\n                    // reset the mouse state ready for the next step\n                    Mouse.clearSourceEvents(mouse);\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired when the mouse has moved (or a touch moves) during the last step\n    *\n    * @event mousemove\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when the mouse is down (or a touch has started) during the last step\n    *\n    * @event mousedown\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when the mouse is up (or a touch has ended) during the last step\n    *\n    * @event mouseup\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when the user starts dragging a body\n    *\n    * @event startdrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired when the user ends dragging a body\n    *\n    * @event enddrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body that has stopped being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */ /**\n     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.\n     *\n     * @property mouse\n     * @type mouse\n     * @default mouse\n     */ /**\n     * The `Body` that is currently being moved by the user, or `null` if no body.\n     *\n     * @property body\n     * @type body\n     * @default null\n     */ /**\n     * The `Constraint` object that is used to move the body during interaction.\n     *\n     * @property constraint\n     * @type constraint\n     */ /**\n     * An `Object` that specifies the collision filter properties.\n     * The collision filter allows the user to define which types of body this mouse constraint can interact with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter\n     * @type object\n     */ })();\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __nested_webpack_require_316500__) {\n            /**\n* The `Matter.Query` module contains methods for performing collision queries.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Query\n*/ var Query = {};\n            module1.exports = Query;\n            var Vector = __nested_webpack_require_316500__(2);\n            var Collision = __nested_webpack_require_316500__(8);\n            var Bounds = __nested_webpack_require_316500__(1);\n            var Bodies = __nested_webpack_require_316500__(12);\n            var Vertices = __nested_webpack_require_316500__(3);\n            (function() {\n                /**\n     * Returns a list of collisions between `body` and `bodies`.\n     * @method collides\n     * @param {body} body\n     * @param {body[]} bodies\n     * @return {collision[]} Collisions\n     */ Query.collides = function(body, bodies) {\n                    var collisions = [], bodiesLength = bodies.length, bounds = body.bounds, collides = Collision.collides, overlaps = Bounds.overlaps;\n                    for(var i = 0; i < bodiesLength; i++){\n                        var bodyA = bodies[i], partsALength = bodyA.parts.length, partsAStart = partsALength === 1 ? 0 : 1;\n                        if (overlaps(bodyA.bounds, bounds)) {\n                            for(var j = partsAStart; j < partsALength; j++){\n                                var part = bodyA.parts[j];\n                                if (overlaps(part.bounds, bounds)) {\n                                    var collision = collides(part, body);\n                                    if (collision) {\n                                        collisions.push(collision);\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return collisions;\n                };\n                /**\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\n     * @method ray\n     * @param {body[]} bodies\n     * @param {vector} startPoint\n     * @param {vector} endPoint\n     * @param {number} [rayWidth]\n     * @return {collision[]} Collisions\n     */ Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\n                    rayWidth = rayWidth || 1e-100;\n                    var rayAngle = Vector.angle(startPoint, endPoint), rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {\n                        angle: rayAngle\n                    }), collisions = Query.collides(ray, bodies);\n                    for(var i = 0; i < collisions.length; i += 1){\n                        var collision = collisions[i];\n                        collision.body = collision.bodyB = collision.bodyA;\n                    }\n                    return collisions;\n                };\n                /**\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\n     * @method region\n     * @param {body[]} bodies\n     * @param {bounds} bounds\n     * @param {bool} [outside=false]\n     * @return {body[]} The bodies matching the query\n     */ Query.region = function(bodies, bounds, outside) {\n                    var result = [];\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i], overlaps = Bounds.overlaps(body.bounds, bounds);\n                        if (overlaps && !outside || !overlaps && outside) result.push(body);\n                    }\n                    return result;\n                };\n                /**\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\n     * @method point\n     * @param {body[]} bodies\n     * @param {vector} point\n     * @return {body[]} The bodies matching the query\n     */ Query.point = function(bodies, point) {\n                    var result = [];\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i];\n                        if (Bounds.contains(body.bounds, point)) {\n                            for(var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++){\n                                var part = body.parts[j];\n                                if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {\n                                    result.push(body);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    return result;\n                };\n            })();\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __nested_webpack_require_321378__) {\n            /**\n* The `Matter.Render` module is a simple canvas based renderer for visualising instances of `Matter.Engine`.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.\n*\n* @class Render\n*/ var Render = {};\n            module1.exports = Render;\n            var Body = __nested_webpack_require_321378__(4);\n            var Common = __nested_webpack_require_321378__(0);\n            var Composite = __nested_webpack_require_321378__(6);\n            var Bounds = __nested_webpack_require_321378__(1);\n            var Events = __nested_webpack_require_321378__(5);\n            var Vector = __nested_webpack_require_321378__(2);\n            var Mouse = __nested_webpack_require_321378__(14);\n            (function() {\n                var _requestAnimationFrame, _cancelAnimationFrame;\n                if (false) {}\n                Render._goodFps = 30;\n                Render._goodDelta = 1000 / 60;\n                /**\n     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {render} A new renderer\n     */ Render.create = function(options) {\n                    var defaults = {\n                        engine: null,\n                        element: null,\n                        canvas: null,\n                        mouse: null,\n                        frameRequestId: null,\n                        timing: {\n                            historySize: 60,\n                            delta: 0,\n                            deltaHistory: [],\n                            lastTime: 0,\n                            lastTimestamp: 0,\n                            lastElapsed: 0,\n                            timestampElapsed: 0,\n                            timestampElapsedHistory: [],\n                            engineDeltaHistory: [],\n                            engineElapsedHistory: [],\n                            elapsedHistory: []\n                        },\n                        options: {\n                            width: 800,\n                            height: 600,\n                            pixelRatio: 1,\n                            background: \"#14151f\",\n                            wireframeBackground: \"#14151f\",\n                            hasBounds: !!options.bounds,\n                            enabled: true,\n                            wireframes: true,\n                            showSleeping: true,\n                            showDebug: false,\n                            showStats: false,\n                            showPerformance: false,\n                            showBounds: false,\n                            showVelocity: false,\n                            showCollisions: false,\n                            showSeparations: false,\n                            showAxes: false,\n                            showPositions: false,\n                            showAngleIndicator: false,\n                            showIds: false,\n                            showVertexNumbers: false,\n                            showConvexHulls: false,\n                            showInternalEdges: false,\n                            showMousePosition: false\n                        }\n                    };\n                    var render = Common.extend(defaults, options);\n                    if (render.canvas) {\n                        render.canvas.width = render.options.width || render.canvas.width;\n                        render.canvas.height = render.options.height || render.canvas.height;\n                    }\n                    render.mouse = options.mouse;\n                    render.engine = options.engine;\n                    render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);\n                    render.context = render.canvas.getContext(\"2d\");\n                    render.textures = {};\n                    render.bounds = render.bounds || {\n                        min: {\n                            x: 0,\n                            y: 0\n                        },\n                        max: {\n                            x: render.canvas.width,\n                            y: render.canvas.height\n                        }\n                    };\n                    // for temporary back compatibility only\n                    render.controller = Render;\n                    render.options.showBroadphase = false;\n                    if (render.options.pixelRatio !== 1) {\n                        Render.setPixelRatio(render, render.options.pixelRatio);\n                    }\n                    if (Common.isElement(render.element)) {\n                        render.element.appendChild(render.canvas);\n                    }\n                    return render;\n                };\n                /**\n     * Continuously updates the render canvas on the `requestAnimationFrame` event.\n     * @method run\n     * @param {render} render\n     */ Render.run = function(render) {\n                    (function loop(time) {\n                        render.frameRequestId = _requestAnimationFrame(loop);\n                        _updateTiming(render, time);\n                        Render.world(render, time);\n                        if (render.options.showStats || render.options.showDebug) {\n                            Render.stats(render, render.context, time);\n                        }\n                        if (render.options.showPerformance || render.options.showDebug) {\n                            Render.performance(render, render.context, time);\n                        }\n                    })();\n                };\n                /**\n     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.\n     * @method stop\n     * @param {render} render\n     */ Render.stop = function(render) {\n                    _cancelAnimationFrame(render.frameRequestId);\n                };\n                /**\n     * Sets the pixel ratio of the renderer and updates the canvas.\n     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.\n     * @method setPixelRatio\n     * @param {render} render\n     * @param {number} pixelRatio\n     */ Render.setPixelRatio = function(render, pixelRatio) {\n                    var options = render.options, canvas = render.canvas;\n                    if (pixelRatio === \"auto\") {\n                        pixelRatio = _getPixelRatio(canvas);\n                    }\n                    options.pixelRatio = pixelRatio;\n                    canvas.setAttribute(\"data-pixel-ratio\", pixelRatio);\n                    canvas.width = options.width * pixelRatio;\n                    canvas.height = options.height * pixelRatio;\n                    canvas.style.width = options.width + \"px\";\n                    canvas.style.height = options.height + \"px\";\n                };\n                /**\n     * Positions and sizes the viewport around the given object bounds.\n     * Objects must have at least one of the following properties:\n     * - `object.bounds`\n     * - `object.position`\n     * - `object.min` and `object.max`\n     * - `object.x` and `object.y`\n     * @method lookAt\n     * @param {render} render\n     * @param {object[]} objects\n     * @param {vector} [padding]\n     * @param {bool} [center=true]\n     */ Render.lookAt = function(render, objects, padding, center) {\n                    center = typeof center !== \"undefined\" ? center : true;\n                    objects = Common.isArray(objects) ? objects : [\n                        objects\n                    ];\n                    padding = padding || {\n                        x: 0,\n                        y: 0\n                    };\n                    // find bounds of all objects\n                    var bounds = {\n                        min: {\n                            x: Infinity,\n                            y: Infinity\n                        },\n                        max: {\n                            x: -Infinity,\n                            y: -Infinity\n                        }\n                    };\n                    for(var i = 0; i < objects.length; i += 1){\n                        var object = objects[i], min = object.bounds ? object.bounds.min : object.min || object.position || object, max = object.bounds ? object.bounds.max : object.max || object.position || object;\n                        if (min && max) {\n                            if (min.x < bounds.min.x) bounds.min.x = min.x;\n                            if (max.x > bounds.max.x) bounds.max.x = max.x;\n                            if (min.y < bounds.min.y) bounds.min.y = min.y;\n                            if (max.y > bounds.max.y) bounds.max.y = max.y;\n                        }\n                    }\n                    // find ratios\n                    var width = bounds.max.x - bounds.min.x + 2 * padding.x, height = bounds.max.y - bounds.min.y + 2 * padding.y, viewHeight = render.canvas.height, viewWidth = render.canvas.width, outerRatio = viewWidth / viewHeight, innerRatio = width / height, scaleX = 1, scaleY = 1;\n                    // find scale factor\n                    if (innerRatio > outerRatio) {\n                        scaleY = innerRatio / outerRatio;\n                    } else {\n                        scaleX = outerRatio / innerRatio;\n                    }\n                    // enable bounds\n                    render.options.hasBounds = true;\n                    // position and size\n                    render.bounds.min.x = bounds.min.x;\n                    render.bounds.max.x = bounds.min.x + width * scaleX;\n                    render.bounds.min.y = bounds.min.y;\n                    render.bounds.max.y = bounds.min.y + height * scaleY;\n                    // center\n                    if (center) {\n                        render.bounds.min.x += width * 0.5 - width * scaleX * 0.5;\n                        render.bounds.max.x += width * 0.5 - width * scaleX * 0.5;\n                        render.bounds.min.y += height * 0.5 - height * scaleY * 0.5;\n                        render.bounds.max.y += height * 0.5 - height * scaleY * 0.5;\n                    }\n                    // padding\n                    render.bounds.min.x -= padding.x;\n                    render.bounds.max.x -= padding.x;\n                    render.bounds.min.y -= padding.y;\n                    render.bounds.max.y -= padding.y;\n                    // update mouse\n                    if (render.mouse) {\n                        Mouse.setScale(render.mouse, {\n                            x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,\n                            y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height\n                        });\n                        Mouse.setOffset(render.mouse, render.bounds.min);\n                    }\n                };\n                /**\n     * Applies viewport transforms based on `render.bounds` to a render context.\n     * @method startViewTransform\n     * @param {render} render\n     */ Render.startViewTransform = function(render) {\n                    var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;\n                    render.context.setTransform(render.options.pixelRatio / boundsScaleX, 0, 0, render.options.pixelRatio / boundsScaleY, 0, 0);\n                    render.context.translate(-render.bounds.min.x, -render.bounds.min.y);\n                };\n                /**\n     * Resets all transforms on the render context.\n     * @method endViewTransform\n     * @param {render} render\n     */ Render.endViewTransform = function(render) {\n                    render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n                };\n                /**\n     * Renders the given `engine`'s `Matter.World` object.\n     * This is the entry point for all rendering and should be called every time the scene changes.\n     * @method world\n     * @param {render} render\n     */ Render.world = function(render, time) {\n                    var startTime = Common.now(), engine = render.engine, world = engine.world, canvas = render.canvas, context = render.context, options = render.options, timing = render.timing;\n                    var allBodies = Composite.allBodies(world), allConstraints = Composite.allConstraints(world), background = options.wireframes ? options.wireframeBackground : options.background, bodies = [], constraints = [], i;\n                    var event = {\n                        timestamp: engine.timing.timestamp\n                    };\n                    Events.trigger(render, \"beforeRender\", event);\n                    // apply background if it has changed\n                    if (render.currentBackground !== background) _applyBackground(render, background);\n                    // clear the canvas with a transparent fill, to allow the canvas background to show\n                    context.globalCompositeOperation = \"source-in\";\n                    context.fillStyle = \"transparent\";\n                    context.fillRect(0, 0, canvas.width, canvas.height);\n                    context.globalCompositeOperation = \"source-over\";\n                    // handle bounds\n                    if (options.hasBounds) {\n                        // filter out bodies that are not in view\n                        for(i = 0; i < allBodies.length; i++){\n                            var body = allBodies[i];\n                            if (Bounds.overlaps(body.bounds, render.bounds)) bodies.push(body);\n                        }\n                        // filter out constraints that are not in view\n                        for(i = 0; i < allConstraints.length; i++){\n                            var constraint = allConstraints[i], bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointAWorld = constraint.pointA, pointBWorld = constraint.pointB;\n                            if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n                            if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n                            if (!pointAWorld || !pointBWorld) continue;\n                            if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld)) constraints.push(constraint);\n                        }\n                        // transform the view\n                        Render.startViewTransform(render);\n                        // update mouse\n                        if (render.mouse) {\n                            Mouse.setScale(render.mouse, {\n                                x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,\n                                y: (render.bounds.max.y - render.bounds.min.y) / render.options.height\n                            });\n                            Mouse.setOffset(render.mouse, render.bounds.min);\n                        }\n                    } else {\n                        constraints = allConstraints;\n                        bodies = allBodies;\n                        if (render.options.pixelRatio !== 1) {\n                            render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n                        }\n                    }\n                    if (!options.wireframes || engine.enableSleeping && options.showSleeping) {\n                        // fully featured rendering of bodies\n                        Render.bodies(render, bodies, context);\n                    } else {\n                        if (options.showConvexHulls) Render.bodyConvexHulls(render, bodies, context);\n                        // optimised method for wireframes only\n                        Render.bodyWireframes(render, bodies, context);\n                    }\n                    if (options.showBounds) Render.bodyBounds(render, bodies, context);\n                    if (options.showAxes || options.showAngleIndicator) Render.bodyAxes(render, bodies, context);\n                    if (options.showPositions) Render.bodyPositions(render, bodies, context);\n                    if (options.showVelocity) Render.bodyVelocity(render, bodies, context);\n                    if (options.showIds) Render.bodyIds(render, bodies, context);\n                    if (options.showSeparations) Render.separations(render, engine.pairs.list, context);\n                    if (options.showCollisions) Render.collisions(render, engine.pairs.list, context);\n                    if (options.showVertexNumbers) Render.vertexNumbers(render, bodies, context);\n                    if (options.showMousePosition) Render.mousePosition(render, render.mouse, context);\n                    Render.constraints(constraints, context);\n                    if (options.hasBounds) {\n                        // revert view transforms\n                        Render.endViewTransform(render);\n                    }\n                    Events.trigger(render, \"afterRender\", event);\n                    // log the time elapsed computing this update\n                    timing.lastElapsed = Common.now() - startTime;\n                };\n                /**\n     * Renders statistics about the engine and world useful for debugging.\n     * @private\n     * @method stats\n     * @param {render} render\n     * @param {RenderingContext} context\n     * @param {Number} time\n     */ Render.stats = function(render, context, time) {\n                    var engine = render.engine, world = engine.world, bodies = Composite.allBodies(world), parts = 0, width = 55, height = 44, x = 0, y = 0;\n                    // count parts\n                    for(var i = 0; i < bodies.length; i += 1){\n                        parts += bodies[i].parts.length;\n                    }\n                    // sections\n                    var sections = {\n                        \"Part\": parts,\n                        \"Body\": bodies.length,\n                        \"Cons\": Composite.allConstraints(world).length,\n                        \"Comp\": Composite.allComposites(world).length,\n                        \"Pair\": engine.pairs.list.length\n                    };\n                    // background\n                    context.fillStyle = \"#0e0f19\";\n                    context.fillRect(x, y, width * 5.5, height);\n                    context.font = \"12px Arial\";\n                    context.textBaseline = \"top\";\n                    context.textAlign = \"right\";\n                    // sections\n                    for(var key in sections){\n                        var section = sections[key];\n                        // label\n                        context.fillStyle = \"#aaa\";\n                        context.fillText(key, x + width, y + 8);\n                        // value\n                        context.fillStyle = \"#eee\";\n                        context.fillText(section, x + width, y + 26);\n                        x += width;\n                    }\n                };\n                /**\n     * Renders engine and render performance information.\n     * @private\n     * @method performance\n     * @param {render} render\n     * @param {RenderingContext} context\n     */ Render.performance = function(render, context) {\n                    var engine = render.engine, timing = render.timing, deltaHistory = timing.deltaHistory, elapsedHistory = timing.elapsedHistory, timestampElapsedHistory = timing.timestampElapsedHistory, engineDeltaHistory = timing.engineDeltaHistory, engineElapsedHistory = timing.engineElapsedHistory, lastEngineDelta = engine.timing.lastDelta;\n                    var deltaMean = _mean(deltaHistory), elapsedMean = _mean(elapsedHistory), engineDeltaMean = _mean(engineDeltaHistory), engineElapsedMean = _mean(engineElapsedHistory), timestampElapsedMean = _mean(timestampElapsedHistory), rateMean = timestampElapsedMean / deltaMean || 0, fps = 1000 / deltaMean || 0;\n                    var graphHeight = 4, gap = 12, width = 60, height = 34, x = 10, y = 69;\n                    // background\n                    context.fillStyle = \"#0e0f19\";\n                    context.fillRect(0, 50, gap * 4 + width * 5 + 22, height);\n                    // show FPS\n                    Render.status(context, x, y, width, graphHeight, deltaHistory.length, Math.round(fps) + \" fps\", fps / Render._goodFps, function(i) {\n                        return deltaHistory[i] / deltaMean - 1;\n                    });\n                    // show engine delta\n                    Render.status(context, x + gap + width, y, width, graphHeight, engineDeltaHistory.length, lastEngineDelta.toFixed(2) + \" dt\", Render._goodDelta / lastEngineDelta, function(i) {\n                        return engineDeltaHistory[i] / engineDeltaMean - 1;\n                    });\n                    // show engine update time\n                    Render.status(context, x + (gap + width) * 2, y, width, graphHeight, engineElapsedHistory.length, engineElapsedMean.toFixed(2) + \" ut\", 1 - engineElapsedMean / Render._goodFps, function(i) {\n                        return engineElapsedHistory[i] / engineElapsedMean - 1;\n                    });\n                    // show render time\n                    Render.status(context, x + (gap + width) * 3, y, width, graphHeight, elapsedHistory.length, elapsedMean.toFixed(2) + \" rt\", 1 - elapsedMean / Render._goodFps, function(i) {\n                        return elapsedHistory[i] / elapsedMean - 1;\n                    });\n                    // show effective speed\n                    Render.status(context, x + (gap + width) * 4, y, width, graphHeight, timestampElapsedHistory.length, rateMean.toFixed(2) + \" x\", rateMean * rateMean * rateMean, function(i) {\n                        return (timestampElapsedHistory[i] / deltaHistory[i] / rateMean || 0) - 1;\n                    });\n                };\n                /**\n     * Renders a label, indicator and a chart.\n     * @private\n     * @method status\n     * @param {RenderingContext} context\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} count\n     * @param {string} label\n     * @param {string} indicator\n     * @param {function} plotY\n     */ Render.status = function(context, x, y, width, height, count, label, indicator, plotY) {\n                    // background\n                    context.strokeStyle = \"#888\";\n                    context.fillStyle = \"#444\";\n                    context.lineWidth = 1;\n                    context.fillRect(x, y + 7, width, 1);\n                    // chart\n                    context.beginPath();\n                    context.moveTo(x, y + 7 - height * Common.clamp(0.4 * plotY(0), -2, 2));\n                    for(var i = 0; i < width; i += 1){\n                        context.lineTo(x + i, y + 7 - (i < count ? height * Common.clamp(0.4 * plotY(i), -2, 2) : 0));\n                    }\n                    context.stroke();\n                    // indicator\n                    context.fillStyle = \"hsl(\" + Common.clamp(25 + 95 * indicator, 0, 120) + \",100%,60%)\";\n                    context.fillRect(x, y - 7, 4, 4);\n                    // label\n                    context.font = \"12px Arial\";\n                    context.textBaseline = \"middle\";\n                    context.textAlign = \"right\";\n                    context.fillStyle = \"#eee\";\n                    context.fillText(label, x + width, y - 5);\n                };\n                /**\n     * Description\n     * @private\n     * @method constraints\n     * @param {constraint[]} constraints\n     * @param {RenderingContext} context\n     */ Render.constraints = function(constraints, context) {\n                    var c = context;\n                    for(var i = 0; i < constraints.length; i++){\n                        var constraint = constraints[i];\n                        if (!constraint.render.visible || !constraint.pointA || !constraint.pointB) continue;\n                        var bodyA = constraint.bodyA, bodyB = constraint.bodyB, start, end;\n                        if (bodyA) {\n                            start = Vector.add(bodyA.position, constraint.pointA);\n                        } else {\n                            start = constraint.pointA;\n                        }\n                        if (constraint.render.type === \"pin\") {\n                            c.beginPath();\n                            c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                            c.closePath();\n                        } else {\n                            if (bodyB) {\n                                end = Vector.add(bodyB.position, constraint.pointB);\n                            } else {\n                                end = constraint.pointB;\n                            }\n                            c.beginPath();\n                            c.moveTo(start.x, start.y);\n                            if (constraint.render.type === \"spring\") {\n                                var delta = Vector.sub(end, start), normal = Vector.perp(Vector.normalise(delta)), coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)), offset;\n                                for(var j = 1; j < coils; j += 1){\n                                    offset = j % 2 === 0 ? 1 : -1;\n                                    c.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);\n                                }\n                            }\n                            c.lineTo(end.x, end.y);\n                        }\n                        if (constraint.render.lineWidth) {\n                            c.lineWidth = constraint.render.lineWidth;\n                            c.strokeStyle = constraint.render.strokeStyle;\n                            c.stroke();\n                        }\n                        if (constraint.render.anchors) {\n                            c.fillStyle = constraint.render.strokeStyle;\n                            c.beginPath();\n                            c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                            c.arc(end.x, end.y, 3, 0, 2 * Math.PI);\n                            c.closePath();\n                            c.fill();\n                        }\n                    }\n                };\n                /**\n     * Description\n     * @private\n     * @method bodies\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodies = function(render, bodies, context) {\n                    var c = context, engine = render.engine, options = render.options, showInternalEdges = options.showInternalEdges || !options.wireframes, body, part, i, k;\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (!body.render.visible) continue;\n                        // handle compound parts\n                        for(k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++){\n                            part = body.parts[k];\n                            if (!part.render.visible) continue;\n                            if (options.showSleeping && body.isSleeping) {\n                                c.globalAlpha = 0.5 * part.render.opacity;\n                            } else if (part.render.opacity !== 1) {\n                                c.globalAlpha = part.render.opacity;\n                            }\n                            if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {\n                                // part sprite\n                                var sprite = part.render.sprite, texture = _getTexture(render, sprite.texture);\n                                c.translate(part.position.x, part.position.y);\n                                c.rotate(part.angle);\n                                c.drawImage(texture, texture.width * -sprite.xOffset * sprite.xScale, texture.height * -sprite.yOffset * sprite.yScale, texture.width * sprite.xScale, texture.height * sprite.yScale);\n                                // revert translation, hopefully faster than save / restore\n                                c.rotate(-part.angle);\n                                c.translate(-part.position.x, -part.position.y);\n                            } else {\n                                // part polygon\n                                if (part.circleRadius) {\n                                    c.beginPath();\n                                    c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\n                                } else {\n                                    c.beginPath();\n                                    c.moveTo(part.vertices[0].x, part.vertices[0].y);\n                                    for(var j = 1; j < part.vertices.length; j++){\n                                        if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                                            c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                                        } else {\n                                            c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                                        }\n                                        if (part.vertices[j].isInternal && !showInternalEdges) {\n                                            c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                                        }\n                                    }\n                                    c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                                    c.closePath();\n                                }\n                                if (!options.wireframes) {\n                                    c.fillStyle = part.render.fillStyle;\n                                    if (part.render.lineWidth) {\n                                        c.lineWidth = part.render.lineWidth;\n                                        c.strokeStyle = part.render.strokeStyle;\n                                        c.stroke();\n                                    }\n                                    c.fill();\n                                } else {\n                                    c.lineWidth = 1;\n                                    c.strokeStyle = \"#bbb\";\n                                    c.stroke();\n                                }\n                            }\n                            c.globalAlpha = 1;\n                        }\n                    }\n                };\n                /**\n     * Optimised method for drawing body wireframes in one pass\n     * @private\n     * @method bodyWireframes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyWireframes = function(render, bodies, context) {\n                    var c = context, showInternalEdges = render.options.showInternalEdges, body, part, i, j, k;\n                    c.beginPath();\n                    // render all bodies\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (!body.render.visible) continue;\n                        // handle compound parts\n                        for(k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++){\n                            part = body.parts[k];\n                            c.moveTo(part.vertices[0].x, part.vertices[0].y);\n                            for(j = 1; j < part.vertices.length; j++){\n                                if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                                    c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                                } else {\n                                    c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                                }\n                                if (part.vertices[j].isInternal && !showInternalEdges) {\n                                    c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                                }\n                            }\n                            c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                        }\n                    }\n                    c.lineWidth = 1;\n                    c.strokeStyle = \"#bbb\";\n                    c.stroke();\n                };\n                /**\n     * Optimised method for drawing body convex hull wireframes in one pass\n     * @private\n     * @method bodyConvexHulls\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyConvexHulls = function(render, bodies, context) {\n                    var c = context, body, part, i, j, k;\n                    c.beginPath();\n                    // render convex hulls\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (!body.render.visible || body.parts.length === 1) continue;\n                        c.moveTo(body.vertices[0].x, body.vertices[0].y);\n                        for(j = 1; j < body.vertices.length; j++){\n                            c.lineTo(body.vertices[j].x, body.vertices[j].y);\n                        }\n                        c.lineTo(body.vertices[0].x, body.vertices[0].y);\n                    }\n                    c.lineWidth = 1;\n                    c.strokeStyle = \"rgba(255,255,255,0.2)\";\n                    c.stroke();\n                };\n                /**\n     * Renders body vertex numbers.\n     * @private\n     * @method vertexNumbers\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.vertexNumbers = function(render, bodies, context) {\n                    var c = context, i, j, k;\n                    for(i = 0; i < bodies.length; i++){\n                        var parts = bodies[i].parts;\n                        for(k = parts.length > 1 ? 1 : 0; k < parts.length; k++){\n                            var part = parts[k];\n                            for(j = 0; j < part.vertices.length; j++){\n                                c.fillStyle = \"rgba(255,255,255,0.2)\";\n                                c.fillText(i + \"_\" + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);\n                            }\n                        }\n                    }\n                };\n                /**\n     * Renders mouse position.\n     * @private\n     * @method mousePosition\n     * @param {render} render\n     * @param {mouse} mouse\n     * @param {RenderingContext} context\n     */ Render.mousePosition = function(render, mouse, context) {\n                    var c = context;\n                    c.fillStyle = \"rgba(255,255,255,0.8)\";\n                    c.fillText(mouse.position.x + \"  \" + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);\n                };\n                /**\n     * Draws body bounds\n     * @private\n     * @method bodyBounds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyBounds = function(render, bodies, context) {\n                    var c = context, engine = render.engine, options = render.options;\n                    c.beginPath();\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i];\n                        if (body.render.visible) {\n                            var parts = bodies[i].parts;\n                            for(var j = parts.length > 1 ? 1 : 0; j < parts.length; j++){\n                                var part = parts[j];\n                                c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);\n                            }\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.strokeStyle = \"rgba(255,255,255,0.08)\";\n                    } else {\n                        c.strokeStyle = \"rgba(0,0,0,0.1)\";\n                    }\n                    c.lineWidth = 1;\n                    c.stroke();\n                };\n                /**\n     * Draws body angle indicators and axes\n     * @private\n     * @method bodyAxes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyAxes = function(render, bodies, context) {\n                    var c = context, engine = render.engine, options = render.options, part, i, j, k;\n                    c.beginPath();\n                    for(i = 0; i < bodies.length; i++){\n                        var body = bodies[i], parts = body.parts;\n                        if (!body.render.visible) continue;\n                        if (options.showAxes) {\n                            // render all axes\n                            for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){\n                                part = parts[j];\n                                for(k = 0; k < part.axes.length; k++){\n                                    var axis = part.axes[k];\n                                    c.moveTo(part.position.x, part.position.y);\n                                    c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);\n                                }\n                            }\n                        } else {\n                            for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){\n                                part = parts[j];\n                                for(k = 0; k < part.axes.length; k++){\n                                    // render a single axis indicator\n                                    c.moveTo(part.position.x, part.position.y);\n                                    c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);\n                                }\n                            }\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.strokeStyle = \"indianred\";\n                        c.lineWidth = 1;\n                    } else {\n                        c.strokeStyle = \"rgba(255, 255, 255, 0.4)\";\n                        c.globalCompositeOperation = \"overlay\";\n                        c.lineWidth = 2;\n                    }\n                    c.stroke();\n                    c.globalCompositeOperation = \"source-over\";\n                };\n                /**\n     * Draws body positions\n     * @private\n     * @method bodyPositions\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyPositions = function(render, bodies, context) {\n                    var c = context, engine = render.engine, options = render.options, body, part, i, k;\n                    c.beginPath();\n                    // render current positions\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (!body.render.visible) continue;\n                        // handle compound parts\n                        for(k = 0; k < body.parts.length; k++){\n                            part = body.parts[k];\n                            c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);\n                            c.closePath();\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.fillStyle = \"indianred\";\n                    } else {\n                        c.fillStyle = \"rgba(0,0,0,0.5)\";\n                    }\n                    c.fill();\n                    c.beginPath();\n                    // render previous positions\n                    for(i = 0; i < bodies.length; i++){\n                        body = bodies[i];\n                        if (body.render.visible) {\n                            c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\n                            c.closePath();\n                        }\n                    }\n                    c.fillStyle = \"rgba(255,165,0,0.8)\";\n                    c.fill();\n                };\n                /**\n     * Draws body velocity\n     * @private\n     * @method bodyVelocity\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyVelocity = function(render, bodies, context) {\n                    var c = context;\n                    c.beginPath();\n                    for(var i = 0; i < bodies.length; i++){\n                        var body = bodies[i];\n                        if (!body.render.visible) continue;\n                        var velocity = Body.getVelocity(body);\n                        c.moveTo(body.position.x, body.position.y);\n                        c.lineTo(body.position.x + velocity.x, body.position.y + velocity.y);\n                    }\n                    c.lineWidth = 3;\n                    c.strokeStyle = \"cornflowerblue\";\n                    c.stroke();\n                };\n                /**\n     * Draws body ids\n     * @private\n     * @method bodyIds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */ Render.bodyIds = function(render, bodies, context) {\n                    var c = context, i, j;\n                    for(i = 0; i < bodies.length; i++){\n                        if (!bodies[i].render.visible) continue;\n                        var parts = bodies[i].parts;\n                        for(j = parts.length > 1 ? 1 : 0; j < parts.length; j++){\n                            var part = parts[j];\n                            c.font = \"12px Arial\";\n                            c.fillStyle = \"rgba(255,255,255,0.5)\";\n                            c.fillText(part.id, part.position.x + 10, part.position.y - 10);\n                        }\n                    }\n                };\n                /**\n     * Description\n     * @private\n     * @method collisions\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */ Render.collisions = function(render, pairs, context) {\n                    var c = context, options = render.options, pair, collision, corrected, bodyA, bodyB, i, j;\n                    c.beginPath();\n                    // render collision positions\n                    for(i = 0; i < pairs.length; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive) continue;\n                        collision = pair.collision;\n                        for(j = 0; j < pair.activeContacts.length; j++){\n                            var contact = pair.activeContacts[j], vertex = contact.vertex;\n                            c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.fillStyle = \"rgba(255,255,255,0.7)\";\n                    } else {\n                        c.fillStyle = \"orange\";\n                    }\n                    c.fill();\n                    c.beginPath();\n                    // render collision normals\n                    for(i = 0; i < pairs.length; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive) continue;\n                        collision = pair.collision;\n                        if (pair.activeContacts.length > 0) {\n                            var normalPosX = pair.activeContacts[0].vertex.x, normalPosY = pair.activeContacts[0].vertex.y;\n                            if (pair.activeContacts.length === 2) {\n                                normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;\n                                normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;\n                            }\n                            if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {\n                                c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\n                            } else {\n                                c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);\n                            }\n                            c.lineTo(normalPosX, normalPosY);\n                        }\n                    }\n                    if (options.wireframes) {\n                        c.strokeStyle = \"rgba(255,165,0,0.7)\";\n                    } else {\n                        c.strokeStyle = \"orange\";\n                    }\n                    c.lineWidth = 1;\n                    c.stroke();\n                };\n                /**\n     * Description\n     * @private\n     * @method separations\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */ Render.separations = function(render, pairs, context) {\n                    var c = context, options = render.options, pair, collision, corrected, bodyA, bodyB, i, j;\n                    c.beginPath();\n                    // render separations\n                    for(i = 0; i < pairs.length; i++){\n                        pair = pairs[i];\n                        if (!pair.isActive) continue;\n                        collision = pair.collision;\n                        bodyA = collision.bodyA;\n                        bodyB = collision.bodyB;\n                        var k = 1;\n                        if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n                        if (bodyB.isStatic) k = 0;\n                        c.moveTo(bodyB.position.x, bodyB.position.y);\n                        c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);\n                        k = 1;\n                        if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n                        if (bodyA.isStatic) k = 0;\n                        c.moveTo(bodyA.position.x, bodyA.position.y);\n                        c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);\n                    }\n                    if (options.wireframes) {\n                        c.strokeStyle = \"rgba(255,165,0,0.5)\";\n                    } else {\n                        c.strokeStyle = \"orange\";\n                    }\n                    c.stroke();\n                };\n                /**\n     * Description\n     * @private\n     * @method inspector\n     * @param {inspector} inspector\n     * @param {RenderingContext} context\n     */ Render.inspector = function(inspector, context) {\n                    var engine = inspector.engine, selected = inspector.selected, render = inspector.render, options = render.options, bounds;\n                    if (options.hasBounds) {\n                        var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;\n                        context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n                        context.translate(-render.bounds.min.x, -render.bounds.min.y);\n                    }\n                    for(var i = 0; i < selected.length; i++){\n                        var item = selected[i].data;\n                        context.translate(0.5, 0.5);\n                        context.lineWidth = 1;\n                        context.strokeStyle = \"rgba(255,165,0,0.9)\";\n                        context.setLineDash([\n                            1,\n                            2\n                        ]);\n                        switch(item.type){\n                            case \"body\":\n                                // render body selections\n                                bounds = item.bounds;\n                                context.beginPath();\n                                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));\n                                context.closePath();\n                                context.stroke();\n                                break;\n                            case \"constraint\":\n                                // render constraint selections\n                                var point = item.pointA;\n                                if (item.bodyA) point = item.pointB;\n                                context.beginPath();\n                                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);\n                                context.closePath();\n                                context.stroke();\n                                break;\n                        }\n                        context.setLineDash([]);\n                        context.translate(-0.5, -0.5);\n                    }\n                    // render selection region\n                    if (inspector.selectStart !== null) {\n                        context.translate(0.5, 0.5);\n                        context.lineWidth = 1;\n                        context.strokeStyle = \"rgba(255,165,0,0.6)\";\n                        context.fillStyle = \"rgba(255,165,0,0.1)\";\n                        bounds = inspector.selectBounds;\n                        context.beginPath();\n                        context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));\n                        context.closePath();\n                        context.stroke();\n                        context.fill();\n                        context.translate(-0.5, -0.5);\n                    }\n                    if (options.hasBounds) context.setTransform(1, 0, 0, 1, 0, 0);\n                };\n                /**\n     * Updates render timing.\n     * @method _updateTiming\n     * @private\n     * @param {render} render\n     * @param {number} time\n     */ var _updateTiming = function(render, time) {\n                    var engine = render.engine, timing = render.timing, historySize = timing.historySize, timestamp = engine.timing.timestamp;\n                    timing.delta = time - timing.lastTime || Render._goodDelta;\n                    timing.lastTime = time;\n                    timing.timestampElapsed = timestamp - timing.lastTimestamp || 0;\n                    timing.lastTimestamp = timestamp;\n                    timing.deltaHistory.unshift(timing.delta);\n                    timing.deltaHistory.length = Math.min(timing.deltaHistory.length, historySize);\n                    timing.engineDeltaHistory.unshift(engine.timing.lastDelta);\n                    timing.engineDeltaHistory.length = Math.min(timing.engineDeltaHistory.length, historySize);\n                    timing.timestampElapsedHistory.unshift(timing.timestampElapsed);\n                    timing.timestampElapsedHistory.length = Math.min(timing.timestampElapsedHistory.length, historySize);\n                    timing.engineElapsedHistory.unshift(engine.timing.lastElapsed);\n                    timing.engineElapsedHistory.length = Math.min(timing.engineElapsedHistory.length, historySize);\n                    timing.elapsedHistory.unshift(timing.lastElapsed);\n                    timing.elapsedHistory.length = Math.min(timing.elapsedHistory.length, historySize);\n                };\n                /**\n     * Returns the mean value of the given numbers.\n     * @method _mean\n     * @private\n     * @param {Number[]} values\n     * @return {Number} the mean of given values\n     */ var _mean = function(values) {\n                    var result = 0;\n                    for(var i = 0; i < values.length; i += 1){\n                        result += values[i];\n                    }\n                    return result / values.length || 0;\n                };\n                /**\n     * @method _createCanvas\n     * @private\n     * @param {} width\n     * @param {} height\n     * @return canvas\n     */ var _createCanvas = function(width, height) {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.width = width;\n                    canvas.height = height;\n                    canvas.oncontextmenu = function() {\n                        return false;\n                    };\n                    canvas.onselectstart = function() {\n                        return false;\n                    };\n                    return canvas;\n                };\n                /**\n     * Gets the pixel ratio of the canvas.\n     * @method _getPixelRatio\n     * @private\n     * @param {HTMLElement} canvas\n     * @return {Number} pixel ratio\n     */ var _getPixelRatio = function(canvas) {\n                    var context = canvas.getContext(\"2d\"), devicePixelRatio = window.devicePixelRatio || 1, backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n                    return devicePixelRatio / backingStorePixelRatio;\n                };\n                /**\n     * Gets the requested texture (an Image) via its path\n     * @method _getTexture\n     * @private\n     * @param {render} render\n     * @param {string} imagePath\n     * @return {Image} texture\n     */ var _getTexture = function(render, imagePath) {\n                    var image = render.textures[imagePath];\n                    if (image) return image;\n                    image = render.textures[imagePath] = new Image();\n                    image.src = imagePath;\n                    return image;\n                };\n                /**\n     * Applies the background to the canvas using CSS.\n     * @method applyBackground\n     * @private\n     * @param {render} render\n     * @param {string} background\n     */ var _applyBackground = function(render, background) {\n                    var cssBackground = background;\n                    if (/(jpg|gif|png)$/.test(background)) cssBackground = \"url(\" + background + \")\";\n                    render.canvas.style.background = cssBackground;\n                    render.canvas.style.backgroundSize = \"contain\";\n                    render.currentBackground = background;\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired before rendering\n    *\n    * @event beforeRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired after rendering\n    *\n    * @event afterRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * A back-reference to the `Matter.Render` module.\n     *\n     * @deprecated\n     * @property controller\n     * @type render\n     */ /**\n     * A reference to the `Matter.Engine` instance to be used.\n     *\n     * @property engine\n     * @type engine\n     */ /**\n     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)\n     *\n     * @property element\n     * @type HTMLElement\n     * @default null\n     */ /**\n     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     * @default null\n     */ /**\n     * A `Bounds` object that specifies the drawing view region.\n     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).\n     * This allows for creating views that can pan or zoom around the scene.\n     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.\n     *\n     * @property bounds\n     * @type bounds\n     */ /**\n     * The 2d rendering context from the `render.canvas` element.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */ /**\n     * The sprite texture cache.\n     *\n     * @property textures\n     * @type {}\n     */ /**\n     * The mouse to render if `render.options.showMousePosition` is enabled.\n     *\n     * @property mouse\n     * @type mouse\n     * @default null\n     */ /**\n     * The configuration options of the renderer.\n     *\n     * @property options\n     * @type {}\n     */ /**\n     * The target width in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.width\n     * @type number\n     * @default 800\n     */ /**\n     * The target height in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.height\n     * @type number\n     * @default 600\n     */ /**\n     * The [pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio) to use when rendering.\n     *\n     * @property options.pixelRatio\n     * @type number\n     * @default 1\n     */ /**\n     * A CSS background color string to use when `render.options.wireframes` is disabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.background\n     * @type string\n     * @default '#14151f'\n     */ /**\n     * A CSS background color string to use when `render.options.wireframes` is enabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.wireframeBackground\n     * @type string\n     * @default '#14151f'\n     */ /**\n     * A flag that specifies if `render.bounds` should be used when rendering.\n     *\n     * @property options.hasBounds\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable all debug information overlays together.  \n     * This includes and has priority over the values of:\n     *\n     * - `render.options.showStats`\n     * - `render.options.showPerformance`\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the engine stats info overlay.  \n     * From left to right, the values shown are:\n     *\n     * - body parts total\n     * - body total\n     * - constraints total\n     * - composites total\n     * - collision pairs total\n     *\n     * @property options.showStats\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable performance charts.  \n     * From left to right, the values shown are:\n     *\n     * - average render frequency (e.g. 60 fps)\n     * - exact engine delta time used for last update (e.g. 16.66ms)\n     * - average engine execution duration (e.g. 5.00ms)\n     * - average render execution duration (e.g. 0.40ms)\n     * - average effective play speed (e.g. '1.00x' is 'real-time')\n     *\n     * Each value is recorded over a fixed sample of past frames (60 frames).\n     *\n     * A chart shown below each value indicates the variance from the average over the sample.\n     * The more stable or fixed the value is the flatter the chart will appear.\n     *\n     * @property options.showPerformance\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable rendering entirely.\n     *\n     * @property options.enabled\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to toggle wireframe rendering otherwise solid fill rendering is used.\n     *\n     * @property options.wireframes\n     * @type boolean\n     * @default true\n     */ /**\n     * A flag to enable or disable sleeping bodies indicators.\n     *\n     * @property options.showSleeping\n     * @type boolean\n     * @default true\n     */ /**\n     * A flag to enable or disable the debug information overlay.\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the collision broadphase debug overlay.\n     *\n     * @deprecated no longer implemented\n     * @property options.showBroadphase\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body bounds debug overlay.\n     *\n     * @property options.showBounds\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body velocity debug overlay.\n     *\n     * @property options.showVelocity\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body collisions debug overlay.\n     *\n     * @property options.showCollisions\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the collision resolver separations debug overlay.\n     *\n     * @property options.showSeparations\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body axes debug overlay.\n     *\n     * @property options.showAxes\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body positions debug overlay.\n     *\n     * @property options.showPositions\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body angle debug overlay.\n     *\n     * @property options.showAngleIndicator\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body and part ids debug overlay.\n     *\n     * @property options.showIds\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body vertex numbers debug overlay.\n     *\n     * @property options.showVertexNumbers\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body convex hulls debug overlay.\n     *\n     * @property options.showConvexHulls\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the body internal edges debug overlay.\n     *\n     * @property options.showInternalEdges\n     * @type boolean\n     * @default false\n     */ /**\n     * A flag to enable or disable the mouse position debug overlay.\n     *\n     * @property options.showMousePosition\n     * @type boolean\n     * @default false\n     */ })();\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __nested_webpack_require_385233__) {\n            /**\n* The `Matter.Runner` module is an optional utility which provides a game loop, \n* that handles continuously updating a `Matter.Engine` for you within a browser.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.\n* Instead just call `Engine.update(engine, delta)` in your own loop.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Runner\n*/ var Runner = {};\n            module1.exports = Runner;\n            var Events = __nested_webpack_require_385233__(5);\n            var Engine = __nested_webpack_require_385233__(17);\n            var Common = __nested_webpack_require_385233__(0);\n            (function() {\n                var _requestAnimationFrame, _cancelAnimationFrame;\n                if (false) {}\n                if (!_requestAnimationFrame) {\n                    var _frameTimeout;\n                    _requestAnimationFrame = function(callback) {\n                        _frameTimeout = setTimeout(function() {\n                            callback(Common.now());\n                        }, 1000 / 60);\n                    };\n                    _cancelAnimationFrame = function() {\n                        clearTimeout(_frameTimeout);\n                    };\n                }\n                /**\n     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * @method create\n     * @param {} options\n     */ Runner.create = function(options) {\n                    var defaults = {\n                        fps: 60,\n                        deltaSampleSize: 60,\n                        counterTimestamp: 0,\n                        frameCounter: 0,\n                        deltaHistory: [],\n                        timePrev: null,\n                        frameRequestId: null,\n                        isFixed: false,\n                        enabled: true\n                    };\n                    var runner = Common.extend(defaults, options);\n                    runner.delta = runner.delta || 1000 / runner.fps;\n                    runner.deltaMin = runner.deltaMin || 1000 / runner.fps;\n                    runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);\n                    runner.fps = 1000 / runner.delta;\n                    return runner;\n                };\n                /**\n     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.\n     * @method run\n     * @param {engine} engine\n     */ Runner.run = function(runner, engine) {\n                    // create runner if engine is first argument\n                    if (typeof runner.positionIterations !== \"undefined\") {\n                        engine = runner;\n                        runner = Runner.create();\n                    }\n                    (function run(time) {\n                        runner.frameRequestId = _requestAnimationFrame(run);\n                        if (time && runner.enabled) {\n                            Runner.tick(runner, engine, time);\n                        }\n                    })();\n                    return runner;\n                };\n                /**\n     * A game loop utility that updates the engine and renderer by one step (a 'tick').\n     * Features delta smoothing, time correction and fixed or dynamic timing.\n     * Consider just `Engine.update(engine, delta)` if you're using your own loop.\n     * @method tick\n     * @param {runner} runner\n     * @param {engine} engine\n     * @param {number} time\n     */ Runner.tick = function(runner, engine, time) {\n                    var timing = engine.timing, delta;\n                    if (runner.isFixed) {\n                        // fixed timestep\n                        delta = runner.delta;\n                    } else {\n                        // dynamic timestep based on wall clock between calls\n                        delta = time - runner.timePrev || runner.delta;\n                        runner.timePrev = time;\n                        // optimistically filter delta over a few frames, to improve stability\n                        runner.deltaHistory.push(delta);\n                        runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);\n                        delta = Math.min.apply(null, runner.deltaHistory);\n                        // limit delta\n                        delta = delta < runner.deltaMin ? runner.deltaMin : delta;\n                        delta = delta > runner.deltaMax ? runner.deltaMax : delta;\n                        // update engine timing object\n                        runner.delta = delta;\n                    }\n                    // create an event object\n                    var event = {\n                        timestamp: timing.timestamp\n                    };\n                    Events.trigger(runner, \"beforeTick\", event);\n                    // fps counter\n                    runner.frameCounter += 1;\n                    if (time - runner.counterTimestamp >= 1000) {\n                        runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);\n                        runner.counterTimestamp = time;\n                        runner.frameCounter = 0;\n                    }\n                    Events.trigger(runner, \"tick\", event);\n                    // update\n                    Events.trigger(runner, \"beforeUpdate\", event);\n                    Engine.update(engine, delta);\n                    Events.trigger(runner, \"afterUpdate\", event);\n                    Events.trigger(runner, \"afterTick\", event);\n                };\n                /**\n     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.\n     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.\n     * @method stop\n     * @param {runner} runner\n     */ Runner.stop = function(runner) {\n                    _cancelAnimationFrame(runner.frameRequestId);\n                };\n                /**\n     * Alias for `Runner.run`.\n     * @method start\n     * @param {runner} runner\n     * @param {engine} engine\n     */ Runner.start = function(runner, engine) {\n                    Runner.run(runner, engine);\n                };\n            /*\n    *\n    *  Events Documentation\n    *\n    */ /**\n    * Fired at the start of a tick, before any updates to the engine or timing\n    *\n    * @event beforeTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired after engine timing updated, but just before update\n    *\n    * @event tick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired at the end of a tick, after engine update and after rendering\n    *\n    * @event afterTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired before update\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /**\n    * Fired after update\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */ /*\n    *\n    *  Properties Documentation\n    *\n    */ /**\n     * A flag that specifies whether the runner is running or not.\n     *\n     * @property enabled\n     * @type boolean\n     * @default true\n     */ /**\n     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).\n     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).\n     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).\n     *\n     * @property isFixed\n     * @type boolean\n     * @default false\n     */ /**\n     * A `Number` that specifies the time step between updates in milliseconds.\n     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.\n     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.\n     *\n     * @property delta\n     * @type number\n     * @default 1000 / 60\n     */ })();\n        /***/ },\n        /* 28 */ /***/ function(module1, exports1, __nested_webpack_require_394777__) {\n            /**\n* This module has now been replaced by `Matter.Collision`.\n*\n* All usage should be migrated to `Matter.Collision`.\n* For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n*\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\n*\n* @class SAT\n* @deprecated\n*/ var SAT = {};\n            module1.exports = SAT;\n            var Collision = __nested_webpack_require_394777__(8);\n            var Common = __nested_webpack_require_394777__(0);\n            var deprecated = Common.deprecated;\n            (function() {\n                /**\n     * Detect collision between two bodies using the Separating Axis Theorem.\n     * @deprecated replaced by Collision.collides\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {collision} collision\n     */ SAT.collides = function(bodyA, bodyB) {\n                    return Collision.collides(bodyA, bodyB);\n                };\n                deprecated(SAT, \"collides\", \"SAT.collides ➤ replaced by Collision.collides\");\n            })();\n        /***/ },\n        /* 29 */ /***/ function(module1, exports1, __nested_webpack_require_395982__) {\n            /**\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\n*\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Svg\n*/ var Svg = {};\n            module1.exports = Svg;\n            var Bounds = __nested_webpack_require_395982__(1);\n            var Common = __nested_webpack_require_395982__(0);\n            (function() {\n                /**\n     * Converts an SVG path into an array of vector points.\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\n     * See `Bodies.fromVertices` which provides support for this.\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\n     * You must load the `pathseg.js` polyfill on newer browsers.\n     * @method pathToVertices\n     * @param {SVGPathElement} path\n     * @param {Number} [sampleLength=15]\n     * @return {Vector[]} points\n     */ Svg.pathToVertices = function(path, sampleLength) {\n                    if (false) {}\n                    // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n                    var i, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x = 0, y = 0;\n                    sampleLength = sampleLength || 15;\n                    var addPoint = function(px, py, pathSegType) {\n                        // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n                        var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\n                        // when the last point doesn't equal the current point add the current point\n                        if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n                            if (lastPoint && isRelative) {\n                                lx = lastPoint.x;\n                                ly = lastPoint.y;\n                            } else {\n                                lx = 0;\n                                ly = 0;\n                            }\n                            var point = {\n                                x: lx + px,\n                                y: ly + py\n                            };\n                            // set last point\n                            if (isRelative || !lastPoint) {\n                                lastPoint = point;\n                            }\n                            points.push(point);\n                            x = lx + px;\n                            y = ly + py;\n                        }\n                    };\n                    var addSegmentPoint = function(segment) {\n                        var segType = segment.pathSegTypeAsLetter.toUpperCase();\n                        // skip path ends\n                        if (segType === \"Z\") return;\n                        // map segment to x and y\n                        switch(segType){\n                            case \"M\":\n                            case \"L\":\n                            case \"T\":\n                            case \"C\":\n                            case \"S\":\n                            case \"Q\":\n                                x = segment.x;\n                                y = segment.y;\n                                break;\n                            case \"H\":\n                                x = segment.x;\n                                break;\n                            case \"V\":\n                                y = segment.y;\n                                break;\n                        }\n                        addPoint(x, y, segment.pathSegType);\n                    };\n                    // ensure path is absolute\n                    Svg._svgPathToAbsolute(path);\n                    // get total length\n                    total = path.getTotalLength();\n                    // queue segments\n                    segments = [];\n                    for(i = 0; i < path.pathSegList.numberOfItems; i += 1)segments.push(path.pathSegList.getItem(i));\n                    segmentsQueue = segments.concat();\n                    // sample through path\n                    while(length < total){\n                        // get segment at position\n                        segmentIndex = path.getPathSegAtLength(length);\n                        segment = segments[segmentIndex];\n                        // new segment\n                        if (segment != lastSegment) {\n                            while(segmentsQueue.length && segmentsQueue[0] != segment)addSegmentPoint(segmentsQueue.shift());\n                            lastSegment = segment;\n                        }\n                        // add points in between when curving\n                        // TODO: adaptive sampling\n                        switch(segment.pathSegTypeAsLetter.toUpperCase()){\n                            case \"C\":\n                            case \"T\":\n                            case \"S\":\n                            case \"Q\":\n                            case \"A\":\n                                point = path.getPointAtLength(length);\n                                addPoint(point.x, point.y, 0);\n                                break;\n                        }\n                        // increment by sample value\n                        length += sampleLength;\n                    }\n                    // add remaining segments not passed by sampling\n                    for(i = 0, il = segmentsQueue.length; i < il; ++i)addSegmentPoint(segmentsQueue[i]);\n                    return points;\n                };\n                Svg._svgPathToAbsolute = function(path) {\n                    // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n                    // Copyright (c) Gavin Kistner\n                    // http://phrogz.net/js/_ReuseLicense.txt\n                    // Modifications: tidy formatting and naming\n                    var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems;\n                    for(var i = 0; i < len; ++i){\n                        var seg = segs.getItem(i), segType = seg.pathSegTypeAsLetter;\n                        if (/[MLHVCSQTA]/.test(segType)) {\n                            if (\"x\" in seg) x = seg.x;\n                            if (\"y\" in seg) y = seg.y;\n                        } else {\n                            if (\"x1\" in seg) x1 = x + seg.x1;\n                            if (\"x2\" in seg) x2 = x + seg.x2;\n                            if (\"y1\" in seg) y1 = y + seg.y1;\n                            if (\"y2\" in seg) y2 = y + seg.y2;\n                            if (\"x\" in seg) x += seg.x;\n                            if (\"y\" in seg) y += seg.y;\n                            switch(segType){\n                                case \"m\":\n                                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n                                    break;\n                                case \"l\":\n                                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n                                    break;\n                                case \"h\":\n                                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n                                    break;\n                                case \"v\":\n                                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n                                    break;\n                                case \"c\":\n                                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n                                    break;\n                                case \"s\":\n                                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n                                    break;\n                                case \"q\":\n                                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n                                    break;\n                                case \"t\":\n                                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n                                    break;\n                                case \"a\":\n                                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n                                    break;\n                                case \"z\":\n                                case \"Z\":\n                                    x = x0;\n                                    y = y0;\n                                    break;\n                            }\n                        }\n                        if (segType == \"M\" || segType == \"m\") {\n                            x0 = x;\n                            y0 = y;\n                        }\n                    }\n                };\n            })();\n        /***/ },\n        /* 30 */ /***/ function(module1, exports1, __nested_webpack_require_405386__) {\n            /**\n* This module has now been replaced by `Matter.Composite`.\n*\n* All usage should be migrated to the equivalent functions found on `Matter.Composite`.\n* For example `World.add(world, body)` now becomes `Composite.add(world, body)`.\n*\n* The property `world.gravity` has been moved to `engine.gravity`.\n*\n* For back-compatibility purposes this module will remain as a direct alias to `Matter.Composite` in the short term during migration.\n* Eventually this alias module will be marked as deprecated and then later removed in a future release.\n*\n* @class World\n*/ var World = {};\n            module1.exports = World;\n            var Composite = __nested_webpack_require_405386__(6);\n            var Common = __nested_webpack_require_405386__(0);\n            (function() {\n                /**\n     * See above, aliases for back compatibility only\n     */ World.create = Composite.create;\n                World.add = Composite.add;\n                World.remove = Composite.remove;\n                World.clear = Composite.clear;\n                World.addComposite = Composite.addComposite;\n                World.addBody = Composite.addBody;\n                World.addConstraint = Composite.addConstraint;\n            })();\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbWF0dGVyLWpzQDAuMTkuMC9ub2RlX21vZHVsZXMvbWF0dGVyLWpzL2J1aWxkL21hdHRlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJDLEdBQ0EsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRDtTQUNiLEVBS3VCQTtBQUM3QixHQUFHLFFBQU07SUFDVCxPQUFnQixNQUFILEdBQUksU0FBU0ssT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsK0JBQW1CQSxDQUFDQyxRQUFRO1lBQy9DLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUFFO2dCQUMxQyxNQUFNLEdBQU0sT0FBT0YsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQ1AsT0FBTztZQUNyRCxNQUFNLEdBQUs7WUFDWCxNQUFNLEdBQUssa0RBQWtEO1lBQzdELE1BQU0sR0FBSyxJQUFJQyxVQUFTSSxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO2dCQUNyRCxNQUFNLEdBQU1DLEdBQUdEO2dCQUNmLE1BQU0sR0FBTUUsR0FBRztnQkFDZixNQUFNLEdBQU1ULFNBQVMsQ0FBQztZQUNYO1lBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLSSxPQUFPLENBQUNHLFNBQVMsQ0FBQ0csSUFBSSxDQUFDVCxRQUFPRCxPQUFPLEVBQUVDLFNBQVFBLFFBQU9ELE9BQU8sRUFBRU0sK0JBQW1CQTtZQUM3RixNQUFNLEdBQ04sTUFBTSxHQUFLLDRCQUE0QjtZQUN2QyxNQUFNLEdBQUtMLFFB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QyxHQUFHMDRCLElBQUlXLEVBQUUsRUFBRVgsSUFBSVksRUFBRSxFQUFFWixJQUFJcjNCLEtBQUssRUFBRXEzQixJQUFJYSxZQUFZLEVBQUViLElBQUljLFNBQVMsR0FBR3JpQztvQ0FDaEg7Z0NBQ0osS0FBSztnQ0FDTCxLQUFLO29DQUNENEksSUFBSXE0QjtvQ0FDSnA0QixJQUFJcTRCO29DQUNKOzRCQUVKO3dCQUNKO3dCQUVBLElBQUlYLFdBQVcsT0FBT0EsV0FBVyxLQUFLOzRCQUNsQ1UsS0FBS3I0Qjs0QkFDTHM0QixLQUFLcjRCO3dCQUNUO29CQUNKO2dCQUNKO1lBRUo7UUFFQSxHQUFHLEdBQUc7UUFDTixNQUFNLEdBQ04sR0FBRyxHQUFJLFNBQVNwSixPQUFNLEVBQUVELFFBQU8sRUFBRU0saUNBQW1CO1lBRXBEOzs7Ozs7Ozs7Ozs7QUFZQSxHQUVBLElBQUlnd0IsUUFBUSxDQUFDO1lBRWJyd0IsUUFBT0QsT0FBTyxHQUFHc3dCO1lBRWpCLElBQUlsWixZQUFZOVcsaUNBQW1CQSxDQUFDO1lBQ3BDLElBQUltQyxTQUFTbkMsaUNBQW1CQSxDQUFDO1lBRWhDO2dCQUVHOztLQUVDLEdBQ0Rnd0IsTUFBTXp1QixNQUFNLEdBQUd1VixVQUFVdlYsTUFBTTtnQkFDL0J5dUIsTUFBTWhsQixHQUFHLEdBQUc4TCxVQUFVOUwsR0FBRztnQkFDekJnbEIsTUFBTS9YLE1BQU0sR0FBR25CLFVBQVVtQixNQUFNO2dCQUMvQitYLE1BQU1yWCxLQUFLLEdBQUc3QixVQUFVNkIsS0FBSztnQkFDN0JxWCxNQUFNalksWUFBWSxHQUFHakIsVUFBVWlCLFlBQVk7Z0JBQzNDaVksTUFBTW5ZLE9BQU8sR0FBR2YsVUFBVWUsT0FBTztnQkFDakNtWSxNQUFNbFksYUFBYSxHQUFHaEIsVUFBVWdCLGFBQWE7WUFFakQ7UUFHQSxHQUFHLEdBQUc7S0FDSTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3BfZmluYWwvLi9ub2RlX21vZHVsZXMvLnBucG0vbWF0dGVyLWpzQDAuMTkuMC9ub2RlX21vZHVsZXMvbWF0dGVyLWpzL2J1aWxkL21hdHRlci5qcz84ODY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogbWF0dGVyLWpzIDAuMTkuMCBieSBAbGlhYnJ1XG4gKiBodHRwOi8vYnJtLmlvL21hdHRlci1qcy9cbiAqIExpY2Vuc2UgTUlUXG4gKiBcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIExpYW0gQnJ1bW1pdHQgYW5kIGNvbnRyaWJ1dG9ycy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIk1hdHRlclwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJNYXR0ZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiTWF0dGVyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5Db21tb25gIG1vZHVsZSBjb250YWlucyB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IGFyZSBjb21tb24gdG8gYWxsIG1vZHVsZXMuXG4qXG4qIEBjbGFzcyBDb21tb25cbiovXG5cbnZhciBDb21tb24gPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tb247XG5cbihmdW5jdGlvbigpIHtcblxuICAgIENvbW1vbi5fYmFzZURlbHRhID0gMTAwMCAvIDYwO1xuICAgIENvbW1vbi5fbmV4dElkID0gMDtcbiAgICBDb21tb24uX3NlZWQgPSAwO1xuICAgIENvbW1vbi5fbm93U3RhcnRUaW1lID0gKyhuZXcgRGF0ZSgpKTtcbiAgICBDb21tb24uX3dhcm5lZE9uY2UgPSB7fTtcbiAgICBDb21tb24uX2RlY29tcCA9IG51bGw7XG4gICAgXG4gICAgLyoqXG4gICAgICogRXh0ZW5kcyB0aGUgb2JqZWN0IGluIHRoZSBmaXJzdCBhcmd1bWVudCB1c2luZyB0aGUgb2JqZWN0IGluIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgICogQG1ldGhvZCBleHRlbmRcbiAgICAgKiBAcGFyYW0ge30gb2JqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkZWVwXG4gICAgICogQHJldHVybiB7fSBvYmogZXh0ZW5kZWRcbiAgICAgKi9cbiAgICBDb21tb24uZXh0ZW5kID0gZnVuY3Rpb24ob2JqLCBkZWVwKSB7XG4gICAgICAgIHZhciBhcmdzU3RhcnQsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgZGVlcENsb25lO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGVlcCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBhcmdzU3RhcnQgPSAyO1xuICAgICAgICAgICAgZGVlcENsb25lID0gZGVlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3NTdGFydCA9IDE7XG4gICAgICAgICAgICBkZWVwQ2xvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3NTdGFydDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWVwQ2xvbmUgJiYgc291cmNlW3Byb3BdICYmIHNvdXJjZVtwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtwcm9wXSB8fCBvYmpbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IG9ialtwcm9wXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb21tb24uZXh0ZW5kKG9ialtwcm9wXSwgZGVlcENsb25lLCBzb3VyY2VbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2xvbmUgb2YgdGhlIG9iamVjdCwgaWYgZGVlcCBpcyB0cnVlIHJlZmVyZW5jZXMgd2lsbCBhbHNvIGJlIGNsb25lZC5cbiAgICAgKiBAbWV0aG9kIGNsb25lXG4gICAgICogQHBhcmFtIHt9IG9ialxuICAgICAqIEBwYXJhbSB7Ym9vbH0gZGVlcFxuICAgICAqIEByZXR1cm4ge30gb2JqIGNsb25lZFxuICAgICAqL1xuICAgIENvbW1vbi5jbG9uZSA9IGZ1bmN0aW9uKG9iaiwgZGVlcCkge1xuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZCh7fSwgZGVlcCwgb2JqKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBrZXlzIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2Qga2V5c1xuICAgICAqIEBwYXJhbSB7fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0ga2V5c1xuICAgICAqL1xuICAgIENvbW1vbi5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuXG4gICAgICAgIC8vIGF2b2lkIGhhc093blByb3BlcnR5IGZvciBwZXJmb3JtYW5jZVxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZhbHVlcyBmb3IgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7fSBvYmpcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgdGhlIG9iamVjdHMgcHJvcGVydHkgdmFsdWVzXG4gICAgICovXG4gICAgQ29tbW9uLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXlzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBhdm9pZCBoYXNPd25Qcm9wZXJ0eSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG9ialtrZXldKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHZhbHVlIGZyb20gYGJhc2VgIHJlbGF0aXZlIHRvIHRoZSBgcGF0aGAgc3RyaW5nLlxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICogQHBhcmFtIHt9IG9iaiBUaGUgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWAsIGUuZy4gJ0Zvby5CYXIuYmF6J1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmVnaW5dIFBhdGggc2xpY2UgYmVnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gUGF0aCBzbGljZSBlbmRcbiAgICAgKiBAcmV0dXJuIHt9IFRoZSBvYmplY3QgYXQgdGhlIGdpdmVuIHBhdGhcbiAgICAgKi9cbiAgICBDb21tb24uZ2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJykuc2xpY2UoYmVnaW4sIGVuZCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBvYmogPSBvYmpbcGF0aFtpXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgb24gYGJhc2VgIHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBgcGF0aGAgc3RyaW5nLlxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtIHt9IG9iaiBUaGUgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgYmFzZWAsIGUuZy4gJ0Zvby5CYXIuYmF6J1xuICAgICAqIEBwYXJhbSB7fSB2YWwgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYmVnaW5dIFBhdGggc2xpY2UgYmVnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF0gUGF0aCBzbGljZSBlbmRcbiAgICAgKiBAcmV0dXJuIHt9IFBhc3MgdGhyb3VnaCBgdmFsYCBmb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBDb21tb24uc2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCB2YWwsIGJlZ2luLCBlbmQpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLicpLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgICBDb21tb24uZ2V0KG9iaiwgcGF0aCwgMCwgLTEpW3BhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2h1ZmZsZXMgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlLlxuICAgICAqIFRoZSBmdW5jdGlvbiB1c2VzIGEgc2VlZGVkIHJhbmRvbSBnZW5lcmF0b3IuXG4gICAgICogQG1ldGhvZCBzaHVmZmxlXG4gICAgICogQHBhcmFtIHthcnJheX0gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gYXJyYXkgc2h1ZmZsZWQgcmFuZG9tbHlcbiAgICAgKi9cbiAgICBDb21tb24uc2h1ZmZsZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoQ29tbW9uLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGFycmF5W2ldO1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgICAgIGFycmF5W2pdID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJhbmRvbWx5IGNob29zZXMgYSB2YWx1ZSBmcm9tIGEgbGlzdCB3aXRoIGVxdWFsIHByb2JhYmlsaXR5LlxuICAgICAqIFRoZSBmdW5jdGlvbiB1c2VzIGEgc2VlZGVkIHJhbmRvbSBnZW5lcmF0b3IuXG4gICAgICogQG1ldGhvZCBjaG9vc2VcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBjaG9pY2VzXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHJhbmRvbSBjaG9pY2Ugb2JqZWN0IGZyb20gdGhlIGFycmF5XG4gICAgICovXG4gICAgQ29tbW9uLmNob29zZSA9IGZ1bmN0aW9uKGNob2ljZXMpIHtcbiAgICAgICAgcmV0dXJuIGNob2ljZXNbTWF0aC5mbG9vcihDb21tb24ucmFuZG9tKCkgKiBjaG9pY2VzLmxlbmd0aCldO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIEhUTUxFbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogQG1ldGhvZCBpc0VsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgSFRNTEVsZW1lbnQsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlICYmIG9iai5ub2RlTmFtZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGFycmF5LlxuICAgICAqIEBtZXRob2QgaXNBcnJheVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gYXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBmdW5jdGlvbi5cbiAgICAgKiBAbWV0aG9kIGlzRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBtZXRob2QgaXNQbGFpbk9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBwbGFpbiBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBzdHJpbmcuXG4gICAgICogQG1ldGhvZCBpc1N0cmluZ1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBzdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIENvbW1vbi5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdpdmVuIHZhbHVlIGNsYW1wZWQgYmV0d2VlbiBhIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUuXG4gICAgICogQG1ldGhvZCBjbGFtcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgY2xhbXBlZCBiZXR3ZWVuIG1pbiBhbmQgbWF4IGluY2x1c2l2ZVxuICAgICAqL1xuICAgIENvbW1vbi5jbGFtcCA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAodmFsdWUgPCBtaW4pXG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXgpXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAbWV0aG9kIHNpZ25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0xIGlmIG5lZ2F0aXZlLCArMSBpZiAwIG9yIHBvc2l0aXZlXG4gICAgICovXG4gICAgQ29tbW9uLnNpZ24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gLTEgOiAxO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lc3RhbXAgc2luY2UgdGhlIHRpbWUgb3JpZ2luIChlLmcuIGZyb20gcGFnZSBsb2FkKS5cbiAgICAgKiBUaGUgcmVzdWx0IGlzIGluIG1pbGxpc2Vjb25kcyBhbmQgd2lsbCB1c2UgaGlnaC1yZXNvbHV0aW9uIHRpbWluZyBpZiBhdmFpbGFibGUuXG4gICAgICogQG1ldGhvZCBub3dcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBDb21tb24ubm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LnBlcmZvcm1hbmNlLndlYmtpdE5vdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uud2Via2l0Tm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRGF0ZS5ub3cpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSgpKSAtIENvbW1vbi5fbm93U3RhcnRUaW1lO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSB2YWx1ZSBiZXR3ZWVuIGEgbWluaW11bSBhbmQgYSBtYXhpbXVtIHZhbHVlIGluY2x1c2l2ZS5cbiAgICAgKiBUaGUgZnVuY3Rpb24gdXNlcyBhIHNlZWRlZCByYW5kb20gZ2VuZXJhdG9yLlxuICAgICAqIEBtZXRob2QgcmFuZG9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IGluY2x1c2l2ZVxuICAgICAqL1xuICAgIENvbW1vbi5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgICBtaW4gPSAodHlwZW9mIG1pbiAhPT0gXCJ1bmRlZmluZWRcIikgPyBtaW4gOiAwO1xuICAgICAgICBtYXggPSAodHlwZW9mIG1heCAhPT0gXCJ1bmRlZmluZWRcIikgPyBtYXggOiAxO1xuICAgICAgICByZXR1cm4gbWluICsgX3NlZWRlZFJhbmRvbSgpICogKG1heCAtIG1pbik7XG4gICAgfTtcblxuICAgIHZhciBfc2VlZGVkUmFuZG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9jb25ncnVlbnRpYWxfZ2VuZXJhdG9yXG4gICAgICAgIENvbW1vbi5fc2VlZCA9IChDb21tb24uX3NlZWQgKiA5MzAxICsgNDkyOTcpICUgMjMzMjgwO1xuICAgICAgICByZXR1cm4gQ29tbW9uLl9zZWVkIC8gMjMzMjgwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIENTUyBoZXggY29sb3VyIHN0cmluZyBpbnRvIGFuIGludGVnZXIuXG4gICAgICogQG1ldGhvZCBjb2xvclRvTnVtYmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yU3RyaW5nXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgQ1NTIGhleCBzdHJpbmdcbiAgICAgKi9cbiAgICBDb21tb24uY29sb3JUb051bWJlciA9IGZ1bmN0aW9uKGNvbG9yU3RyaW5nKSB7XG4gICAgICAgIGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcucmVwbGFjZSgnIycsJycpO1xuXG4gICAgICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5jaGFyQXQoMCkgKyBjb2xvclN0cmluZy5jaGFyQXQoMClcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3JTdHJpbmcuY2hhckF0KDEpICsgY29sb3JTdHJpbmcuY2hhckF0KDEpXG4gICAgICAgICAgICAgICAgICAgICAgICArIGNvbG9yU3RyaW5nLmNoYXJBdCgyKSArIGNvbG9yU3RyaW5nLmNoYXJBdCgyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc29sZSBsb2dnaW5nIGxldmVsIHRvIHVzZSwgd2hlcmUgZWFjaCBsZXZlbCBpbmNsdWRlcyBhbGwgbGV2ZWxzIGFib3ZlIGFuZCBleGNsdWRlcyB0aGUgbGV2ZWxzIGJlbG93LlxuICAgICAqIFRoZSBkZWZhdWx0IGxldmVsIGlzICdkZWJ1Zycgd2hpY2ggc2hvd3MgYWxsIGNvbnNvbGUgbWVzc2FnZXMuICBcbiAgICAgKlxuICAgICAqIFBvc3NpYmxlIGxldmVsIHZhbHVlcyBhcmU6XG4gICAgICogLSAwID0gTm9uZVxuICAgICAqIC0gMSA9IERlYnVnXG4gICAgICogLSAyID0gSW5mb1xuICAgICAqIC0gMyA9IFdhcm5cbiAgICAgKiAtIDQgPSBFcnJvclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJvcGVydHkgbG9nTGV2ZWxcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICBDb21tb24ubG9nTGV2ZWwgPSAxO1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBgY29uc29sZS5sb2dgIG1lc3NhZ2Ugb25seSBpZiB0aGUgY3VycmVudCBgQ29tbW9uLmxvZ0xldmVsYCBhbGxvd3MgaXQuXG4gICAgICogVGhlIG1lc3NhZ2Ugd2lsbCBiZSBwcmVmaXhlZCB3aXRoICdtYXR0ZXItanMnIHRvIG1ha2UgaXQgZWFzaWx5IGlkZW50aWZpYWJsZS5cbiAgICAgKiBAbWV0aG9kIGxvZ1xuICAgICAqIEBwYXJhbSAuLi5vYmpzIHt9IFRoZSBvYmplY3RzIHRvIGxvZy5cbiAgICAgKi9cbiAgICBDb21tb24ubG9nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjb25zb2xlICYmIENvbW1vbi5sb2dMZXZlbCA+IDAgJiYgQ29tbW9uLmxvZ0xldmVsIDw9IDMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFsnbWF0dGVyLWpzOiddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBgY29uc29sZS5pbmZvYCBtZXNzYWdlIG9ubHkgaWYgdGhlIGN1cnJlbnQgYENvbW1vbi5sb2dMZXZlbGAgYWxsb3dzIGl0LlxuICAgICAqIFRoZSBtZXNzYWdlIHdpbGwgYmUgcHJlZml4ZWQgd2l0aCAnbWF0dGVyLWpzJyB0byBtYWtlIGl0IGVhc2lseSBpZGVudGlmaWFibGUuXG4gICAgICogQG1ldGhvZCBpbmZvXG4gICAgICogQHBhcmFtIC4uLm9ianMge30gVGhlIG9iamVjdHMgdG8gbG9nLlxuICAgICAqL1xuICAgIENvbW1vbi5pbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjb25zb2xlICYmIENvbW1vbi5sb2dMZXZlbCA+IDAgJiYgQ29tbW9uLmxvZ0xldmVsIDw9IDIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBbJ21hdHRlci1qczonXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3dzIGEgYGNvbnNvbGUud2FybmAgbWVzc2FnZSBvbmx5IGlmIHRoZSBjdXJyZW50IGBDb21tb24ubG9nTGV2ZWxgIGFsbG93cyBpdC5cbiAgICAgKiBUaGUgbWVzc2FnZSB3aWxsIGJlIHByZWZpeGVkIHdpdGggJ21hdHRlci1qcycgdG8gbWFrZSBpdCBlYXNpbHkgaWRlbnRpZmlhYmxlLlxuICAgICAqIEBtZXRob2Qgd2FyblxuICAgICAqIEBwYXJhbSAuLi5vYmpzIHt9IFRoZSBvYmplY3RzIHRvIGxvZy5cbiAgICAgKi9cbiAgICBDb21tb24ud2FybiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY29uc29sZSAmJiBDb21tb24ubG9nTGV2ZWwgPiAwICYmIENvbW1vbi5sb2dMZXZlbCA8PSAzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgWydtYXR0ZXItanM6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGBDb21tb24ud2FybmAgdG8gbG9nIHRoZSBnaXZlbiBtZXNzYWdlIG9uZSB0aW1lIG9ubHkuXG4gICAgICogQG1ldGhvZCB3YXJuT25jZVxuICAgICAqIEBwYXJhbSAuLi5vYmpzIHt9IFRoZSBvYmplY3RzIHRvIGxvZy5cbiAgICAgKi9cbiAgICBDb21tb24ud2Fybk9uY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKTtcblxuICAgICAgICBpZiAoIUNvbW1vbi5fd2FybmVkT25jZVttZXNzYWdlXSkge1xuICAgICAgICAgICAgQ29tbW9uLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICBDb21tb24uX3dhcm5lZE9uY2VbbWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3dzIGEgZGVwcmVjYXRlZCBjb25zb2xlIHdhcm5pbmcgd2hlbiB0aGUgZnVuY3Rpb24gb24gdGhlIGdpdmVuIG9iamVjdCBpcyBjYWxsZWQuXG4gICAgICogVGhlIHRhcmdldCBmdW5jdGlvbiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYSBuZXcgZnVuY3Rpb24gdGhhdCBmaXJzdCBzaG93cyB0aGUgd2FybmluZ1xuICAgICAqIGFuZCB0aGVuIGNhbGxzIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgICAgKiBAbWV0aG9kIGRlcHJlY2F0ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIFRoZSBvYmplY3Qgb3IgbW9kdWxlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGZ1bmN0aW9uIG9uIG9ialxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YXJuaW5nIFRoZSBvbmUtdGltZSBtZXNzYWdlIHRvIHNob3cgaWYgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgICAqL1xuICAgIENvbW1vbi5kZXByZWNhdGVkID0gZnVuY3Rpb24ob2JqLCBwcm9wLCB3YXJuaW5nKSB7XG4gICAgICAgIG9ialtwcm9wXSA9IENvbW1vbi5jaGFpbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuT25jZSgn8J+UhSBkZXByZWNhdGVkIPCflIUnLCB3YXJuaW5nKTtcbiAgICAgICAgfSwgb2JqW3Byb3BdKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgc2VxdWVudGlhbCBJRC5cbiAgICAgKiBAbWV0aG9kIG5leHRJZFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVW5pcXVlIHNlcXVlbnRpYWwgSURcbiAgICAgKi9cbiAgICBDb21tb24ubmV4dElkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uX25leHRJZCsrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGNyb3NzIGJyb3dzZXIgY29tcGF0aWJsZSBpbmRleE9mIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBtZXRob2QgaW5kZXhPZlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGhheXN0YWNrXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5lZWRsZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIG9mIG5lZWRsZSBpbiBoYXlzdGFjaywgb3RoZXJ3aXNlIC0xLlxuICAgICAqL1xuICAgIENvbW1vbi5pbmRleE9mID0gZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSkge1xuICAgICAgICBpZiAoaGF5c3RhY2suaW5kZXhPZilcbiAgICAgICAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXlzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGhheXN0YWNrW2ldID09PSBuZWVkbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgY3Jvc3MgYnJvd3NlciBjb21wYXRpYmxlIGFycmF5IG1hcCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAbWV0aG9kIG1hcFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGxpc3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHJldHVybiB7YXJyYXl9IFZhbHVlcyBmcm9tIGxpc3QgdHJhbnNmb3JtZWQgYnkgZnVuYy5cbiAgICAgKi9cbiAgICBDb21tb24ubWFwID0gZnVuY3Rpb24obGlzdCwgZnVuYykge1xuICAgICAgICBpZiAobGlzdC5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKGZ1bmMobGlzdFtpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBkaXJlY3RlZCBncmFwaCBhbmQgcmV0dXJucyB0aGUgcGFydGlhbGx5IG9yZGVyZWQgc2V0IG9mIHZlcnRpY2VzIGluIHRvcG9sb2dpY2FsIG9yZGVyLlxuICAgICAqIENpcmN1bGFyIGRlcGVuZGVuY2llcyBhcmUgYWxsb3dlZC5cbiAgICAgKiBAbWV0aG9kIHRvcG9sb2dpY2FsU29ydFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaFxuICAgICAqIEByZXR1cm4ge2FycmF5fSBQYXJ0aWFsbHkgb3JkZXJlZCBzZXQgb2YgdmVydGljZXMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIuXG4gICAgICovXG4gICAgQ29tbW9uLnRvcG9sb2dpY2FsU29ydCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZ2VjaGV2L2phdmFzY3JpcHQtYWxnb3JpdGhtc1xuICAgICAgICAvLyBDb3B5cmlnaHQgKGMpIE1pbmtvIEdlY2hldiAoTUlUIGxpY2Vuc2UpXG4gICAgICAgIC8vIE1vZGlmaWNhdGlvbnM6IHRpZHkgZm9ybWF0dGluZyBhbmQgbmFtaW5nXG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHZpc2l0ZWQgPSBbXSxcbiAgICAgICAgICAgIHRlbXAgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBub2RlIGluIGdyYXBoKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbm9kZV0gJiYgIXRlbXBbbm9kZV0pIHtcbiAgICAgICAgICAgICAgICBDb21tb24uX3RvcG9sb2dpY2FsU29ydChub2RlLCB2aXNpdGVkLCB0ZW1wLCBncmFwaCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvbW1vbi5fdG9wb2xvZ2ljYWxTb3J0ID0gZnVuY3Rpb24obm9kZSwgdmlzaXRlZCwgdGVtcCwgZ3JhcGgsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGhbbm9kZV0gfHwgW107XG4gICAgICAgIHRlbXBbbm9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cbiAgICAgICAgICAgIGlmICh0ZW1wW25laWdoYm9yXSkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtuZWlnaGJvcl0pIHtcbiAgICAgICAgICAgICAgICBDb21tb24uX3RvcG9sb2dpY2FsU29ydChuZWlnaGJvciwgdmlzaXRlZCwgdGVtcCwgZ3JhcGgsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wW25vZGVdID0gZmFsc2U7XG4gICAgICAgIHZpc2l0ZWRbbm9kZV0gPSB0cnVlO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBfbl8gZnVuY3Rpb25zIGFzIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZW0gaW4gb3JkZXIuXG4gICAgICogVGhlIGFyZ3VtZW50cyBhcHBsaWVkIHdoZW4gY2FsbGluZyB0aGUgbmV3IGZ1bmN0aW9uIHdpbGwgYWxzbyBiZSBhcHBsaWVkIHRvIGV2ZXJ5IGZ1bmN0aW9uIHBhc3NlZC5cbiAgICAgKiBUaGUgdmFsdWUgb2YgYHRoaXNgIHJlZmVycyB0byB0aGUgbGFzdCB2YWx1ZSByZXR1cm5lZCBpbiB0aGUgY2hhaW4gdGhhdCB3YXMgbm90IGB1bmRlZmluZWRgLlxuICAgICAqIFRoZXJlZm9yZSBpZiBhIHBhc3NlZCBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZSwgdGhlIHByZXZpb3VzbHkgcmV0dXJuZWQgdmFsdWUgaXMgbWFpbnRhaW5lZC5cbiAgICAgKiBBZnRlciBhbGwgcGFzc2VkIGZ1bmN0aW9ucyBoYXZlIGJlZW4gY2FsbGVkIHRoZSBuZXcgZnVuY3Rpb24gcmV0dXJucyB0aGUgbGFzdCByZXR1cm5lZCB2YWx1ZSAoaWYgYW55KS5cbiAgICAgKiBJZiBhbnkgb2YgdGhlIHBhc3NlZCBmdW5jdGlvbnMgYXJlIGEgY2hhaW4sIHRoZW4gdGhlIGNoYWluIHdpbGwgYmUgZmxhdHRlbmVkLlxuICAgICAqIEBtZXRob2QgY2hhaW5cbiAgICAgKiBAcGFyYW0gLi4uZnVuY3Mge2Z1bmN0aW9ufSBUaGUgZnVuY3Rpb25zIHRvIGNoYWluLlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBwYXNzZWQgZnVuY3Rpb25zIGluIG9yZGVyLlxuICAgICAqL1xuICAgIENvbW1vbi5jaGFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZnVuY3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgICAgIGlmIChmdW5jLl9jaGFpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxhdHRlbiBhbHJlYWR5IGNoYWluZWQgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgZnVuY3MucHVzaC5hcHBseShmdW5jcywgZnVuYy5fY2hhaW5lZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZ1bmNzLnB1c2goZnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvZGV2dG9vbHMtZG9jcy9pc3N1ZXMvNTMjaXNzdWVjb21tZW50LTUxOTQxMzU4XG4gICAgICAgICAgICB2YXIgbGFzdFJlc3VsdCxcbiAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuY3NbaV0uYXBwbHkobGFzdFJlc3VsdCwgYXJncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNoYWluLl9jaGFpbmVkID0gZnVuY3M7XG5cbiAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYmVmb3JlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbiB0aGUgZ2l2ZW4gYHBhdGhgIHJlbGF0aXZlIHRvIGBiYXNlYC5cbiAgICAgKiBTZWUgYWxzbyBkb2NzIGZvciBgQ29tbW9uLmNoYWluYC5cbiAgICAgKiBAbWV0aG9kIGNoYWluUGF0aEJlZm9yZVxuICAgICAqIEBwYXJhbSB7fSBiYXNlIFRoZSBiYXNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBiYXNlYFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoYWluIGJlZm9yZSB0aGUgb3JpZ2luYWxcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGNoYWluZWQgZnVuY3Rpb24gdGhhdCByZXBsYWNlZCB0aGUgb3JpZ2luYWxcbiAgICAgKi9cbiAgICBDb21tb24uY2hhaW5QYXRoQmVmb3JlID0gZnVuY3Rpb24oYmFzZSwgcGF0aCwgZnVuYykge1xuICAgICAgICByZXR1cm4gQ29tbW9uLnNldChiYXNlLCBwYXRoLCBDb21tb24uY2hhaW4oXG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICAgICAgQ29tbW9uLmdldChiYXNlLCBwYXRoKVxuICAgICAgICApKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhaW5zIGEgZnVuY3Rpb24gdG8gZXhjdXRlIGFmdGVyIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvbiB0aGUgZ2l2ZW4gYHBhdGhgIHJlbGF0aXZlIHRvIGBiYXNlYC5cbiAgICAgKiBTZWUgYWxzbyBkb2NzIGZvciBgQ29tbW9uLmNoYWluYC5cbiAgICAgKiBAbWV0aG9kIGNoYWluUGF0aEFmdGVyXG4gICAgICogQHBhcmFtIHt9IGJhc2UgVGhlIGJhc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggcmVsYXRpdmUgdG8gYGJhc2VgXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hhaW4gYWZ0ZXIgdGhlIG9yaWdpbmFsXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXG4gICAgICovXG4gICAgQ29tbW9uLmNoYWluUGF0aEFmdGVyID0gZnVuY3Rpb24oYmFzZSwgcGF0aCwgZnVuYykge1xuICAgICAgICByZXR1cm4gQ29tbW9uLnNldChiYXNlLCBwYXRoLCBDb21tb24uY2hhaW4oXG4gICAgICAgICAgICBDb21tb24uZ2V0KGJhc2UsIHBhdGgpLFxuICAgICAgICAgICAgZnVuY1xuICAgICAgICApKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSB0aGUgW3BvbHktZGVjb21wXShodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvcG9seS1kZWNvbXAuanMpIGxpYnJhcnkgbW9kdWxlIHRvIGVuYWJsZVxuICAgICAqIGNvbmNhdmUgdmVydGV4IGRlY29tcG9zaXRpb24gc3VwcG9ydCB3aGVuIHVzaW5nIGBCb2RpZXMuZnJvbVZlcnRpY2VzYCBlLmcuIGBDb21tb24uc2V0RGVjb21wKHJlcXVpcmUoJ3BvbHktZGVjb21wJykpYC5cbiAgICAgKiBAbWV0aG9kIHNldERlY29tcFxuICAgICAqIEBwYXJhbSB7fSBkZWNvbXAgVGhlIFtwb2x5LWRlY29tcF0oaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3BvbHktZGVjb21wLmpzKSBsaWJyYXJ5IG1vZHVsZS5cbiAgICAgKi9cbiAgICBDb21tb24uc2V0RGVjb21wID0gZnVuY3Rpb24oZGVjb21wKSB7XG4gICAgICAgIENvbW1vbi5fZGVjb21wID0gZGVjb21wO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBbcG9seS1kZWNvbXBdKGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9wb2x5LWRlY29tcC5qcykgbGlicmFyeSBtb2R1bGUgcHJvdmlkZWQgdGhyb3VnaCBgQ29tbW9uLnNldERlY29tcGAsXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgdGhlIGdsb2JhbCBgZGVjb21wYCBpZiBzZXQuXG4gICAgICogQG1ldGhvZCBnZXREZWNvbXBcbiAgICAgKiBAcmV0dXJuIHt9IFRoZSBbcG9seS1kZWNvbXBdKGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9wb2x5LWRlY29tcC5qcykgbGlicmFyeSBtb2R1bGUgaWYgcHJvdmlkZWQuXG4gICAgICovXG4gICAgQ29tbW9uLmdldERlY29tcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBnZXQgdXNlciBwcm92aWRlZCBkZWNvbXAgaWYgc2V0XG4gICAgICAgIHZhciBkZWNvbXAgPSBDb21tb24uX2RlY29tcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZyb20gd2luZG93IGdsb2JhbFxuICAgICAgICAgICAgaWYgKCFkZWNvbXAgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZWNvbXAgPSB3aW5kb3cuZGVjb21wO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZyb20gbm9kZSBnbG9iYWxcbiAgICAgICAgICAgIGlmICghZGVjb21wICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVjb21wID0gZ2xvYmFsLmRlY29tcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gZGVjb21wIG5vdCBhdmFpbGFibGVcbiAgICAgICAgICAgIGRlY29tcCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVjb21wO1xuICAgIH07XG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuQm91bmRzYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94ZXMgKEFBQkIpLlxuKlxuKiBAY2xhc3MgQm91bmRzXG4qL1xuXG52YXIgQm91bmRzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQm91bmRzO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggKEFBQkIpIGZvciB0aGUgZ2l2ZW4gdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4ge2JvdW5kc30gQSBuZXcgYm91bmRzIG9iamVjdFxuICAgICAqL1xuICAgIEJvdW5kcy5jcmVhdGUgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICB2YXIgYm91bmRzID0geyBcbiAgICAgICAgICAgIG1pbjogeyB4OiAwLCB5OiAwIH0sIFxuICAgICAgICAgICAgbWF4OiB7IHg6IDAsIHk6IDAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh2ZXJ0aWNlcylcbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUoYm91bmRzLCB2ZXJ0aWNlcyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGJvdW5kcyB1c2luZyB0aGUgZ2l2ZW4gdmVydGljZXMgYW5kIGV4dGVuZHMgdGhlIGJvdW5kcyBnaXZlbiBhIHZlbG9jaXR5LlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlbG9jaXR5XG4gICAgICovXG4gICAgQm91bmRzLnVwZGF0ZSA9IGZ1bmN0aW9uKGJvdW5kcywgdmVydGljZXMsIHZlbG9jaXR5KSB7XG4gICAgICAgIGJvdW5kcy5taW4ueCA9IEluZmluaXR5O1xuICAgICAgICBib3VuZHMubWF4LnggPSAtSW5maW5pdHk7XG4gICAgICAgIGJvdW5kcy5taW4ueSA9IEluZmluaXR5O1xuICAgICAgICBib3VuZHMubWF4LnkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgaWYgKHZlcnRleC54ID4gYm91bmRzLm1heC54KSBib3VuZHMubWF4LnggPSB2ZXJ0ZXgueDtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgueCA8IGJvdW5kcy5taW4ueCkgYm91bmRzLm1pbi54ID0gdmVydGV4Lng7XG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPiBib3VuZHMubWF4LnkpIGJvdW5kcy5tYXgueSA9IHZlcnRleC55O1xuICAgICAgICAgICAgaWYgKHZlcnRleC55IDwgYm91bmRzLm1pbi55KSBib3VuZHMubWluLnkgPSB2ZXJ0ZXgueTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHZlbG9jaXR5KSB7XG4gICAgICAgICAgICBpZiAodmVsb2NpdHkueCA+IDApIHtcbiAgICAgICAgICAgICAgICBib3VuZHMubWF4LnggKz0gdmVsb2NpdHkueDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLm1pbi54ICs9IHZlbG9jaXR5Lng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh2ZWxvY2l0eS55ID4gMCkge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5tYXgueSArPSB2ZWxvY2l0eS55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3VuZHMubWluLnkgKz0gdmVsb2NpdHkueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJvdW5kcyBjb250YWlucyB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgICogQG1ldGhvZCBjb250YWluc1xuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBib3VuZHMgY29udGFpbiB0aGUgcG9pbnQsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIEJvdW5kcy5jb250YWlucyA9IGZ1bmN0aW9uKGJvdW5kcywgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPj0gYm91bmRzLm1pbi54ICYmIHBvaW50LnggPD0gYm91bmRzLm1heC54IFxuICAgICAgICAgICAgICAgJiYgcG9pbnQueSA+PSBib3VuZHMubWluLnkgJiYgcG9pbnQueSA8PSBib3VuZHMubWF4Lnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGJvdW5kcyBpbnRlcnNlY3QuXG4gICAgICogQG1ldGhvZCBvdmVybGFwc1xuICAgICAqIEBwYXJhbSB7Ym91bmRzfSBib3VuZHNBXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc0JcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBib3VuZHMgb3ZlcmxhcCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICovXG4gICAgQm91bmRzLm92ZXJsYXBzID0gZnVuY3Rpb24oYm91bmRzQSwgYm91bmRzQikge1xuICAgICAgICByZXR1cm4gKGJvdW5kc0EubWluLnggPD0gYm91bmRzQi5tYXgueCAmJiBib3VuZHNBLm1heC54ID49IGJvdW5kc0IubWluLnhcbiAgICAgICAgICAgICAgICAmJiBib3VuZHNBLm1heC55ID49IGJvdW5kc0IubWluLnkgJiYgYm91bmRzQS5taW4ueSA8PSBib3VuZHNCLm1heC55KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgYm91bmRzIGJ5IHRoZSBnaXZlbiB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCB0cmFuc2xhdGVcbiAgICAgKiBAcGFyYW0ge2JvdW5kc30gYm91bmRzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqL1xuICAgIEJvdW5kcy50cmFuc2xhdGUgPSBmdW5jdGlvbihib3VuZHMsIHZlY3Rvcikge1xuICAgICAgICBib3VuZHMubWluLnggKz0gdmVjdG9yLng7XG4gICAgICAgIGJvdW5kcy5tYXgueCArPSB2ZWN0b3IueDtcbiAgICAgICAgYm91bmRzLm1pbi55ICs9IHZlY3Rvci55O1xuICAgICAgICBib3VuZHMubWF4LnkgKz0gdmVjdG9yLnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyB0aGUgYm91bmRzIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKiBAbWV0aG9kIHNoaWZ0XG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb3NpdGlvblxuICAgICAqL1xuICAgIEJvdW5kcy5zaGlmdCA9IGZ1bmN0aW9uKGJvdW5kcywgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGJvdW5kcy5tYXgueCAtIGJvdW5kcy5taW4ueCxcbiAgICAgICAgICAgIGRlbHRhWSA9IGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueTtcbiAgICAgICAgICAgIFxuICAgICAgICBib3VuZHMubWluLnggPSBwb3NpdGlvbi54O1xuICAgICAgICBib3VuZHMubWF4LnggPSBwb3NpdGlvbi54ICsgZGVsdGFYO1xuICAgICAgICBib3VuZHMubWluLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICBib3VuZHMubWF4LnkgPSBwb3NpdGlvbi55ICsgZGVsdGFZO1xuICAgIH07XG4gICAgXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuVmVjdG9yYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyB2ZWN0b3JzLlxuKiBWZWN0b3JzIGFyZSB0aGUgYmFzaXMgb2YgYWxsIHRoZSBnZW9tZXRyeSByZWxhdGVkIG9wZXJhdGlvbnMgaW4gdGhlIGVuZ2luZS5cbiogQSBgTWF0dGVyLlZlY3RvcmAgb2JqZWN0IGlzIG9mIHRoZSBmb3JtIGB7IHg6IDAsIHk6IDAgfWAuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBWZWN0b3JcbiovXG5cbi8vIFRPRE86IGNvbnNpZGVyIHBhcmFtcyBmb3IgcmV1c2luZyB2ZWN0b3Igb2JqZWN0c1xuXG52YXIgVmVjdG9yID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZlY3Rvci5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvclxuICAgICAqL1xuICAgIFZlY3Rvci5jcmVhdGUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggfHwgMCwgeTogeSB8fCAwIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHdpdGggYHhgIGFuZCBgeWAgY29waWVkIGZyb20gdGhlIGdpdmVuIGB2ZWN0b3JgLlxuICAgICAqIEBtZXRob2QgY2xvbmVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyBjbG9uZWQgdmVjdG9yXG4gICAgICovXG4gICAgVmVjdG9yLmNsb25lID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54LCB5OiB2ZWN0b3IueSB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYWduaXR1ZGUgKGxlbmd0aCkgb2YgYSB2ZWN0b3IuXG4gICAgICogQG1ldGhvZCBtYWduaXR1ZGVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IubWFnbml0dWRlID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHZlY3Rvci54ICogdmVjdG9yLngpICsgKHZlY3Rvci55ICogdmVjdG9yLnkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFnbml0dWRlIChsZW5ndGgpIG9mIGEgdmVjdG9yICh0aGVyZWZvcmUgc2F2aW5nIGEgYHNxcnRgIG9wZXJhdGlvbikuXG4gICAgICogQG1ldGhvZCBtYWduaXR1ZGVTcXVhcmVkXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IubWFnbml0dWRlU3F1YXJlZCA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICByZXR1cm4gKHZlY3Rvci54ICogdmVjdG9yLngpICsgKHZlY3Rvci55ICogdmVjdG9yLnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSB2ZWN0b3IgYWJvdXQgKDAsIDApIGJ5IHNwZWNpZmllZCBhbmdsZS5cbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW291dHB1dF1cbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSB2ZWN0b3Igcm90YXRlZCBhYm91dCAoMCwgMClcbiAgICAgKi9cbiAgICBWZWN0b3Iucm90YXRlID0gZnVuY3Rpb24odmVjdG9yLCBhbmdsZSwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgICB2YXIgeCA9IHZlY3Rvci54ICogY29zIC0gdmVjdG9yLnkgKiBzaW47XG4gICAgICAgIG91dHB1dC55ID0gdmVjdG9yLnggKiBzaW4gKyB2ZWN0b3IueSAqIGNvcztcbiAgICAgICAgb3V0cHV0LnggPSB4O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoZSB2ZWN0b3IgYWJvdXQgYSBzcGVjaWZpZWQgcG9pbnQgYnkgc3BlY2lmaWVkIGFuZ2xlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlQWJvdXRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igcm90YXRlZCBhYm91dCB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBWZWN0b3Iucm90YXRlQWJvdXQgPSBmdW5jdGlvbih2ZWN0b3IsIGFuZ2xlLCBwb2ludCwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgICB2YXIgeCA9IHBvaW50LnggKyAoKHZlY3Rvci54IC0gcG9pbnQueCkgKiBjb3MgLSAodmVjdG9yLnkgLSBwb2ludC55KSAqIHNpbik7XG4gICAgICAgIG91dHB1dC55ID0gcG9pbnQueSArICgodmVjdG9yLnggLSBwb2ludC54KSAqIHNpbiArICh2ZWN0b3IueSAtIHBvaW50LnkpICogY29zKTtcbiAgICAgICAgb3V0cHV0LnggPSB4O1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpc2VzIGEgdmVjdG9yIChzdWNoIHRoYXQgaXRzIG1hZ25pdHVkZSBpcyBgMWApLlxuICAgICAqIEBtZXRob2Qgbm9ybWFsaXNlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEByZXR1cm4ge3ZlY3Rvcn0gQSBuZXcgdmVjdG9yIG5vcm1hbGlzZWRcbiAgICAgKi9cbiAgICBWZWN0b3Iubm9ybWFsaXNlID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBWZWN0b3IubWFnbml0dWRlKHZlY3Rvcik7XG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHJldHVybiB7IHg6IHZlY3Rvci54IC8gbWFnbml0dWRlLCB5OiB2ZWN0b3IueSAvIG1hZ25pdHVkZSB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkb3QtcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGRvdFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgdHdvIHZlY3RvcnNcbiAgICAgKi9cbiAgICBWZWN0b3IuZG90ID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xuICAgICAgICByZXR1cm4gKHZlY3RvckEueCAqIHZlY3RvckIueCkgKyAodmVjdG9yQS55ICogdmVjdG9yQi55KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cbiAgICAgKiBAbWV0aG9kIGNyb3NzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIHR3byB2ZWN0b3JzXG4gICAgICovXG4gICAgVmVjdG9yLmNyb3NzID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xuICAgICAgICByZXR1cm4gKHZlY3RvckEueCAqIHZlY3RvckIueSkgLSAodmVjdG9yQS55ICogdmVjdG9yQi54KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzLlxuICAgICAqIEBtZXRob2QgY3Jvc3MzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckFcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQlxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JDXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgdGhyZWUgdmVjdG9yc1xuICAgICAqL1xuICAgIFZlY3Rvci5jcm9zczMgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCB2ZWN0b3JDKSB7XG4gICAgICAgIHJldHVybiAodmVjdG9yQi54IC0gdmVjdG9yQS54KSAqICh2ZWN0b3JDLnkgLSB2ZWN0b3JBLnkpIC0gKHZlY3RvckIueSAtIHZlY3RvckEueSkgKiAodmVjdG9yQy54IC0gdmVjdG9yQS54KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgdHdvIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igb2YgdmVjdG9yQSBhbmQgdmVjdG9yQiBhZGRlZFxuICAgICAqL1xuICAgIFZlY3Rvci5hZGQgPSBmdW5jdGlvbih2ZWN0b3JBLCB2ZWN0b3JCLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKCFvdXRwdXQpIG91dHB1dCA9IHt9O1xuICAgICAgICBvdXRwdXQueCA9IHZlY3RvckEueCArIHZlY3RvckIueDtcbiAgICAgICAgb3V0cHV0LnkgPSB2ZWN0b3JBLnkgKyB2ZWN0b3JCLnk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB0aGUgdHdvIHZlY3RvcnMuXG4gICAgICogQG1ldGhvZCBzdWJcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yQVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JCXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtvdXRwdXRdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBBIG5ldyB2ZWN0b3Igb2YgdmVjdG9yQSBhbmQgdmVjdG9yQiBzdWJ0cmFjdGVkXG4gICAgICovXG4gICAgVmVjdG9yLnN1YiA9IGZ1bmN0aW9uKHZlY3RvckEsIHZlY3RvckIsIG91dHB1dCkge1xuICAgICAgICBpZiAoIW91dHB1dCkgb3V0cHV0ID0ge307XG4gICAgICAgIG91dHB1dC54ID0gdmVjdG9yQS54IC0gdmVjdG9yQi54O1xuICAgICAgICBvdXRwdXQueSA9IHZlY3RvckEueSAtIHZlY3RvckIueTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyBhIHZlY3RvciBhbmQgYSBzY2FsYXIuXG4gICAgICogQG1ldGhvZCBtdWx0XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBtdWx0aXBsaWVkIGJ5IHNjYWxhclxuICAgICAqL1xuICAgIFZlY3Rvci5tdWx0ID0gZnVuY3Rpb24odmVjdG9yLCBzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogdmVjdG9yLnggKiBzY2FsYXIsIHk6IHZlY3Rvci55ICogc2NhbGFyIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgYSB2ZWN0b3IgYW5kIGEgc2NhbGFyLlxuICAgICAqIEBtZXRob2QgZGl2XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IEEgbmV3IHZlY3RvciBkaXZpZGVkIGJ5IHNjYWxhclxuICAgICAqL1xuICAgIFZlY3Rvci5kaXYgPSBmdW5jdGlvbih2ZWN0b3IsIHNjYWxhcikge1xuICAgICAgICByZXR1cm4geyB4OiB2ZWN0b3IueCAvIHNjYWxhciwgeTogdmVjdG9yLnkgLyBzY2FsYXIgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVycGVuZGljdWxhciB2ZWN0b3IuIFNldCBgbmVnYXRlYCB0byB0cnVlIGZvciB0aGUgcGVycGVuZGljdWxhciBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICAgICAqIEBtZXRob2QgcGVycFxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtuZWdhdGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgcGVycGVuZGljdWxhciB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IucGVycCA9IGZ1bmN0aW9uKHZlY3RvciwgbmVnYXRlKSB7XG4gICAgICAgIG5lZ2F0ZSA9IG5lZ2F0ZSA9PT0gdHJ1ZSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIHsgeDogbmVnYXRlICogLXZlY3Rvci55LCB5OiBuZWdhdGUgKiB2ZWN0b3IueCB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIGJvdGggY29tcG9uZW50cyBvZiBhIHZlY3RvciBzdWNoIHRoYXQgaXQgcG9pbnRzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogQG1ldGhvZCBuZWdcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgbmVnYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBWZWN0b3IubmVnID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB7IHg6IC12ZWN0b3IueCwgeTogLXZlY3Rvci55IH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHZlY3RvciBgdmVjdG9yQiAtIHZlY3RvckFgIGFuZCB0aGUgeC1heGlzIGluIHJhZGlhbnMuXG4gICAgICogQG1ldGhvZCBhbmdsZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB2ZWN0b3JBXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlY3RvckJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gICAgICovXG4gICAgVmVjdG9yLmFuZ2xlID0gZnVuY3Rpb24odmVjdG9yQSwgdmVjdG9yQikge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih2ZWN0b3JCLnkgLSB2ZWN0b3JBLnksIHZlY3RvckIueCAtIHZlY3RvckEueCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyeSB2ZWN0b3IgcG9vbCAobm90IHRocmVhZC1zYWZlKS5cbiAgICAgKiBAcHJvcGVydHkgX3RlbXBcbiAgICAgKiBAdHlwZSB7dmVjdG9yW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWZWN0b3IuX3RlbXAgPSBbXG4gICAgICAgIFZlY3Rvci5jcmVhdGUoKSwgVmVjdG9yLmNyZWF0ZSgpLCBcbiAgICAgICAgVmVjdG9yLmNyZWF0ZSgpLCBWZWN0b3IuY3JlYXRlKCksIFxuICAgICAgICBWZWN0b3IuY3JlYXRlKCksIFZlY3Rvci5jcmVhdGUoKVxuICAgIF07XG5cbn0pKCk7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuVmVydGljZXNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNldHMgb2YgdmVydGljZXMuXG4qIEEgc2V0IG9mIHZlcnRpY2VzIGlzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCB3aXRoIGFkZGl0aW9uYWwgaW5kZXhpbmcgcHJvcGVydGllcyBpbnNlcnRlZCBieSBgVmVydGljZXMuY3JlYXRlYC5cbiogQSBgTWF0dGVyLkJvZHlgIG1haW50YWlucyBhIHNldCBvZiB2ZXJ0aWNlcyB0byByZXByZXNlbnQgdGhlIHNoYXBlIG9mIHRoZSBvYmplY3QgKGl0cyBjb252ZXggaHVsbCkuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBWZXJ0aWNlc1xuKi9cblxudmFyIFZlcnRpY2VzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGljZXM7XG5cbnZhciBWZWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2V0IG9mIGBNYXR0ZXIuQm9keWAgY29tcGF0aWJsZSB2ZXJ0aWNlcy5cbiAgICAgKiBUaGUgYHBvaW50c2AgYXJndW1lbnQgYWNjZXB0cyBhbiBhcnJheSBvZiBgTWF0dGVyLlZlY3RvcmAgcG9pbnRzIG9yaWVudGF0ZWQgYXJvdW5kIHRoZSBvcmlnaW4gYCgwLCAwKWAsIGZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIFt7IHg6IDAsIHk6IDAgfSwgeyB4OiAyNSwgeTogNTAgfSwgeyB4OiA1MCwgeTogMCB9XVxuICAgICAqXG4gICAgICogVGhlIGBWZXJ0aWNlcy5jcmVhdGVgIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIHZlcnRpY2VzLCB3aGljaCBhcmUgc2ltaWxhciB0byBNYXR0ZXIuVmVjdG9yIG9iamVjdHMsXG4gICAgICogYnV0IHdpdGggc29tZSBhZGRpdGlvbmFsIHJlZmVyZW5jZXMgcmVxdWlyZWQgZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uIHJvdXRpbmVzLlxuICAgICAqXG4gICAgICogVmVydGljZXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gY2xvY2t3aXNlIG9yZGVyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBgYm9keWAgYXJndW1lbnQgaXMgbm90IG9wdGlvbmFsLCBhIGBNYXR0ZXIuQm9keWAgcmVmZXJlbmNlIG11c3QgYmUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7dmVjdG9yW119IHBvaW50c1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqL1xuICAgIFZlcnRpY2VzLmNyZWF0ZSA9IGZ1bmN0aW9uKHBvaW50cywgYm9keSkge1xuICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgICAgIHZlcnRleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9pbnQueSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGlzSW50ZXJuYWw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzdHJpbmcgY29udGFpbmluZyBvcmRlcmVkIHggeSBwYWlycyBzZXBhcmF0ZWQgYnkgc3BhY2VzIChhbmQgb3B0aW9uYWxseSBjb21tYXMpLCBcbiAgICAgKiBpbnRvIGEgYE1hdHRlci5WZXJ0aWNlc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gYE1hdHRlci5Cb2R5YC5cbiAgICAgKiBGb3IgcGFyc2luZyBTVkcgcGF0aHMsIHNlZSBgU3ZnLnBhdGhUb1ZlcnRpY2VzYC5cbiAgICAgKiBAbWV0aG9kIGZyb21QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5mcm9tUGF0aCA9IGZ1bmN0aW9uKHBhdGgsIGJvZHkpIHtcbiAgICAgICAgdmFyIHBhdGhQYXR0ZXJuID0gL0w/XFxzKihbLVxcZC5lXSspW1xccyxdKihbLVxcZC5lXSspKi9pZyxcbiAgICAgICAgICAgIHBvaW50cyA9IFtdO1xuXG4gICAgICAgIHBhdGgucmVwbGFjZShwYXRoUGF0dGVybiwgZnVuY3Rpb24obWF0Y2gsIHgsIHkpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHsgeDogcGFyc2VGbG9hdCh4KSwgeTogcGFyc2VGbG9hdCh5KSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFZlcnRpY2VzLmNyZWF0ZShwb2ludHMsIGJvZHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjZW50cmUgKGNlbnRyb2lkKSBvZiB0aGUgc2V0IG9mIHZlcnRpY2VzLlxuICAgICAqIEBtZXRob2QgY2VudHJlXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IFRoZSBjZW50cmUgcG9pbnRcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5jZW50cmUgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICB2YXIgYXJlYSA9IFZlcnRpY2VzLmFyZWEodmVydGljZXMsIHRydWUpLFxuICAgICAgICAgICAgY2VudHJlID0geyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBjcm9zcyxcbiAgICAgICAgICAgIHRlbXAsXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGogPSAoaSArIDEpICUgdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgY3Jvc3MgPSBWZWN0b3IuY3Jvc3ModmVydGljZXNbaV0sIHZlcnRpY2VzW2pdKTtcbiAgICAgICAgICAgIHRlbXAgPSBWZWN0b3IubXVsdChWZWN0b3IuYWRkKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tqXSksIGNyb3NzKTtcbiAgICAgICAgICAgIGNlbnRyZSA9IFZlY3Rvci5hZGQoY2VudHJlLCB0ZW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBWZWN0b3IuZGl2KGNlbnRyZSwgNiAqIGFyZWEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIChtZWFuKSBvZiB0aGUgc2V0IG9mIHZlcnRpY2VzLlxuICAgICAqIEBtZXRob2QgbWVhblxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7dmVjdG9yfSBUaGUgYXZlcmFnZSBwb2ludFxuICAgICAqL1xuICAgIFZlcnRpY2VzLm1lYW4gPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICB2YXIgYXZlcmFnZSA9IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGF2ZXJhZ2UueCArPSB2ZXJ0aWNlc1tpXS54O1xuICAgICAgICAgICAgYXZlcmFnZS55ICs9IHZlcnRpY2VzW2ldLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVmVjdG9yLmRpdihhdmVyYWdlLCB2ZXJ0aWNlcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcmVhIG9mIHRoZSBzZXQgb2YgdmVydGljZXMuXG4gICAgICogQG1ldGhvZCBhcmVhXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IHNpZ25lZFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFyZWFcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5hcmVhID0gZnVuY3Rpb24odmVydGljZXMsIHNpZ25lZCkge1xuICAgICAgICB2YXIgYXJlYSA9IDAsXG4gICAgICAgICAgICBqID0gdmVydGljZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhICs9ICh2ZXJ0aWNlc1tqXS54IC0gdmVydGljZXNbaV0ueCkgKiAodmVydGljZXNbal0ueSArIHZlcnRpY2VzW2ldLnkpO1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGFyZWEgLyAyO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhcmVhKSAvIDI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vbWVudCBvZiBpbmVydGlhIChzZWNvbmQgbW9tZW50IG9mIGFyZWEpIG9mIHRoZSBzZXQgb2YgdmVydGljZXMgZ2l2ZW4gdGhlIHRvdGFsIG1hc3MuXG4gICAgICogQG1ldGhvZCBpbmVydGlhXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFzc1xuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvbHlnb24ncyBtb21lbnQgb2YgaW5lcnRpYVxuICAgICAqL1xuICAgIFZlcnRpY2VzLmluZXJ0aWEgPSBmdW5jdGlvbih2ZXJ0aWNlcywgbWFzcykge1xuICAgICAgICB2YXIgbnVtZXJhdG9yID0gMCxcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gMCxcbiAgICAgICAgICAgIHYgPSB2ZXJ0aWNlcyxcbiAgICAgICAgICAgIGNyb3NzLFxuICAgICAgICAgICAgajtcblxuICAgICAgICAvLyBmaW5kIHRoZSBwb2x5Z29uJ3MgbW9tZW50IG9mIGluZXJ0aWEsIHVzaW5nIHNlY29uZCBtb21lbnQgb2YgYXJlYVxuICAgICAgICAvLyBmcm9tIGVxdWF0aW9ucyBhdCBodHRwOi8vd3d3LnBoeXNpY3Nmb3J1bXMuY29tL3Nob3d0aHJlYWQucGhwP3Q9MjUyOTNcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB2Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBqID0gKG4gKyAxKSAlIHYubGVuZ3RoO1xuICAgICAgICAgICAgY3Jvc3MgPSBNYXRoLmFicyhWZWN0b3IuY3Jvc3ModltqXSwgdltuXSkpO1xuICAgICAgICAgICAgbnVtZXJhdG9yICs9IGNyb3NzICogKFZlY3Rvci5kb3QodltqXSwgdltqXSkgKyBWZWN0b3IuZG90KHZbal0sIHZbbl0pICsgVmVjdG9yLmRvdCh2W25dLCB2W25dKSk7XG4gICAgICAgICAgICBkZW5vbWluYXRvciArPSBjcm9zcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobWFzcyAvIDYpICogKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgc2V0IG9mIHZlcnRpY2VzIGluLXBsYWNlLlxuICAgICAqIEBtZXRob2QgdHJhbnNsYXRlXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdmVjdG9yXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhclxuICAgICAqL1xuICAgIFZlcnRpY2VzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCB2ZWN0b3IsIHNjYWxhcikge1xuICAgICAgICBzY2FsYXIgPSB0eXBlb2Ygc2NhbGFyICE9PSAndW5kZWZpbmVkJyA/IHNjYWxhciA6IDE7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzTGVuZ3RoID0gdmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IHZlY3Rvci54ICogc2NhbGFyLFxuICAgICAgICAgICAgdHJhbnNsYXRlWSA9IHZlY3Rvci55ICogc2NhbGFyLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpXS54ICs9IHRyYW5zbGF0ZVg7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpXS55ICs9IHRyYW5zbGF0ZVk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIHNldCBvZiB2ZXJ0aWNlcyBpbi1wbGFjZS5cbiAgICAgKiBAbWV0aG9kIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICovXG4gICAgVmVydGljZXMucm90YXRlID0gZnVuY3Rpb24odmVydGljZXMsIGFuZ2xlLCBwb2ludCkge1xuICAgICAgICBpZiAoYW5nbGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHBvaW50WCA9IHBvaW50LngsXG4gICAgICAgICAgICBwb2ludFkgPSBwb2ludC55LFxuICAgICAgICAgICAgdmVydGljZXNMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgICAgICBkeCxcbiAgICAgICAgICAgIGR5LFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICBkeCA9IHZlcnRleC54IC0gcG9pbnRYO1xuICAgICAgICAgICAgZHkgPSB2ZXJ0ZXgueSAtIHBvaW50WTtcbiAgICAgICAgICAgIHZlcnRleC54ID0gcG9pbnRYICsgKGR4ICogY29zIC0gZHkgKiBzaW4pO1xuICAgICAgICAgICAgdmVydGV4LnkgPSBwb2ludFkgKyAoZHggKiBzaW4gKyBkeSAqIGNvcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBgcG9pbnRgIGlzIGluc2lkZSB0aGUgc2V0IG9mIGB2ZXJ0aWNlc2AuXG4gICAgICogQG1ldGhvZCBjb250YWluc1xuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVydGljZXMgY29udGFpbnMgcG9pbnQsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIFZlcnRpY2VzLmNvbnRhaW5zID0gZnVuY3Rpb24odmVydGljZXMsIHBvaW50KSB7XG4gICAgICAgIHZhciBwb2ludFggPSBwb2ludC54LFxuICAgICAgICAgICAgcG9pbnRZID0gcG9pbnQueSxcbiAgICAgICAgICAgIHZlcnRpY2VzTGVuZ3RoID0gdmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbdmVydGljZXNMZW5ndGggLSAxXSxcbiAgICAgICAgICAgIG5leHRWZXJ0ZXg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXh0VmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgICAgIGlmICgocG9pbnRYIC0gdmVydGV4LngpICogKG5leHRWZXJ0ZXgueSAtIHZlcnRleC55KSBcbiAgICAgICAgICAgICAgICArIChwb2ludFkgLSB2ZXJ0ZXgueSkgKiAodmVydGV4LnggLSBuZXh0VmVydGV4LngpID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVydGV4ID0gbmV4dFZlcnRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIHZlcnRpY2VzIGZyb20gYSBwb2ludCAoZGVmYXVsdCBpcyBjZW50cmUpIGluLXBsYWNlLlxuICAgICAqIEBtZXRob2Qgc2NhbGVcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICovXG4gICAgVmVydGljZXMuc2NhbGUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgc2NhbGVYLCBzY2FsZVksIHBvaW50KSB7XG4gICAgICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuXG4gICAgICAgIHBvaW50ID0gcG9pbnQgfHwgVmVydGljZXMuY2VudHJlKHZlcnRpY2VzKTtcblxuICAgICAgICB2YXIgdmVydGV4LFxuICAgICAgICAgICAgZGVsdGE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICBkZWx0YSA9IFZlY3Rvci5zdWIodmVydGV4LCBwb2ludCk7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpXS54ID0gcG9pbnQueCArIGRlbHRhLnggKiBzY2FsZVg7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpXS55ID0gcG9pbnQueSArIGRlbHRhLnkgKiBzY2FsZVk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW1mZXJzIGEgc2V0IG9mIHZlcnRpY2VzIGJ5IGdpdmluZyB0aGVtIHJvdW5kZWQgY29ybmVycywgcmV0dXJucyBhIG5ldyBzZXQgb2YgdmVydGljZXMuXG4gICAgICogVGhlIHJhZGl1cyBwYXJhbWV0ZXIgaXMgYSBzaW5nbGUgbnVtYmVyIG9yIGFuIGFycmF5IHRvIHNwZWNpZnkgdGhlIHJhZGl1cyBmb3IgZWFjaCB2ZXJ0ZXguXG4gICAgICogQG1ldGhvZCBjaGFtZmVyXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5TWluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlNYXhcbiAgICAgKi9cbiAgICBWZXJ0aWNlcy5jaGFtZmVyID0gZnVuY3Rpb24odmVydGljZXMsIHJhZGl1cywgcXVhbGl0eSwgcXVhbGl0eU1pbiwgcXVhbGl0eU1heCkge1xuICAgICAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IFtyYWRpdXNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IFs4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHF1YWxpdHkgZGVmYXVsdHMgdG8gLTEsIHdoaWNoIGlzIGF1dG9cbiAgICAgICAgcXVhbGl0eSA9ICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpID8gcXVhbGl0eSA6IC0xO1xuICAgICAgICBxdWFsaXR5TWluID0gcXVhbGl0eU1pbiB8fCAyO1xuICAgICAgICBxdWFsaXR5TWF4ID0gcXVhbGl0eU1heCB8fCAxNDtcblxuICAgICAgICB2YXIgbmV3VmVydGljZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJldlZlcnRleCA9IHZlcnRpY2VzW2kgLSAxID49IDAgPyBpIC0gMSA6IHZlcnRpY2VzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldLFxuICAgICAgICAgICAgICAgIG5leHRWZXJ0ZXggPSB2ZXJ0aWNlc1soaSArIDEpICUgdmVydGljZXMubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UmFkaXVzID0gcmFkaXVzW2kgPCByYWRpdXMubGVuZ3RoID8gaSA6IHJhZGl1cy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSYWRpdXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdWZXJ0aWNlcy5wdXNoKHZlcnRleCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwcmV2Tm9ybWFsID0gVmVjdG9yLm5vcm1hbGlzZSh7IFxuICAgICAgICAgICAgICAgIHg6IHZlcnRleC55IC0gcHJldlZlcnRleC55LCBcbiAgICAgICAgICAgICAgICB5OiBwcmV2VmVydGV4LnggLSB2ZXJ0ZXgueFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBuZXh0Tm9ybWFsID0gVmVjdG9yLm5vcm1hbGlzZSh7IFxuICAgICAgICAgICAgICAgIHg6IG5leHRWZXJ0ZXgueSAtIHZlcnRleC55LCBcbiAgICAgICAgICAgICAgICB5OiB2ZXJ0ZXgueCAtIG5leHRWZXJ0ZXgueFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBkaWFnb25hbFJhZGl1cyA9IE1hdGguc3FydCgyICogTWF0aC5wb3coY3VycmVudFJhZGl1cywgMikpLFxuICAgICAgICAgICAgICAgIHJhZGl1c1ZlY3RvciA9IFZlY3Rvci5tdWx0KENvbW1vbi5jbG9uZShwcmV2Tm9ybWFsKSwgY3VycmVudFJhZGl1cyksXG4gICAgICAgICAgICAgICAgbWlkTm9ybWFsID0gVmVjdG9yLm5vcm1hbGlzZShWZWN0b3IubXVsdChWZWN0b3IuYWRkKHByZXZOb3JtYWwsIG5leHROb3JtYWwpLCAwLjUpKSxcbiAgICAgICAgICAgICAgICBzY2FsZWRWZXJ0ZXggPSBWZWN0b3Iuc3ViKHZlcnRleCwgVmVjdG9yLm11bHQobWlkTm9ybWFsLCBkaWFnb25hbFJhZGl1cykpO1xuXG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gcXVhbGl0eTtcblxuICAgICAgICAgICAgaWYgKHF1YWxpdHkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZWNpZGUgcHJlY2lzaW9uXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5wb3coY3VycmVudFJhZGl1cywgMC4zMikgKiAxLjc1O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVjaXNpb24gPSBDb21tb24uY2xhbXAocHJlY2lzaW9uLCBxdWFsaXR5TWluLCBxdWFsaXR5TWF4KTtcblxuICAgICAgICAgICAgLy8gdXNlIGFuIGV2ZW4gdmFsdWUgZm9yIHByZWNpc2lvbiwgbW9yZSBsaWtlbHkgdG8gcmVkdWNlIGF4ZXMgYnkgdXNpbmcgc3ltbWV0cnlcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gJSAyID09PSAxKVxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiArPSAxO1xuXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLmFjb3MoVmVjdG9yLmRvdChwcmV2Tm9ybWFsLCBuZXh0Tm9ybWFsKSksXG4gICAgICAgICAgICAgICAgdGhldGEgPSBhbHBoYSAvIHByZWNpc2lvbjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcmVjaXNpb247IGorKykge1xuICAgICAgICAgICAgICAgIG5ld1ZlcnRpY2VzLnB1c2goVmVjdG9yLmFkZChWZWN0b3Iucm90YXRlKHJhZGl1c1ZlY3RvciwgdGhldGEgKiBqKSwgc2NhbGVkVmVydGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VmVydGljZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBpbnB1dCB2ZXJ0aWNlcyBpbnRvIGNsb2Nrd2lzZSBvcmRlciBpbiBwbGFjZS5cbiAgICAgKiBAbWV0aG9kIGNsb2Nrd2lzZVNvcnRcbiAgICAgKiBAcGFyYW0ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqIEByZXR1cm4ge3ZlcnRpY2VzfSB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIFZlcnRpY2VzLmNsb2Nrd2lzZVNvcnQgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICB2YXIgY2VudHJlID0gVmVydGljZXMubWVhbih2ZXJ0aWNlcyk7XG5cbiAgICAgICAgdmVydGljZXMuc29ydChmdW5jdGlvbih2ZXJ0ZXhBLCB2ZXJ0ZXhCKSB7XG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLmFuZ2xlKGNlbnRyZSwgdmVydGV4QSkgLSBWZWN0b3IuYW5nbGUoY2VudHJlLCB2ZXJ0ZXhCKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZlcnRpY2VzIGZvcm0gYSBjb252ZXggc2hhcGUgKHZlcnRpY2VzIG11c3QgYmUgaW4gY2xvY2t3aXNlIG9yZGVyKS5cbiAgICAgKiBAbWV0aG9kIGlzQ29udmV4XG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcmV0dXJuIHtib29sfSBgdHJ1ZWAgaWYgdGhlIGB2ZXJ0aWNlc2AgYXJlIGNvbnZleCwgYGZhbHNlYCBpZiBub3QgKG9yIGBudWxsYCBpZiBub3QgY29tcHV0YWJsZSkuXG4gICAgICovXG4gICAgVmVydGljZXMuaXNDb252ZXggPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICAvLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZ2VvbWV0cnkvcG9seWdvbm1lc2gvXG4gICAgICAgIC8vIENvcHlyaWdodCAoYykgUGF1bCBCb3Vya2UgKHVzZSBwZXJtaXR0ZWQpXG5cbiAgICAgICAgdmFyIGZsYWcgPSAwLFxuICAgICAgICAgICAgbiA9IHZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIHo7XG5cbiAgICAgICAgaWYgKG4gPCAzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaiA9IChpICsgMSkgJSBuO1xuICAgICAgICAgICAgayA9IChpICsgMikgJSBuO1xuICAgICAgICAgICAgeiA9ICh2ZXJ0aWNlc1tqXS54IC0gdmVydGljZXNbaV0ueCkgKiAodmVydGljZXNba10ueSAtIHZlcnRpY2VzW2pdLnkpO1xuICAgICAgICAgICAgeiAtPSAodmVydGljZXNbal0ueSAtIHZlcnRpY2VzW2ldLnkpICogKHZlcnRpY2VzW2tdLnggLSB2ZXJ0aWNlc1tqXS54KTtcblxuICAgICAgICAgICAgaWYgKHogPCAwKSB7XG4gICAgICAgICAgICAgICAgZmxhZyB8PSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh6ID4gMCkge1xuICAgICAgICAgICAgICAgIGZsYWcgfD0gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZsYWcgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZyAhPT0gMCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnZleCBodWxsIG9mIHRoZSBpbnB1dCB2ZXJ0aWNlcyBhcyBhIG5ldyBhcnJheSBvZiBwb2ludHMuXG4gICAgICogQG1ldGhvZCBodWxsXG4gICAgICogQHBhcmFtIHt2ZXJ0aWNlc30gdmVydGljZXNcbiAgICAgKiBAcmV0dXJuIFt2ZXJ0ZXhdIHZlcnRpY2VzXG4gICAgICovXG4gICAgVmVydGljZXMuaHVsbCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTEwLV9odWxsLTEuaHRtbFxuXG4gICAgICAgIHZhciB1cHBlciA9IFtdLFxuICAgICAgICAgICAgbG93ZXIgPSBbXSwgXG4gICAgICAgICAgICB2ZXJ0ZXgsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIHNvcnQgdmVydGljZXMgb24geC1heGlzICh5LWF4aXMgZm9yIHRpZXMpXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuc2xpY2UoMCk7XG4gICAgICAgIHZlcnRpY2VzLnNvcnQoZnVuY3Rpb24odmVydGV4QSwgdmVydGV4Qikge1xuICAgICAgICAgICAgdmFyIGR4ID0gdmVydGV4QS54IC0gdmVydGV4Qi54O1xuICAgICAgICAgICAgcmV0dXJuIGR4ICE9PSAwID8gZHggOiB2ZXJ0ZXhBLnkgLSB2ZXJ0ZXhCLnk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGJ1aWxkIGxvd2VyIGh1bGxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgICAgd2hpbGUgKGxvd2VyLmxlbmd0aCA+PSAyIFxuICAgICAgICAgICAgICAgICAgICYmIFZlY3Rvci5jcm9zczMobG93ZXJbbG93ZXIubGVuZ3RoIC0gMl0sIGxvd2VyW2xvd2VyLmxlbmd0aCAtIDFdLCB2ZXJ0ZXgpIDw9IDApIHtcbiAgICAgICAgICAgICAgICBsb3dlci5wb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG93ZXIucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnVpbGQgdXBwZXIgaHVsbFxuICAgICAgICBmb3IgKGkgPSB2ZXJ0aWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgICAgIHdoaWxlICh1cHBlci5sZW5ndGggPj0gMiBcbiAgICAgICAgICAgICAgICAgICAmJiBWZWN0b3IuY3Jvc3MzKHVwcGVyW3VwcGVyLmxlbmd0aCAtIDJdLCB1cHBlclt1cHBlci5sZW5ndGggLSAxXSwgdmVydGV4KSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdXBwZXIucG9wKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwcGVyLnB1c2godmVydGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbmNhdGVuYXRpb24gb2YgdGhlIGxvd2VyIGFuZCB1cHBlciBodWxscyBnaXZlcyB0aGUgY29udmV4IGh1bGxcbiAgICAgICAgLy8gb21pdCBsYXN0IHBvaW50cyBiZWNhdXNlIHRoZXkgYXJlIHJlcGVhdGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG90aGVyIGxpc3RcbiAgICAgICAgdXBwZXIucG9wKCk7XG4gICAgICAgIGxvd2VyLnBvcCgpO1xuXG4gICAgICAgIHJldHVybiB1cHBlci5jb25jYXQobG93ZXIpO1xuICAgIH07XG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyByaWdpZCBib2RpZXMuXG4qIEZvciBjcmVhdGluZyBib2RpZXMgd2l0aCBjb21tb24gY29uZmlndXJhdGlvbnMgc3VjaCBhcyByZWN0YW5nbGVzLCBjaXJjbGVzIGFuZCBvdGhlciBwb2x5Z29ucyBzZWUgdGhlIG1vZHVsZSBgTWF0dGVyLkJvZGllc2AuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG5cbiogQGNsYXNzIEJvZHlcbiovXG5cbnZhciBCb2R5ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQm9keTtcblxudmFyIFZlcnRpY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBWZWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIFNsZWVwaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIEJvdW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQXhlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBCb2R5Ll90aW1lQ29ycmVjdGlvbiA9IHRydWU7XG4gICAgQm9keS5faW5lcnRpYVNjYWxlID0gNDtcbiAgICBCb2R5Ll9uZXh0Q29sbGlkaW5nR3JvdXBJZCA9IDE7XG4gICAgQm9keS5fbmV4dE5vbkNvbGxpZGluZ0dyb3VwSWQgPSAtMTtcbiAgICBCb2R5Ll9uZXh0Q2F0ZWdvcnkgPSAweDAwMDE7XG4gICAgQm9keS5fYmFzZURlbHRhID0gMTAwMCAvIDYwO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIFZlcnRpY2VzIG11c3QgYmUgc3BlY2lmaWVkIGluIGNsb2Nrd2lzZSBvcmRlci5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtib2R5fSBib2R5XG4gICAgICovXG4gICAgQm9keS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGlkOiBDb21tb24ubmV4dElkKCksXG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBsYWJlbDogJ0JvZHknLFxuICAgICAgICAgICAgcGFydHM6IFtdLFxuICAgICAgICAgICAgcGx1Z2luOiB7fSxcbiAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKCdMIDAgMCBMIDQwIDAgTCA0MCA0MCBMIDAgNDAnKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGZvcmNlOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIHRvcnF1ZTogMCxcbiAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZTogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICBjb25zdHJhaW50SW1wdWxzZTogeyB4OiAwLCB5OiAwLCBhbmdsZTogMCB9LFxuICAgICAgICAgICAgdG90YWxDb250YWN0czogMCxcbiAgICAgICAgICAgIHNwZWVkOiAwLFxuICAgICAgICAgICAgYW5ndWxhclNwZWVkOiAwLFxuICAgICAgICAgICAgdmVsb2NpdHk6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgYW5ndWxhclZlbG9jaXR5OiAwLFxuICAgICAgICAgICAgaXNTZW5zb3I6IGZhbHNlLFxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxuICAgICAgICAgICAgaXNTbGVlcGluZzogZmFsc2UsXG4gICAgICAgICAgICBtb3Rpb246IDAsXG4gICAgICAgICAgICBzbGVlcFRocmVzaG9sZDogNjAsXG4gICAgICAgICAgICBkZW5zaXR5OiAwLjAwMSxcbiAgICAgICAgICAgIHJlc3RpdHV0aW9uOiAwLFxuICAgICAgICAgICAgZnJpY3Rpb246IDAuMSxcbiAgICAgICAgICAgIGZyaWN0aW9uU3RhdGljOiAwLjUsXG4gICAgICAgICAgICBmcmljdGlvbkFpcjogMC4wMSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAweDAwMDEsXG4gICAgICAgICAgICAgICAgbWFzazogMHhGRkZGRkZGRixcbiAgICAgICAgICAgICAgICBncm91cDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3A6IDAuMDUsXG4gICAgICAgICAgICB0aW1lU2NhbGU6IDEsXG4gICAgICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogbnVsbCxcbiAgICAgICAgICAgICAgICBzcHJpdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgICAgIHhPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHlPZmZzZXQ6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXZlbnRzOiBudWxsLFxuICAgICAgICAgICAgYm91bmRzOiBudWxsLFxuICAgICAgICAgICAgY2hhbWZlcjogbnVsbCxcbiAgICAgICAgICAgIGNpcmNsZVJhZGl1czogMCxcbiAgICAgICAgICAgIHBvc2l0aW9uUHJldjogbnVsbCxcbiAgICAgICAgICAgIGFuZ2xlUHJldjogMCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGF4ZXM6IG51bGwsXG4gICAgICAgICAgICBhcmVhOiAwLFxuICAgICAgICAgICAgbWFzczogMCxcbiAgICAgICAgICAgIGluZXJ0aWE6IDAsXG4gICAgICAgICAgICBkZWx0YVRpbWU6IDEwMDAgLyA2MCxcbiAgICAgICAgICAgIF9vcmlnaW5hbDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBib2R5ID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgX2luaXRQcm9wZXJ0aWVzKGJvZHksIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBncm91cCBpbmRleCBmb3Igd2hpY2ggYm9kaWVzIHdpbGwgY29sbGlkZS5cbiAgICAgKiBJZiBgaXNOb25Db2xsaWRpbmdgIGlzIGB0cnVlYCwgcmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgZ3JvdXAgaW5kZXggZm9yIHdoaWNoIGJvZGllcyB3aWxsIF9ub3RfIGNvbGxpZGUuXG4gICAgICogU2VlIGBib2R5LmNvbGxpc2lvbkZpbHRlcmAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQG1ldGhvZCBuZXh0R3JvdXBcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtpc05vbkNvbGxpZGluZz1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFVuaXF1ZSBncm91cCBpbmRleFxuICAgICAqL1xuICAgIEJvZHkubmV4dEdyb3VwID0gZnVuY3Rpb24oaXNOb25Db2xsaWRpbmcpIHtcbiAgICAgICAgaWYgKGlzTm9uQ29sbGlkaW5nKVxuICAgICAgICAgICAgcmV0dXJuIEJvZHkuX25leHROb25Db2xsaWRpbmdHcm91cElkLS07XG5cbiAgICAgICAgcmV0dXJuIEJvZHkuX25leHRDb2xsaWRpbmdHcm91cElkKys7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5leHQgdW5pcXVlIGNhdGVnb3J5IGJpdGZpZWxkIChzdGFydGluZyBhZnRlciB0aGUgaW5pdGlhbCBkZWZhdWx0IGNhdGVnb3J5IGAweDAwMDFgKS5cbiAgICAgKiBUaGVyZSBhcmUgMzIgYXZhaWxhYmxlLiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAbWV0aG9kIG5leHRDYXRlZ29yeVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVW5pcXVlIGNhdGVnb3J5IGJpdGZpZWxkXG4gICAgICovXG4gICAgQm9keS5uZXh0Q2F0ZWdvcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgQm9keS5fbmV4dENhdGVnb3J5ID0gQm9keS5fbmV4dENhdGVnb3J5IDw8IDE7XG4gICAgICAgIHJldHVybiBCb2R5Ll9uZXh0Q2F0ZWdvcnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2VzIGJvZHkgcHJvcGVydGllcy5cbiAgICAgKiBAbWV0aG9kIF9pbml0UHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIHZhciBfaW5pdFByb3BlcnRpZXMgPSBmdW5jdGlvbihib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIGluaXQgcmVxdWlyZWQgcHJvcGVydGllcyAob3JkZXIgaXMgaW1wb3J0YW50KVxuICAgICAgICBCb2R5LnNldChib2R5LCB7XG4gICAgICAgICAgICBib3VuZHM6IGJvZHkuYm91bmRzIHx8IEJvdW5kcy5jcmVhdGUoYm9keS52ZXJ0aWNlcyksXG4gICAgICAgICAgICBwb3NpdGlvblByZXY6IGJvZHkucG9zaXRpb25QcmV2IHx8IFZlY3Rvci5jbG9uZShib2R5LnBvc2l0aW9uKSxcbiAgICAgICAgICAgIGFuZ2xlUHJldjogYm9keS5hbmdsZVByZXYgfHwgYm9keS5hbmdsZSxcbiAgICAgICAgICAgIHZlcnRpY2VzOiBib2R5LnZlcnRpY2VzLFxuICAgICAgICAgICAgcGFydHM6IGJvZHkucGFydHMgfHwgW2JvZHldLFxuICAgICAgICAgICAgaXNTdGF0aWM6IGJvZHkuaXNTdGF0aWMsXG4gICAgICAgICAgICBpc1NsZWVwaW5nOiBib2R5LmlzU2xlZXBpbmcsXG4gICAgICAgICAgICBwYXJlbnQ6IGJvZHkucGFyZW50IHx8IGJvZHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgVmVydGljZXMucm90YXRlKGJvZHkudmVydGljZXMsIGJvZHkuYW5nbGUsIGJvZHkucG9zaXRpb24pO1xuICAgICAgICBBeGVzLnJvdGF0ZShib2R5LmF4ZXMsIGJvZHkuYW5nbGUpO1xuICAgICAgICBCb3VuZHMudXBkYXRlKGJvZHkuYm91bmRzLCBib2R5LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcblxuICAgICAgICAvLyBhbGxvdyBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgcHJvcGVydGllc1xuICAgICAgICBCb2R5LnNldChib2R5LCB7XG4gICAgICAgICAgICBheGVzOiBvcHRpb25zLmF4ZXMgfHwgYm9keS5heGVzLFxuICAgICAgICAgICAgYXJlYTogb3B0aW9ucy5hcmVhIHx8IGJvZHkuYXJlYSxcbiAgICAgICAgICAgIG1hc3M6IG9wdGlvbnMubWFzcyB8fCBib2R5Lm1hc3MsXG4gICAgICAgICAgICBpbmVydGlhOiBvcHRpb25zLmluZXJ0aWEgfHwgYm9keS5pbmVydGlhXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbmRlciBwcm9wZXJ0aWVzXG4gICAgICAgIHZhciBkZWZhdWx0RmlsbFN0eWxlID0gKGJvZHkuaXNTdGF0aWMgPyAnIzE0MTUxZicgOiBDb21tb24uY2hvb3NlKFsnI2YxOTY0OCcsICcjZjVkMjU5JywgJyNmNTVhM2MnLCAnIzA2M2U3YicsICcjZWNlY2QxJ10pKSxcbiAgICAgICAgICAgIGRlZmF1bHRTdHJva2VTdHlsZSA9IGJvZHkuaXNTdGF0aWMgPyAnIzU1NScgOiAnI2NjYycsXG4gICAgICAgICAgICBkZWZhdWx0TGluZVdpZHRoID0gYm9keS5pc1N0YXRpYyAmJiBib2R5LnJlbmRlci5maWxsU3R5bGUgPT09IG51bGwgPyAxIDogMDtcbiAgICAgICAgYm9keS5yZW5kZXIuZmlsbFN0eWxlID0gYm9keS5yZW5kZXIuZmlsbFN0eWxlIHx8IGRlZmF1bHRGaWxsU3R5bGU7XG4gICAgICAgIGJvZHkucmVuZGVyLnN0cm9rZVN0eWxlID0gYm9keS5yZW5kZXIuc3Ryb2tlU3R5bGUgfHwgZGVmYXVsdFN0cm9rZVN0eWxlO1xuICAgICAgICBib2R5LnJlbmRlci5saW5lV2lkdGggPSBib2R5LnJlbmRlci5saW5lV2lkdGggfHwgZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgICAgYm9keS5yZW5kZXIuc3ByaXRlLnhPZmZzZXQgKz0gLShib2R5LmJvdW5kcy5taW4ueCAtIGJvZHkucG9zaXRpb24ueCkgLyAoYm9keS5ib3VuZHMubWF4LnggLSBib2R5LmJvdW5kcy5taW4ueCk7XG4gICAgICAgIGJvZHkucmVuZGVyLnNwcml0ZS55T2Zmc2V0ICs9IC0oYm9keS5ib3VuZHMubWluLnkgLSBib2R5LnBvc2l0aW9uLnkpIC8gKGJvZHkuYm91bmRzLm1heC55IC0gYm9keS5ib3VuZHMubWluLnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHByb3BlcnR5IGFuZCBhIHZhbHVlIChvciBtYXAgb2YpLCBzZXRzIHRoZSBwcm9wZXJ0eShzKSBvbiB0aGUgYm9keSwgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIHNldHRlciBmdW5jdGlvbnMgaWYgdGhleSBleGlzdC5cbiAgICAgKiBQcmVmZXIgdG8gdXNlIHRoZSBhY3R1YWwgc2V0dGVyIGZ1bmN0aW9ucyBpbiBwZXJmb3JtYW5jZSBjcml0aWNhbCBzaXR1YXRpb25zLlxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt9IHNldHRpbmdzIEEgcHJvcGVydHkgbmFtZSAob3IgbWFwIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcykgdG8gc2V0IG9uIHRoZSBib2R5LlxuICAgICAqIEBwYXJhbSB7fSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGlmIGBzZXR0aW5nc2AgaXMgYSBzaW5nbGUgcHJvcGVydHkgbmFtZS5cbiAgICAgKi9cbiAgICBCb2R5LnNldCA9IGZ1bmN0aW9uKGJvZHksIHNldHRpbmdzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcHJvcGVydHk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gc2V0dGluZ3M7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHt9O1xuICAgICAgICAgICAgc2V0dGluZ3NbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR0aW5ncywgcHJvcGVydHkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcblxuICAgICAgICAgICAgY2FzZSAnaXNTdGF0aWMnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0U3RhdGljKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzU2xlZXBpbmcnOlxuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXNzJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVuc2l0eSc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXREZW5zaXR5KGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luZXJ0aWEnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0SW5lcnRpYShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2ZXJ0aWNlcyc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRWZXJ0aWNlcyhib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmdsZSc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRBbmdsZShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2ZWxvY2l0eSc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRWZWxvY2l0eShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmd1bGFyVmVsb2NpdHknOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0QW5ndWxhclZlbG9jaXR5KGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NwZWVkJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldFNwZWVkKGJvZHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FuZ3VsYXJTcGVlZCc6XG4gICAgICAgICAgICAgICAgQm9keS5zZXRBbmd1bGFyU3BlZWQoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGFydHMnOlxuICAgICAgICAgICAgICAgIEJvZHkuc2V0UGFydHMoYm9keSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudHJlJzpcbiAgICAgICAgICAgICAgICBCb2R5LnNldENlbnRyZShib2R5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJvZHlbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib2R5IGFzIHN0YXRpYywgaW5jbHVkaW5nIGlzU3RhdGljIGZsYWcgYW5kIHNldHRpbmcgbWFzcyBhbmQgaW5lcnRpYSB0byBJbmZpbml0eS5cbiAgICAgKiBAbWV0aG9kIHNldFN0YXRpY1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7Ym9vbH0gaXNTdGF0aWNcbiAgICAgKi9cbiAgICBCb2R5LnNldFN0YXRpYyA9IGZ1bmN0aW9uKGJvZHksIGlzU3RhdGljKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xuICAgICAgICAgICAgcGFydC5pc1N0YXRpYyA9IGlzU3RhdGljO1xuXG4gICAgICAgICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBwYXJ0Ll9vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGl0dXRpb246IHBhcnQucmVzdGl0dXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uOiBwYXJ0LmZyaWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBtYXNzOiBwYXJ0Lm1hc3MsXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWE6IHBhcnQuaW5lcnRpYSxcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eTogcGFydC5kZW5zaXR5LFxuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlTWFzczogcGFydC5pbnZlcnNlTWFzcyxcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUluZXJ0aWE6IHBhcnQuaW52ZXJzZUluZXJ0aWFcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcGFydC5yZXN0aXR1dGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5mcmljdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgcGFydC5tYXNzID0gcGFydC5pbmVydGlhID0gcGFydC5kZW5zaXR5ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgcGFydC5pbnZlcnNlTWFzcyA9IHBhcnQuaW52ZXJzZUluZXJ0aWEgPSAwO1xuXG4gICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvblByZXYueCA9IHBhcnQucG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uUHJldi55ID0gcGFydC5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIHBhcnQuYW5nbGVQcmV2ID0gcGFydC5hbmdsZTtcbiAgICAgICAgICAgICAgICBwYXJ0LmFuZ3VsYXJWZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5zcGVlZCA9IDA7XG4gICAgICAgICAgICAgICAgcGFydC5hbmd1bGFyU3BlZWQgPSAwO1xuICAgICAgICAgICAgICAgIHBhcnQubW90aW9uID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydC5fb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnJlc3RpdHV0aW9uID0gcGFydC5fb3JpZ2luYWwucmVzdGl0dXRpb247XG4gICAgICAgICAgICAgICAgcGFydC5mcmljdGlvbiA9IHBhcnQuX29yaWdpbmFsLmZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIHBhcnQubWFzcyA9IHBhcnQuX29yaWdpbmFsLm1hc3M7XG4gICAgICAgICAgICAgICAgcGFydC5pbmVydGlhID0gcGFydC5fb3JpZ2luYWwuaW5lcnRpYTtcbiAgICAgICAgICAgICAgICBwYXJ0LmRlbnNpdHkgPSBwYXJ0Ll9vcmlnaW5hbC5kZW5zaXR5O1xuICAgICAgICAgICAgICAgIHBhcnQuaW52ZXJzZU1hc3MgPSBwYXJ0Ll9vcmlnaW5hbC5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICBwYXJ0LmludmVyc2VJbmVydGlhID0gcGFydC5fb3JpZ2luYWwuaW52ZXJzZUluZXJ0aWE7XG5cbiAgICAgICAgICAgICAgICBwYXJ0Ll9vcmlnaW5hbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFzcyBvZiB0aGUgYm9keS4gSW52ZXJzZSBtYXNzLCBkZW5zaXR5IGFuZCBpbmVydGlhIGFyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLlxuICAgICAqIEBtZXRob2Qgc2V0TWFzc1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzXG4gICAgICovXG4gICAgQm9keS5zZXRNYXNzID0gZnVuY3Rpb24oYm9keSwgbWFzcykge1xuICAgICAgICB2YXIgbW9tZW50ID0gYm9keS5pbmVydGlhIC8gKGJvZHkubWFzcyAvIDYpO1xuICAgICAgICBib2R5LmluZXJ0aWEgPSBtb21lbnQgKiAobWFzcyAvIDYpO1xuICAgICAgICBib2R5LmludmVyc2VJbmVydGlhID0gMSAvIGJvZHkuaW5lcnRpYTtcblxuICAgICAgICBib2R5Lm1hc3MgPSBtYXNzO1xuICAgICAgICBib2R5LmludmVyc2VNYXNzID0gMSAvIGJvZHkubWFzcztcbiAgICAgICAgYm9keS5kZW5zaXR5ID0gYm9keS5tYXNzIC8gYm9keS5hcmVhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZW5zaXR5IG9mIHRoZSBib2R5LiBNYXNzIGFuZCBpbmVydGlhIGFyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLlxuICAgICAqIEBtZXRob2Qgc2V0RGVuc2l0eVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZW5zaXR5XG4gICAgICovXG4gICAgQm9keS5zZXREZW5zaXR5ID0gZnVuY3Rpb24oYm9keSwgZGVuc2l0eSkge1xuICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgZGVuc2l0eSAqIGJvZHkuYXJlYSk7XG4gICAgICAgIGJvZHkuZGVuc2l0eSA9IGRlbnNpdHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBib2R5LiBUaGlzIGlzIHRoZSBzZWNvbmQgbW9tZW50IG9mIGFyZWEgaW4gdHdvIGRpbWVuc2lvbnMuXG4gICAgICogSW52ZXJzZSBpbmVydGlhIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBjaGFuZ2UuIE1hc3MgaXMgbm90IGNoYW5nZWQuXG4gICAgICogQG1ldGhvZCBzZXRJbmVydGlhXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZXJ0aWFcbiAgICAgKi9cbiAgICBCb2R5LnNldEluZXJ0aWEgPSBmdW5jdGlvbihib2R5LCBpbmVydGlhKSB7XG4gICAgICAgIGJvZHkuaW5lcnRpYSA9IGluZXJ0aWE7XG4gICAgICAgIGJvZHkuaW52ZXJzZUluZXJ0aWEgPSAxIC8gYm9keS5pbmVydGlhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBib2R5J3MgdmVydGljZXMgYW5kIHVwZGF0ZXMgYm9keSBwcm9wZXJ0aWVzIGFjY29yZGluZ2x5LCBpbmNsdWRpbmcgaW5lcnRpYSwgYXJlYSBhbmQgbWFzcyAod2l0aCByZXNwZWN0IHRvIGBib2R5LmRlbnNpdHlgKS5cbiAgICAgKiBWZXJ0aWNlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtZWQgdG8gYmUgb3JpZW50YXRlZCBhcm91bmQgdGhlaXIgY2VudHJlIG9mIG1hc3MgYXMgdGhlIG9yaWdpbi5cbiAgICAgKiBUaGV5IGFyZSB0aGVuIGF1dG9tYXRpY2FsbHkgdHJhbnNsYXRlZCB0byB3b3JsZCBzcGFjZSBiYXNlZCBvbiBgYm9keS5wb3NpdGlvbmAuXG4gICAgICpcbiAgICAgKiBUaGUgYHZlcnRpY2VzYCBhcmd1bWVudCBzaG91bGQgYmUgcGFzc2VkIGFzIGFuIGFycmF5IG9mIGBNYXR0ZXIuVmVjdG9yYCBwb2ludHMgKG9yIGEgYE1hdHRlci5WZXJ0aWNlc2AgYXJyYXkpLlxuICAgICAqIFZlcnRpY2VzIG11c3QgZm9ybSBhIGNvbnZleCBodWxsLiBDb25jYXZlIHZlcnRpY2VzIG11c3QgYmUgZGVjb21wb3NlZCBpbnRvIGNvbnZleCBwYXJ0cy5cbiAgICAgKiBcbiAgICAgKiBAbWV0aG9kIHNldFZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt2ZWN0b3JbXX0gdmVydGljZXNcbiAgICAgKi9cbiAgICBCb2R5LnNldFZlcnRpY2VzID0gZnVuY3Rpb24oYm9keSwgdmVydGljZXMpIHtcbiAgICAgICAgLy8gY2hhbmdlIHZlcnRpY2VzXG4gICAgICAgIGlmICh2ZXJ0aWNlc1swXS5ib2R5ID09PSBib2R5KSB7XG4gICAgICAgICAgICBib2R5LnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5LnZlcnRpY2VzID0gVmVydGljZXMuY3JlYXRlKHZlcnRpY2VzLCBib2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgIGJvZHkuYXhlcyA9IEF4ZXMuZnJvbVZlcnRpY2VzKGJvZHkudmVydGljZXMpO1xuICAgICAgICBib2R5LmFyZWEgPSBWZXJ0aWNlcy5hcmVhKGJvZHkudmVydGljZXMpO1xuICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgYm9keS5kZW5zaXR5ICogYm9keS5hcmVhKTtcblxuICAgICAgICAvLyBvcmllbnQgdmVydGljZXMgYXJvdW5kIHRoZSBjZW50cmUgb2YgbWFzcyBhdCBvcmlnaW4gKDAsIDApXG4gICAgICAgIHZhciBjZW50cmUgPSBWZXJ0aWNlcy5jZW50cmUoYm9keS52ZXJ0aWNlcyk7XG4gICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShib2R5LnZlcnRpY2VzLCBjZW50cmUsIC0xKTtcblxuICAgICAgICAvLyB1cGRhdGUgaW5lcnRpYSB3aGlsZSB2ZXJ0aWNlcyBhcmUgYXQgb3JpZ2luICgwLCAwKVxuICAgICAgICBCb2R5LnNldEluZXJ0aWEoYm9keSwgQm9keS5faW5lcnRpYVNjYWxlICogVmVydGljZXMuaW5lcnRpYShib2R5LnZlcnRpY2VzLCBib2R5Lm1hc3MpKTtcblxuICAgICAgICAvLyB1cGRhdGUgZ2VvbWV0cnlcbiAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKGJvZHkudmVydGljZXMsIGJvZHkucG9zaXRpb24pO1xuICAgICAgICBCb3VuZHMudXBkYXRlKGJvZHkuYm91bmRzLCBib2R5LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcGFydHMgb2YgdGhlIGBib2R5YCBhbmQgdXBkYXRlcyBtYXNzLCBpbmVydGlhIGFuZCBjZW50cm9pZC5cbiAgICAgKiBFYWNoIHBhcnQgd2lsbCBoYXZlIGl0cyBwYXJlbnQgc2V0IHRvIGBib2R5YC5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBjb252ZXggaHVsbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29tcHV0ZWQgYW5kIHNldCBvbiBgYm9keWAsIHVubGVzcyBgYXV0b0h1bGxgIGlzIHNldCB0byBgZmFsc2UuYFxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBmaXJzdCBwYXJ0IGluIGBib2R5LnBhcnRzYCB3aWxsIGFsd2F5cyBiZSB0aGUgYGJvZHlgLlxuICAgICAqIEBtZXRob2Qgc2V0UGFydHNcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gcGFydHNcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFthdXRvSHVsbD10cnVlXVxuICAgICAqL1xuICAgIEJvZHkuc2V0UGFydHMgPSBmdW5jdGlvbihib2R5LCBwYXJ0cywgYXV0b0h1bGwpIHtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgLy8gYWRkIGFsbCB0aGUgcGFydHMsIGVuc3VyaW5nIHRoYXQgdGhlIGZpcnN0IHBhcnQgaXMgYWx3YXlzIHRoZSBwYXJlbnQgYm9keVxuICAgICAgICBwYXJ0cyA9IHBhcnRzLnNsaWNlKDApO1xuICAgICAgICBib2R5LnBhcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIGJvZHkucGFydHMucHVzaChib2R5KTtcbiAgICAgICAgYm9keS5wYXJlbnQgPSBib2R5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSBib2R5KSB7XG4gICAgICAgICAgICAgICAgcGFydC5wYXJlbnQgPSBib2R5O1xuICAgICAgICAgICAgICAgIGJvZHkucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5LnBhcnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBhdXRvSHVsbCA9IHR5cGVvZiBhdXRvSHVsbCAhPT0gJ3VuZGVmaW5lZCcgPyBhdXRvSHVsbCA6IHRydWU7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgY29udmV4IGh1bGwgb2YgYWxsIHBhcnRzIHRvIHNldCBvbiB0aGUgcGFyZW50IGJvZHlcbiAgICAgICAgaWYgKGF1dG9IdWxsKSB7XG4gICAgICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KHBhcnRzW2ldLnZlcnRpY2VzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVmVydGljZXMuY2xvY2t3aXNlU29ydCh2ZXJ0aWNlcyk7XG5cbiAgICAgICAgICAgIHZhciBodWxsID0gVmVydGljZXMuaHVsbCh2ZXJ0aWNlcyksXG4gICAgICAgICAgICAgICAgaHVsbENlbnRyZSA9IFZlcnRpY2VzLmNlbnRyZShodWxsKTtcblxuICAgICAgICAgICAgQm9keS5zZXRWZXJ0aWNlcyhib2R5LCBodWxsKTtcbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShib2R5LnZlcnRpY2VzLCBodWxsQ2VudHJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN1bSB0aGUgcHJvcGVydGllcyBvZiBhbGwgY29tcG91bmQgcGFydHMgb2YgdGhlIHBhcmVudCBib2R5XG4gICAgICAgIHZhciB0b3RhbCA9IEJvZHkuX3RvdGFsUHJvcGVydGllcyhib2R5KTtcblxuICAgICAgICBib2R5LmFyZWEgPSB0b3RhbC5hcmVhO1xuICAgICAgICBib2R5LnBhcmVudCA9IGJvZHk7XG4gICAgICAgIGJvZHkucG9zaXRpb24ueCA9IHRvdGFsLmNlbnRyZS54O1xuICAgICAgICBib2R5LnBvc2l0aW9uLnkgPSB0b3RhbC5jZW50cmUueTtcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IHRvdGFsLmNlbnRyZS54O1xuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ID0gdG90YWwuY2VudHJlLnk7XG5cbiAgICAgICAgQm9keS5zZXRNYXNzKGJvZHksIHRvdGFsLm1hc3MpO1xuICAgICAgICBCb2R5LnNldEluZXJ0aWEoYm9keSwgdG90YWwuaW5lcnRpYSk7XG4gICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwgdG90YWwuY2VudHJlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjZW50cmUgb2YgbWFzcyBvZiB0aGUgYm9keS4gXG4gICAgICogVGhlIGBjZW50cmVgIGlzIGEgdmVjdG9yIGluIHdvcmxkLXNwYWNlIHVubGVzcyBgcmVsYXRpdmVgIGlzIHNldCwgaW4gd2hpY2ggY2FzZSBpdCBpcyBhIHRyYW5zbGF0aW9uLlxuICAgICAqIFRoZSBjZW50cmUgb2YgbWFzcyBpcyB0aGUgcG9pbnQgdGhlIGJvZHkgcm90YXRlcyBhYm91dCBhbmQgY2FuIGJlIHVzZWQgdG8gc2ltdWxhdGUgbm9uLXVuaWZvcm0gZGVuc2l0eS5cbiAgICAgKiBUaGlzIGlzIGVxdWFsIHRvIG1vdmluZyBgYm9keS5wb3NpdGlvbmAgYnV0IG5vdCB0aGUgYGJvZHkudmVydGljZXNgLlxuICAgICAqIEludmFsaWQgaWYgdGhlIGBjZW50cmVgIGZhbGxzIG91dHNpZGUgdGhlIGJvZHkncyBjb252ZXggaHVsbC5cbiAgICAgKiBAbWV0aG9kIHNldENlbnRyZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBjZW50cmVcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IHJlbGF0aXZlXG4gICAgICovXG4gICAgQm9keS5zZXRDZW50cmUgPSBmdW5jdGlvbihib2R5LCBjZW50cmUsIHJlbGF0aXZlKSB7XG4gICAgICAgIGlmICghcmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBjZW50cmUueCAtIChib2R5LnBvc2l0aW9uLnggLSBib2R5LnBvc2l0aW9uUHJldi54KTtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBjZW50cmUueSAtIChib2R5LnBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uUHJldi55KTtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb24ueCA9IGNlbnRyZS54O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvbi55ID0gY2VudHJlLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ICs9IGNlbnRyZS54O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSArPSBjZW50cmUueTtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb24ueCArPSBjZW50cmUueDtcbiAgICAgICAgICAgIGJvZHkucG9zaXRpb24ueSArPSBjZW50cmUueTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keS4gQnkgZGVmYXVsdCB2ZWxvY2l0eSBpcyB1bmNoYW5nZWQuXG4gICAgICogSWYgYHVwZGF0ZVZlbG9jaXR5YCBpcyBgdHJ1ZWAgdGhlbiB2ZWxvY2l0eSBpcyBpbmZlcnJlZCBmcm9tIHRoZSBjaGFuZ2UgaW4gcG9zaXRpb24uXG4gICAgICogQG1ldGhvZCBzZXRQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZVZlbG9jaXR5PWZhbHNlXVxuICAgICAqL1xuICAgIEJvZHkuc2V0UG9zaXRpb24gPSBmdW5jdGlvbihib2R5LCBwb3NpdGlvbiwgdXBkYXRlVmVsb2NpdHkpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gVmVjdG9yLnN1Yihwb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVZlbG9jaXR5KSB7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ID0gYm9keS5wb3NpdGlvbi54O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSA9IGJvZHkucG9zaXRpb24ueTtcbiAgICAgICAgICAgIGJvZHkudmVsb2NpdHkueCA9IGRlbHRhLng7XG4gICAgICAgICAgICBib2R5LnZlbG9jaXR5LnkgPSBkZWx0YS55O1xuICAgICAgICAgICAgYm9keS5zcGVlZCA9IFZlY3Rvci5tYWduaXR1ZGUoZGVsdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCArPSBkZWx0YS54O1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvblByZXYueSArPSBkZWx0YS55O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV07XG4gICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggKz0gZGVsdGEueDtcbiAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBkZWx0YS55O1xuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIGRlbHRhKTtcbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFuZ2xlIG9mIHRoZSBib2R5LiBCeSBkZWZhdWx0IGFuZ3VsYXIgdmVsb2NpdHkgaXMgdW5jaGFuZ2VkLlxuICAgICAqIElmIGB1cGRhdGVWZWxvY2l0eWAgaXMgYHRydWVgIHRoZW4gYW5ndWxhciB2ZWxvY2l0eSBpcyBpbmZlcnJlZCBmcm9tIHRoZSBjaGFuZ2UgaW4gYW5nbGUuXG4gICAgICogQG1ldGhvZCBzZXRBbmdsZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZVZlbG9jaXR5PWZhbHNlXVxuICAgICAqL1xuICAgIEJvZHkuc2V0QW5nbGUgPSBmdW5jdGlvbihib2R5LCBhbmdsZSwgdXBkYXRlVmVsb2NpdHkpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gYW5nbGUgLSBib2R5LmFuZ2xlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHVwZGF0ZVZlbG9jaXR5KSB7XG4gICAgICAgICAgICBib2R5LmFuZ2xlUHJldiA9IGJvZHkuYW5nbGU7XG4gICAgICAgICAgICBib2R5LmFuZ3VsYXJWZWxvY2l0eSA9IGRlbHRhO1xuICAgICAgICAgICAgYm9keS5hbmd1bGFyU3BlZWQgPSBNYXRoLmFicyhkZWx0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5LmFuZ2xlUHJldiArPSBkZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2ldO1xuICAgICAgICAgICAgcGFydC5hbmdsZSArPSBkZWx0YTtcbiAgICAgICAgICAgIFZlcnRpY2VzLnJvdGF0ZShwYXJ0LnZlcnRpY2VzLCBkZWx0YSwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgICAgICBBeGVzLnJvdGF0ZShwYXJ0LmF4ZXMsIGRlbHRhKTtcbiAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZUFib3V0KHBhcnQucG9zaXRpb24sIGRlbHRhLCBib2R5LnBvc2l0aW9uLCBwYXJ0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgYm9keS4gIFxuICAgICAqIEFmZmVjdHMgYm9keSBzcGVlZC5cbiAgICAgKiBAbWV0aG9kIHNldFZlbG9jaXR5XG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHZlbG9jaXR5XG4gICAgICovXG4gICAgQm9keS5zZXRWZWxvY2l0eSA9IGZ1bmN0aW9uKGJvZHksIHZlbG9jaXR5KSB7XG4gICAgICAgIHZhciB0aW1lU2NhbGUgPSBib2R5LmRlbHRhVGltZSAvIEJvZHkuX2Jhc2VEZWx0YTtcbiAgICAgICAgYm9keS5wb3NpdGlvblByZXYueCA9IGJvZHkucG9zaXRpb24ueCAtIHZlbG9jaXR5LnggKiB0aW1lU2NhbGU7XG4gICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnkgPSBib2R5LnBvc2l0aW9uLnkgLSB2ZWxvY2l0eS55ICogdGltZVNjYWxlO1xuICAgICAgICBib2R5LnZlbG9jaXR5LnggPSAoYm9keS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvblByZXYueCkgLyB0aW1lU2NhbGU7XG4gICAgICAgIGJvZHkudmVsb2NpdHkueSA9IChib2R5LnBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uUHJldi55KSAvIHRpbWVTY2FsZTtcbiAgICAgICAgYm9keS5zcGVlZCA9IFZlY3Rvci5tYWduaXR1ZGUoYm9keS52ZWxvY2l0eSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbGluZWFyIHZlbG9jaXR5IG9mIHRoZSBib2R5LlxuICAgICAqIEBtZXRob2QgZ2V0VmVsb2NpdHlcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHt2ZWN0b3J9IHZlbG9jaXR5XG4gICAgICovXG4gICAgQm9keS5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgdmFyIHRpbWVTY2FsZSA9IEJvZHkuX2Jhc2VEZWx0YSAvIGJvZHkuZGVsdGFUaW1lO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAoYm9keS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvblByZXYueCkgKiB0aW1lU2NhbGUsXG4gICAgICAgICAgICB5OiAoYm9keS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvblByZXYueSkgKiB0aW1lU2NhbGVcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBsaW5lYXIgc3BlZWQgb2YgdGhlIGJvZHkuICBcbiAgICAgKiBFcXVpdmFsZW50IHRvIHRoZSBtYWduaXR1ZGUgb2YgaXRzIHZlbG9jaXR5LlxuICAgICAqIEBtZXRob2QgZ2V0U3BlZWRcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHNwZWVkXG4gICAgICovXG4gICAgQm9keS5nZXRTcGVlZCA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvci5tYWduaXR1ZGUoQm9keS5nZXRWZWxvY2l0eShib2R5KSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgbGluZWFyIHNwZWVkIG9mIHRoZSBib2R5LiAgXG4gICAgICogRGlyZWN0aW9uIGlzIG1haW50YWluZWQuIEFmZmVjdHMgYm9keSB2ZWxvY2l0eS5cbiAgICAgKiBAbWV0aG9kIHNldFNwZWVkXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkXG4gICAgICovXG4gICAgQm9keS5zZXRTcGVlZCA9IGZ1bmN0aW9uKGJvZHksIHNwZWVkKSB7XG4gICAgICAgIEJvZHkuc2V0VmVsb2NpdHkoYm9keSwgVmVjdG9yLm11bHQoVmVjdG9yLm5vcm1hbGlzZShCb2R5LmdldFZlbG9jaXR5KGJvZHkpKSwgc3BlZWQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHRoZSBib2R5LiAgXG4gICAgICogQWZmZWN0cyBib2R5IGFuZ3VsYXIgc3BlZWQuXG4gICAgICogQG1ldGhvZCBzZXRBbmd1bGFyVmVsb2NpdHlcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmVsb2NpdHlcbiAgICAgKi9cbiAgICBCb2R5LnNldEFuZ3VsYXJWZWxvY2l0eSA9IGZ1bmN0aW9uKGJvZHksIHZlbG9jaXR5KSB7XG4gICAgICAgIHZhciB0aW1lU2NhbGUgPSBib2R5LmRlbHRhVGltZSAvIEJvZHkuX2Jhc2VEZWx0YTtcbiAgICAgICAgYm9keS5hbmdsZVByZXYgPSBib2R5LmFuZ2xlIC0gdmVsb2NpdHkgKiB0aW1lU2NhbGU7XG4gICAgICAgIGJvZHkuYW5ndWxhclZlbG9jaXR5ID0gKGJvZHkuYW5nbGUgLSBib2R5LmFuZ2xlUHJldikgLyB0aW1lU2NhbGU7XG4gICAgICAgIGJvZHkuYW5ndWxhclNwZWVkID0gTWF0aC5hYnMoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGJvZHkuXG4gICAgICogQG1ldGhvZCBnZXRBbmd1bGFyVmVsb2NpdHlcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGFuZ3VsYXIgdmVsb2NpdHlcbiAgICAgKi9cbiAgICBCb2R5LmdldEFuZ3VsYXJWZWxvY2l0eSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIChib2R5LmFuZ2xlIC0gYm9keS5hbmdsZVByZXYpICogQm9keS5fYmFzZURlbHRhIC8gYm9keS5kZWx0YVRpbWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgYm9keS4gIFxuICAgICAqIEVxdWl2YWxlbnQgdG8gdGhlIG1hZ25pdHVkZSBvZiBpdHMgYW5ndWxhciB2ZWxvY2l0eS5cbiAgICAgKiBAbWV0aG9kIGdldEFuZ3VsYXJTcGVlZFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYW5ndWxhciBzcGVlZFxuICAgICAqL1xuICAgIEJvZHkuZ2V0QW5ndWxhclNwZWVkID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoQm9keS5nZXRBbmd1bGFyVmVsb2NpdHkoYm9keSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIGJvZHkuICBcbiAgICAgKiBEaXJlY3Rpb24gaXMgbWFpbnRhaW5lZC4gQWZmZWN0cyBib2R5IGFuZ3VsYXIgdmVsb2NpdHkuXG4gICAgICogQG1ldGhvZCBzZXRBbmd1bGFyU3BlZWRcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWRcbiAgICAgKi9cbiAgICBCb2R5LnNldEFuZ3VsYXJTcGVlZCA9IGZ1bmN0aW9uKGJvZHksIHNwZWVkKSB7XG4gICAgICAgIEJvZHkuc2V0QW5ndWxhclZlbG9jaXR5KGJvZHksIENvbW1vbi5zaWduKEJvZHkuZ2V0QW5ndWxhclZlbG9jaXR5KGJvZHkpKSAqIHNwZWVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBib2R5IGJ5IGEgZ2l2ZW4gdmVjdG9yIHJlbGF0aXZlIHRvIGl0cyBjdXJyZW50IHBvc2l0aW9uLiBCeSBkZWZhdWx0IHZlbG9jaXR5IGlzIHVuY2hhbmdlZC5cbiAgICAgKiBJZiBgdXBkYXRlVmVsb2NpdHlgIGlzIGB0cnVlYCB0aGVuIHZlbG9jaXR5IGlzIGluZmVycmVkIGZyb20gdGhlIGNoYW5nZSBpbiBwb3NpdGlvbi5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSB0cmFuc2xhdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZVZlbG9jaXR5PWZhbHNlXVxuICAgICAqL1xuICAgIEJvZHkudHJhbnNsYXRlID0gZnVuY3Rpb24oYm9keSwgdHJhbnNsYXRpb24sIHVwZGF0ZVZlbG9jaXR5KSB7XG4gICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwgVmVjdG9yLmFkZChib2R5LnBvc2l0aW9uLCB0cmFuc2xhdGlvbiksIHVwZGF0ZVZlbG9jaXR5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBhIGJvZHkgYnkgYSBnaXZlbiBhbmdsZSByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBhbmdsZS4gQnkgZGVmYXVsdCBhbmd1bGFyIHZlbG9jaXR5IGlzIHVuY2hhbmdlZC5cbiAgICAgKiBJZiBgdXBkYXRlVmVsb2NpdHlgIGlzIGB0cnVlYCB0aGVuIGFuZ3VsYXIgdmVsb2NpdHkgaXMgaW5mZXJyZWQgZnJvbSB0aGUgY2hhbmdlIGluIGFuZ2xlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IFtwb2ludF1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGVWZWxvY2l0eT1mYWxzZV1cbiAgICAgKi9cbiAgICBCb2R5LnJvdGF0ZSA9IGZ1bmN0aW9uKGJvZHksIHJvdGF0aW9uLCBwb2ludCwgdXBkYXRlVmVsb2NpdHkpIHtcbiAgICAgICAgaWYgKCFwb2ludCkge1xuICAgICAgICAgICAgQm9keS5zZXRBbmdsZShib2R5LCBib2R5LmFuZ2xlICsgcm90YXRpb24sIHVwZGF0ZVZlbG9jaXR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbiksXG4gICAgICAgICAgICAgICAgc2luID0gTWF0aC5zaW4ocm90YXRpb24pLFxuICAgICAgICAgICAgICAgIGR4ID0gYm9keS5wb3NpdGlvbi54IC0gcG9pbnQueCxcbiAgICAgICAgICAgICAgICBkeSA9IGJvZHkucG9zaXRpb24ueSAtIHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54ICsgKGR4ICogY29zIC0gZHkgKiBzaW4pLFxuICAgICAgICAgICAgICAgIHk6IHBvaW50LnkgKyAoZHggKiBzaW4gKyBkeSAqIGNvcylcbiAgICAgICAgICAgIH0sIHVwZGF0ZVZlbG9jaXR5KTtcblxuICAgICAgICAgICAgQm9keS5zZXRBbmdsZShib2R5LCBib2R5LmFuZ2xlICsgcm90YXRpb24sIHVwZGF0ZVZlbG9jaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhlIGJvZHksIGluY2x1ZGluZyB1cGRhdGluZyBwaHlzaWNhbCBwcm9wZXJ0aWVzIChtYXNzLCBhcmVhLCBheGVzLCBpbmVydGlhKSwgZnJvbSBhIHdvcmxkLXNwYWNlIHBvaW50IChkZWZhdWx0IGlzIGJvZHkgY2VudHJlKS5cbiAgICAgKiBAbWV0aG9kIHNjYWxlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVlcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW3BvaW50XVxuICAgICAqL1xuICAgIEJvZHkuc2NhbGUgPSBmdW5jdGlvbihib2R5LCBzY2FsZVgsIHNjYWxlWSwgcG9pbnQpIHtcbiAgICAgICAgdmFyIHRvdGFsQXJlYSA9IDAsXG4gICAgICAgICAgICB0b3RhbEluZXJ0aWEgPSAwO1xuXG4gICAgICAgIHBvaW50ID0gcG9pbnQgfHwgYm9keS5wb3NpdGlvbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcblxuICAgICAgICAgICAgLy8gc2NhbGUgdmVydGljZXNcbiAgICAgICAgICAgIFZlcnRpY2VzLnNjYWxlKHBhcnQudmVydGljZXMsIHNjYWxlWCwgc2NhbGVZLCBwb2ludCk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBwYXJ0LmF4ZXMgPSBBeGVzLmZyb21WZXJ0aWNlcyhwYXJ0LnZlcnRpY2VzKTtcbiAgICAgICAgICAgIHBhcnQuYXJlYSA9IFZlcnRpY2VzLmFyZWEocGFydC52ZXJ0aWNlcyk7XG4gICAgICAgICAgICBCb2R5LnNldE1hc3MocGFydCwgYm9keS5kZW5zaXR5ICogcGFydC5hcmVhKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGluZXJ0aWEgKHJlcXVpcmVzIHZlcnRpY2VzIHRvIGJlIGF0IG9yaWdpbilcbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCB7IHg6IC1wYXJ0LnBvc2l0aW9uLngsIHk6IC1wYXJ0LnBvc2l0aW9uLnkgfSk7XG4gICAgICAgICAgICBCb2R5LnNldEluZXJ0aWEocGFydCwgQm9keS5faW5lcnRpYVNjYWxlICogVmVydGljZXMuaW5lcnRpYShwYXJ0LnZlcnRpY2VzLCBwYXJ0Lm1hc3MpKTtcbiAgICAgICAgICAgIFZlcnRpY2VzLnRyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCB7IHg6IHBhcnQucG9zaXRpb24ueCwgeTogcGFydC5wb3NpdGlvbi55IH0pO1xuXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICB0b3RhbEFyZWEgKz0gcGFydC5hcmVhO1xuICAgICAgICAgICAgICAgIHRvdGFsSW5lcnRpYSArPSBwYXJ0LmluZXJ0aWE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNjYWxlIHBvc2l0aW9uXG4gICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggPSBwb2ludC54ICsgKHBhcnQucG9zaXRpb24ueCAtIHBvaW50LngpICogc2NhbGVYO1xuICAgICAgICAgICAgcGFydC5wb3NpdGlvbi55ID0gcG9pbnQueSArIChwYXJ0LnBvc2l0aW9uLnkgLSBwb2ludC55KSAqIHNjYWxlWTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGJvdW5kc1xuICAgICAgICAgICAgQm91bmRzLnVwZGF0ZShwYXJ0LmJvdW5kcywgcGFydC52ZXJ0aWNlcywgYm9keS52ZWxvY2l0eSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgcGFyZW50IGJvZHlcbiAgICAgICAgaWYgKGJvZHkucGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgYm9keS5hcmVhID0gdG90YWxBcmVhO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBCb2R5LnNldE1hc3MoYm9keSwgYm9keS5kZW5zaXR5ICogdG90YWxBcmVhKTtcbiAgICAgICAgICAgICAgICBCb2R5LnNldEluZXJ0aWEoYm9keSwgdG90YWxJbmVydGlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBjaXJjbGVzXG4gICAgICAgIGlmIChib2R5LmNpcmNsZVJhZGl1cykgeyBcbiAgICAgICAgICAgIGlmIChzY2FsZVggPT09IHNjYWxlWSkge1xuICAgICAgICAgICAgICAgIGJvZHkuY2lyY2xlUmFkaXVzICo9IHNjYWxlWDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYm9keSBpcyBubyBsb25nZXIgYSBjaXJjbGVcbiAgICAgICAgICAgICAgICBib2R5LmNpcmNsZVJhZGl1cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW4gdXBkYXRlIGJ5IGludGVncmF0aW5nIHRoZSBlcXVhdGlvbnMgb2YgbW90aW9uIG9uIHRoZSBgYm9keWAuXG4gICAgICogVGhpcyBpcyBhcHBsaWVkIGV2ZXJ5IHVwZGF0ZSBieSBgTWF0dGVyLkVuZ2luZWAgYXV0b21hdGljYWxseS5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGFUaW1lPTE2LjY2Nl1cbiAgICAgKi9cbiAgICBCb2R5LnVwZGF0ZSA9IGZ1bmN0aW9uKGJvZHksIGRlbHRhVGltZSkge1xuICAgICAgICBkZWx0YVRpbWUgPSAodHlwZW9mIGRlbHRhVGltZSAhPT0gJ3VuZGVmaW5lZCcgPyBkZWx0YVRpbWUgOiAoMTAwMCAvIDYwKSkgKiBib2R5LnRpbWVTY2FsZTtcblxuICAgICAgICB2YXIgZGVsdGFUaW1lU3F1YXJlZCA9IGRlbHRhVGltZSAqIGRlbHRhVGltZSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24gPSBCb2R5Ll90aW1lQ29ycmVjdGlvbiA/IGRlbHRhVGltZSAvIChib2R5LmRlbHRhVGltZSB8fCBkZWx0YVRpbWUpIDogMTtcblxuICAgICAgICAvLyBmcm9tIHRoZSBwcmV2aW91cyBzdGVwXG4gICAgICAgIHZhciBmcmljdGlvbkFpciA9IDEgLSBib2R5LmZyaWN0aW9uQWlyICogKGRlbHRhVGltZSAvIENvbW1vbi5fYmFzZURlbHRhKSxcbiAgICAgICAgICAgIHZlbG9jaXR5UHJldlggPSAoYm9keS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvblByZXYueCkgKiBjb3JyZWN0aW9uLFxuICAgICAgICAgICAgdmVsb2NpdHlQcmV2WSA9IChib2R5LnBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uUHJldi55KSAqIGNvcnJlY3Rpb247XG5cbiAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IHdpdGggVmVybGV0IGludGVncmF0aW9uXG4gICAgICAgIGJvZHkudmVsb2NpdHkueCA9ICh2ZWxvY2l0eVByZXZYICogZnJpY3Rpb25BaXIpICsgKGJvZHkuZm9yY2UueCAvIGJvZHkubWFzcykgKiBkZWx0YVRpbWVTcXVhcmVkO1xuICAgICAgICBib2R5LnZlbG9jaXR5LnkgPSAodmVsb2NpdHlQcmV2WSAqIGZyaWN0aW9uQWlyKSArIChib2R5LmZvcmNlLnkgLyBib2R5Lm1hc3MpICogZGVsdGFUaW1lU3F1YXJlZDtcblxuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi54ID0gYm9keS5wb3NpdGlvbi54O1xuICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ID0gYm9keS5wb3NpdGlvbi55O1xuICAgICAgICBib2R5LnBvc2l0aW9uLnggKz0gYm9keS52ZWxvY2l0eS54O1xuICAgICAgICBib2R5LnBvc2l0aW9uLnkgKz0gYm9keS52ZWxvY2l0eS55O1xuICAgICAgICBib2R5LmRlbHRhVGltZSA9IGRlbHRhVGltZTtcblxuICAgICAgICAvLyB1cGRhdGUgYW5ndWxhciB2ZWxvY2l0eSB3aXRoIFZlcmxldCBpbnRlZ3JhdGlvblxuICAgICAgICBib2R5LmFuZ3VsYXJWZWxvY2l0eSA9ICgoYm9keS5hbmdsZSAtIGJvZHkuYW5nbGVQcmV2KSAqIGZyaWN0aW9uQWlyICogY29ycmVjdGlvbikgKyAoYm9keS50b3JxdWUgLyBib2R5LmluZXJ0aWEpICogZGVsdGFUaW1lU3F1YXJlZDtcbiAgICAgICAgYm9keS5hbmdsZVByZXYgPSBib2R5LmFuZ2xlO1xuICAgICAgICBib2R5LmFuZ2xlICs9IGJvZHkuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgYm9keSBnZW9tZXRyeVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tpXTtcblxuICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnBvc2l0aW9uLnggKz0gYm9keS52ZWxvY2l0eS54O1xuICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBib2R5LnZlbG9jaXR5Lnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChib2R5LmFuZ3VsYXJWZWxvY2l0eSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIFZlcnRpY2VzLnJvdGF0ZShwYXJ0LnZlcnRpY2VzLCBib2R5LmFuZ3VsYXJWZWxvY2l0eSwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgQXhlcy5yb3RhdGUocGFydC5heGVzLCBib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFZlY3Rvci5yb3RhdGVBYm91dChwYXJ0LnBvc2l0aW9uLCBib2R5LmFuZ3VsYXJWZWxvY2l0eSwgYm9keS5wb3NpdGlvbiwgcGFydC5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBCb3VuZHMudXBkYXRlKHBhcnQuYm91bmRzLCBwYXJ0LnZlcnRpY2VzLCBib2R5LnZlbG9jaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHByb3BlcnRpZXMgYGJvZHkudmVsb2NpdHlgLCBgYm9keS5zcGVlZGAsIGBib2R5LmFuZ3VsYXJWZWxvY2l0eWAgYW5kIGBib2R5LmFuZ3VsYXJTcGVlZGAgd2hpY2ggYXJlIG5vcm1hbGlzZWQgaW4gcmVsYXRpb24gdG8gYEJvZHkuX2Jhc2VEZWx0YWAuXG4gICAgICogQG1ldGhvZCB1cGRhdGVWZWxvY2l0aWVzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICovXG4gICAgQm9keS51cGRhdGVWZWxvY2l0aWVzID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICB2YXIgdGltZVNjYWxlID0gQm9keS5fYmFzZURlbHRhIC8gYm9keS5kZWx0YVRpbWUsXG4gICAgICAgICAgICBib2R5VmVsb2NpdHkgPSBib2R5LnZlbG9jaXR5O1xuXG4gICAgICAgIGJvZHlWZWxvY2l0eS54ID0gKGJvZHkucG9zaXRpb24ueCAtIGJvZHkucG9zaXRpb25QcmV2LngpICogdGltZVNjYWxlO1xuICAgICAgICBib2R5VmVsb2NpdHkueSA9IChib2R5LnBvc2l0aW9uLnkgLSBib2R5LnBvc2l0aW9uUHJldi55KSAqIHRpbWVTY2FsZTtcbiAgICAgICAgYm9keS5zcGVlZCA9IE1hdGguc3FydCgoYm9keVZlbG9jaXR5LnggKiBib2R5VmVsb2NpdHkueCkgKyAoYm9keVZlbG9jaXR5LnkgKiBib2R5VmVsb2NpdHkueSkpO1xuXG4gICAgICAgIGJvZHkuYW5ndWxhclZlbG9jaXR5ID0gKGJvZHkuYW5nbGUgLSBib2R5LmFuZ2xlUHJldikgKiB0aW1lU2NhbGU7XG4gICAgICAgIGJvZHkuYW5ndWxhclNwZWVkID0gTWF0aC5hYnMoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBgZm9yY2VgIHRvIHRoZSBgYm9keWAgZnJvbSB0aGUgZm9yY2Ugb3JpZ2luIGBwb3NpdGlvbmAgaW4gd29ybGQtc3BhY2UsIG92ZXIgYSBzaW5nbGUgdGltZXN0ZXAsIGluY2x1ZGluZyBhcHBseWluZyBhbnkgcmVzdWx0aW5nIGFuZ3VsYXIgdG9ycXVlLlxuICAgICAqIFxuICAgICAqIEZvcmNlcyBhcmUgdXNlZnVsIGZvciBlZmZlY3RzIGxpa2UgZ3Jhdml0eSwgd2luZCBvciByb2NrZXQgdGhydXN0LCBidXQgY2FuIGJlIGRpZmZpY3VsdCBpbiBwcmFjdGljZSB3aGVuIHByZWNpc2UgY29udHJvbCBpcyBuZWVkZWQuIEluIHRoZXNlIGNhc2VzIHNlZSBgQm9keS5zZXRWZWxvY2l0eWAgYW5kIGBCb2R5LnNldFBvc2l0aW9uYCBhcyBhbiBhbHRlcm5hdGl2ZS5cbiAgICAgKiBcbiAgICAgKiBUaGUgZm9yY2UgZnJvbSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgYXBwbGllZCBvbmNlIGZvciB0aGUgZHVyYXRpb24gb2YgYSBzaW5nbGUgdGltZXN0ZXAsIGluIG90aGVyIHdvcmRzIHRoZSBkdXJhdGlvbiBkZXBlbmRzIGRpcmVjdGx5IG9uIHRoZSBjdXJyZW50IGVuZ2luZSB1cGRhdGUgYGRlbHRhYCBhbmQgdGhlIHJhdGUgb2YgY2FsbHMgdG8gdGhpcyBmdW5jdGlvbi5cbiAgICAgKiBcbiAgICAgKiBUaGVyZWZvcmUgdG8gYWNjb3VudCBmb3IgdGltZSwgeW91IHNob3VsZCBhcHBseSB0aGUgZm9yY2UgY29uc3RhbnRseSBvdmVyIGFzIG1hbnkgZW5naW5lIHVwZGF0ZXMgYXMgZXF1aXZhbGVudCB0byB0aGUgaW50ZW5kZWQgZHVyYXRpb24uXG4gICAgICogXG4gICAgICogSWYgYWxsIG9yIHBhcnQgb2YgdGhlIGZvcmNlIGR1cmF0aW9uIGlzIHNvbWUgZnJhY3Rpb24gb2YgYSB0aW1lc3RlcCwgZmlyc3QgbXVsdGlwbHkgdGhlIGZvcmNlIGJ5IGBkdXJhdGlvbiAvIHRpbWVzdGVwYC5cbiAgICAgKiBcbiAgICAgKiBUaGUgZm9yY2Ugb3JpZ2luIGBwb3NpdGlvbmAgaW4gd29ybGQtc3BhY2UgbXVzdCBhbHNvIGJlIHNwZWNpZmllZC4gUGFzc2luZyBgYm9keS5wb3NpdGlvbmAgd2lsbCByZXN1bHQgaW4gemVybyBhbmd1bGFyIGVmZmVjdCBhcyB0aGUgZm9yY2Ugb3JpZ2luIHdvdWxkIGJlIGF0IHRoZSBjZW50cmUgb2YgbWFzcy5cbiAgICAgKiBcbiAgICAgKiBUaGUgYGJvZHlgIHdpbGwgdGFrZSB0aW1lIHRvIGFjY2VsZXJhdGUgdW5kZXIgYSBmb3JjZSwgdGhlIHJlc3VsdGluZyBlZmZlY3QgZGVwZW5kcyBvbiBkdXJhdGlvbiBvZiB0aGUgZm9yY2UsIHRoZSBib2R5IG1hc3MgYW5kIG90aGVyIGZvcmNlcyBvbiB0aGUgYm9keSBpbmNsdWRpbmcgZnJpY3Rpb24gY29tYmluZWQuXG4gICAgICogQG1ldGhvZCBhcHBseUZvcmNlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvc2l0aW9uIFRoZSBmb3JjZSBvcmlnaW4gaW4gd29ybGQtc3BhY2UuIFBhc3MgYGJvZHkucG9zaXRpb25gIHRvIGF2b2lkIGFuZ3VsYXIgdG9ycXVlLlxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBmb3JjZVxuICAgICAqL1xuICAgIEJvZHkuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uKGJvZHksIHBvc2l0aW9uLCBmb3JjZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0geyB4OiBwb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55IH07XG4gICAgICAgIGJvZHkuZm9yY2UueCArPSBmb3JjZS54O1xuICAgICAgICBib2R5LmZvcmNlLnkgKz0gZm9yY2UueTtcbiAgICAgICAgYm9keS50b3JxdWUgKz0gb2Zmc2V0LnggKiBmb3JjZS55IC0gb2Zmc2V0LnkgKiBmb3JjZS54O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW1zIG9mIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHkuXG4gICAgICogQG1ldGhvZCBfdG90YWxQcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHt9XG4gICAgICovXG4gICAgQm9keS5fdG90YWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAvLyBmcm9tIGVxdWF0aW9ucyBhdDpcbiAgICAgICAgLy8gaHR0cHM6Ly9lY291cnNlcy5vdS5lZHUvY2dpLWJpbi9lYm9vay5jZ2k/ZG9jPSZ0b3BpYz1zdCZjaGFwX3NlYz0wNy4yJnBhZ2U9dGhlb3J5XG4gICAgICAgIC8vIGh0dHA6Ly9vdXRwdXQudG8vc2lkZXdheS9kZWZhdWx0LmFzcD9xbm89MTIxMTAwMDg3XG5cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtYXNzOiAwLFxuICAgICAgICAgICAgYXJlYTogMCxcbiAgICAgICAgICAgIGluZXJ0aWE6IDAsXG4gICAgICAgICAgICBjZW50cmU6IHsgeDogMCwgeTogMCB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3VtIHRoZSBwcm9wZXJ0aWVzIG9mIGFsbCBjb21wb3VuZCBwYXJ0cyBvZiB0aGUgcGFyZW50IGJvZHlcbiAgICAgICAgZm9yICh2YXIgaSA9IGJvZHkucGFydHMubGVuZ3RoID09PSAxID8gMCA6IDE7IGkgPCBib2R5LnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbaV0sXG4gICAgICAgICAgICAgICAgbWFzcyA9IHBhcnQubWFzcyAhPT0gSW5maW5pdHkgPyBwYXJ0Lm1hc3MgOiAxO1xuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLm1hc3MgKz0gbWFzcztcbiAgICAgICAgICAgIHByb3BlcnRpZXMuYXJlYSArPSBwYXJ0LmFyZWE7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmluZXJ0aWEgKz0gcGFydC5pbmVydGlhO1xuICAgICAgICAgICAgcHJvcGVydGllcy5jZW50cmUgPSBWZWN0b3IuYWRkKHByb3BlcnRpZXMuY2VudHJlLCBWZWN0b3IubXVsdChwYXJ0LnBvc2l0aW9uLCBtYXNzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0aWVzLmNlbnRyZSA9IFZlY3Rvci5kaXYocHJvcGVydGllcy5jZW50cmUsIHByb3BlcnRpZXMubWFzcyk7XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKlxuICAgICogIEV2ZW50cyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gYSBib2R5IHN0YXJ0cyBzbGVlcGluZyAod2hlcmUgYHRoaXNgIGlzIHRoZSBib2R5KS5cbiAgICAqXG4gICAgKiBAZXZlbnQgc2xlZXBTdGFydFxuICAgICogQHRoaXMge2JvZHl9IFRoZSBib2R5IHRoYXQgaGFzIHN0YXJ0ZWQgc2xlZXBpbmdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIGEgYm9keSBlbmRzIHNsZWVwaW5nICh3aGVyZSBgdGhpc2AgaXMgdGhlIGJvZHkpLlxuICAgICpcbiAgICAqIEBldmVudCBzbGVlcEVuZFxuICAgICogQHRoaXMge2JvZHl9IFRoZSBib2R5IHRoYXQgaGFzIGVuZGVkIHNsZWVwaW5nXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB1bmlxdWVseSBpZGVudGlmeWluZyBudW1iZXIgZ2VuZXJhdGVkIGluIGBCb2R5LmNyZWF0ZWAgYnkgYENvbW1vbi5uZXh0SWRgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gU2V0IGJ5IGBCb2R5LmNyZWF0ZWAuXG4gICAgICogXG4gICAgICogQSBgU3RyaW5nYCBkZW5vdGluZyB0aGUgdHlwZSBvZiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0IFwiYm9keVwiXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcmJpdHJhcnkgYFN0cmluZ2AgbmFtZSB0byBoZWxwIHRoZSB1c2VyIGlkZW50aWZ5IGFuZCBtYW5hZ2UgYm9kaWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGxhYmVsXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJCb2R5XCJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBVc2UgYEJvZHkuc2V0UGFydHNgIHRvIHNldC4gXG4gICAgICogXG4gICAgICogQW4gYXJyYXkgb2YgYm9kaWVzIHRoYXQgbWFrZSB1cCB0aGlzIGJvZHkuIFxuICAgICAqIFRoZSBmaXJzdCBib2R5IGluIHRoZSBhcnJheSBtdXN0IGFsd2F5cyBiZSBhIHNlbGYgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGJvZHkgaW5zdGFuY2UuXG4gICAgICogQWxsIGJvZGllcyBpbiB0aGUgYHBhcnRzYCBhcnJheSB0b2dldGhlciBmb3JtIGEgc2luZ2xlIHJpZ2lkIGNvbXBvdW5kIGJvZHkuXG4gICAgICogUGFydHMgYXJlIGFsbG93ZWQgdG8gb3ZlcmxhcCwgaGF2ZSBnYXBzIG9yIGhvbGVzIG9yIGV2ZW4gZm9ybSBjb25jYXZlIGJvZGllcy5cbiAgICAgKiBQYXJ0cyB0aGVtc2VsdmVzIHNob3VsZCBuZXZlciBiZSBhZGRlZCB0byBhIGBXb3JsZGAsIG9ubHkgdGhlIHBhcmVudCBib2R5IHNob3VsZCBiZS5cbiAgICAgKiBVc2UgYEJvZHkuc2V0UGFydHNgIHdoZW4gc2V0dGluZyBwYXJ0cyB0byBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IHBhcnRzXG4gICAgICogQHR5cGUgYm9keVtdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgcmVzZXJ2ZWQgZm9yIHN0b3JpbmcgcGx1Z2luLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGx1Z2luXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBVcGRhdGVkIGJ5IGBCb2R5LnNldFBhcnRzYC5cbiAgICAgKiBcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYm9keSB0aGF0IHRoaXMgaXMgYSBwYXJ0IG9mLiBTZWUgYGJvZHkucGFydHNgLlxuICAgICAqIFRoaXMgaXMgYSBzZWxmIHJlZmVyZW5jZSBpZiB0aGUgYm9keSBpcyBub3QgYSBwYXJ0IG9mIGFub3RoZXIgYm9keS5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBwYXJlbnRcbiAgICAgKiBAdHlwZSBib2R5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHNwZWNpZnlpbmcgdGhlIGFuZ2xlIG9mIHRoZSBib2R5LCBpbiByYWRpYW5zLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGFuZ2xlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgQm9keS5zZXRWZXJ0aWNlc2Agb3IgYEJvZHkuc2V0UGFydHNgIHRvIHNldC4gU2VlIGFsc28gYEJvZGllcy5mcm9tVmVydGljZXNgLlxuICAgICAqIFxuICAgICAqIEFuIGFycmF5IG9mIGBWZWN0b3JgIG9iamVjdHMgdGhhdCBzcGVjaWZ5IHRoZSBjb252ZXggaHVsbCBvZiB0aGUgcmlnaWQgYm9keS5cbiAgICAgKiBUaGVzZSBzaG91bGQgYmUgcHJvdmlkZWQgYWJvdXQgdGhlIG9yaWdpbiBgKDAsIDApYC4gRS5nLlxuICAgICAqXG4gICAgICogYFt7IHg6IDAsIHk6IDAgfSwgeyB4OiAyNSwgeTogNTAgfSwgeyB4OiA1MCwgeTogMCB9XWBcbiAgICAgKiBcbiAgICAgKiBWZXJ0aWNlcyBtdXN0IGFsd2F5cyBiZSBjb252ZXgsIGluIGNsb2Nrd2lzZSBvcmRlciBhbmQgbXVzdCBub3QgY29udGFpbiBhbnkgZHVwbGljYXRlIHBvaW50cy5cbiAgICAgKiBcbiAgICAgKiBDb25jYXZlIHZlcnRpY2VzIHNob3VsZCBiZSBkZWNvbXBvc2VkIGludG8gY29udmV4IGBwYXJ0c2AsIHNlZSBgQm9kaWVzLmZyb21WZXJ0aWNlc2AgYW5kIGBCb2R5LnNldFBhcnRzYC5cbiAgICAgKlxuICAgICAqIFdoZW4gc2V0IHRoZSB2ZXJ0aWNlcyBhcmUgdHJhbnNsYXRlZCBzdWNoIHRoYXQgYGJvZHkucG9zaXRpb25gIGlzIGF0IHRoZSBjZW50cmUgb2YgbWFzcy5cbiAgICAgKiBNYW55IG90aGVyIGJvZHkgcHJvcGVydGllcyBhcmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGZyb20gdGhlc2UgdmVydGljZXMgd2hlbiBzZXQgaW5jbHVkaW5nIGBkZW5zaXR5YCwgYGFyZWFgIGFuZCBgaW5lcnRpYWAuXG4gICAgICogXG4gICAgICogVGhlIG1vZHVsZSBgTWF0dGVyLlZlcnRpY2VzYCBjb250YWlucyB1c2VmdWwgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIHZlcnRpY2VzLlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUgdmVjdG9yW11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBVc2UgYEJvZHkuc2V0UG9zaXRpb25gIHRvIHNldC4gXG4gICAgICogXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgY3VycmVudCB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB2ZWN0b3JcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IGFjY3VtdWxhdGVzIHRoZSB0b3RhbCBmb3JjZSBhcHBsaWVkIHRvIHRoZSBib2R5IGZvciBhIHNpbmdsZSB1cGRhdGUuXG4gICAgICogRm9yY2UgaXMgemVyb2VkIGFmdGVyIGV2ZXJ5IGBFbmdpbmUudXBkYXRlYCwgc28gY29uc3RhbnQgZm9yY2VzIHNob3VsZCBiZSBhcHBsaWVkIGZvciBldmVyeSB1cGRhdGUgdGhleSBhcmUgbmVlZGVkLiBTZWUgYWxzbyBgQm9keS5hcHBseUZvcmNlYC5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgKiBAdHlwZSB2ZWN0b3JcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGFjY3VtdWxhdGVzIHRoZSB0b3RhbCB0b3JxdWUgKHR1cm5pbmcgZm9yY2UpIGFwcGxpZWQgdG8gdGhlIGJvZHkgZm9yIGEgc2luZ2xlIHVwZGF0ZS4gU2VlIGFsc28gYEJvZHkuYXBwbHlGb3JjZWAuXG4gICAgICogVG9ycXVlIGlzIHplcm9lZCBhZnRlciBldmVyeSBgRW5naW5lLnVwZGF0ZWAsIHNvIGNvbnN0YW50IHRvcnF1ZXMgc2hvdWxkIGJlIGFwcGxpZWQgZm9yIGV2ZXJ5IHVwZGF0ZSB0aGV5IGFyZSBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBUb3JxdWVzIHJlc3VsdCBpbiBhbmd1bGFyIGFjY2VsZXJhdGlvbiBvbiBldmVyeSB1cGRhdGUsIHdoaWNoIGRlcGVuZHMgb24gYm9keSBpbmVydGlhIGFuZCB0aGUgZW5naW5lIHVwZGF0ZSBkZWx0YS5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgdG9ycXVlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgQm9keS5zZXRTcGVlZGAgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBTZWUgYEJvZHkuZ2V0U3BlZWRgIGZvciBkZXRhaWxzLlxuICAgICAqIFxuICAgICAqIEVxdWl2YWxlbnQgdG8gdGhlIG1hZ25pdHVkZSBvZiBgYm9keS52ZWxvY2l0eWAgKGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICogXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IHNwZWVkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgQm9keS5zZXRWZWxvY2l0eWAgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBTZWUgYEJvZHkuZ2V0VmVsb2NpdHlgIGZvciBkZXRhaWxzLlxuICAgICAqIFxuICAgICAqIEVxdWl2YWxlbnQgdG8gdGhlIG1hZ25pdHVkZSBvZiBgYm9keS5hbmd1bGFyVmVsb2NpdHlgIChhbHdheXMgcG9zaXRpdmUpLlxuICAgICAqIFxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eVxuICAgICAqIEB0eXBlIHZlY3RvclxuICAgICAqIEBkZWZhdWx0IHsgeDogMCwgeTogMCB9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBCb2R5LnNldEFuZ3VsYXJTcGVlZGAgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBTZWUgYEJvZHkuZ2V0QW5ndWxhclNwZWVkYCBmb3IgZGV0YWlscy5cbiAgICAgKiBcbiAgICAgKiBcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclNwZWVkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgQm9keS5zZXRBbmd1bGFyVmVsb2NpdHlgIHRvIHNldC4gXG4gICAgICogXG4gICAgICogU2VlIGBCb2R5LmdldEFuZ3VsYXJWZWxvY2l0eWAgZm9yIGRldGFpbHMuXG4gICAgICogXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgQm9keS5zZXRTdGF0aWNgIHRvIHNldC4gXG4gICAgICogXG4gICAgICogQSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYSBib2R5IGlzIGNvbnNpZGVyZWQgc3RhdGljLiBBIHN0YXRpYyBib2R5IGNhbiBuZXZlciBjaGFuZ2UgcG9zaXRpb24gb3IgYW5nbGUgYW5kIGlzIGNvbXBsZXRlbHkgZml4ZWQuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgaXNTdGF0aWNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGEgYm9keSBpcyBhIHNlbnNvci4gU2Vuc29yIHRyaWdnZXJzIGNvbGxpc2lvbiBldmVudHMsIGJ1dCBkb2Vzbid0IHJlYWN0IHdpdGggY29sbGlkaW5nIGJvZHkgcGh5c2ljYWxseS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc1NlbnNvclxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVzZSBgU2xlZXBpbmcuc2V0YCB0byBzZXQuIFxuICAgICAqIFxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXBpbmcuIEEgc2xlZXBpbmcgYm9keSBhY3RzIHNpbWlsYXIgdG8gYSBzdGF0aWMgYm9keSwgZXhjZXB0IGl0IGlzIG9ubHkgdGVtcG9yYXJ5IGFuZCBjYW4gYmUgYXdva2VuLlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IGlzU2xlZXBpbmdcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBDYWxjdWxhdGVkIGR1cmluZyBlbmdpbmUgdXBkYXRlIG9ubHkgd2hlbiBzbGVlcGluZyBpcyBlbmFibGVkLlxuICAgICAqIFxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBsb29zZWx5IG1lYXN1cmVzIHRoZSBhbW91bnQgb2YgbW92ZW1lbnQgYSBib2R5IGN1cnJlbnRseSBoYXMuXG4gICAgICpcbiAgICAgKiBEZXJpdmVkIGZyb20gYGJvZHkuc3BlZWReMiArIGJvZHkuYW5ndWxhclNwZWVkXjJgLiBTZWUgYFNsZWVwaW5nLnVwZGF0ZWAuXG4gICAgICogXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IG1vdGlvblxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBsZW5ndGggb2YgdGltZSBkdXJpbmcgd2hpY2ggdGhpcyBib2R5IG11c3QgaGF2ZSBuZWFyLXplcm8gdmVsb2NpdHkgYmVmb3JlIGl0IGlzIHNldCBhcyBzbGVlcGluZyBieSB0aGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlIChpZiBzbGVlcGluZyBpcyBlbmFibGVkIGJ5IHRoZSBlbmdpbmUpLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFRocmVzaG9sZFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDYwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBCb2R5LnNldERlbnNpdHlgIHRvIHNldC4gXG4gICAgICogXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGRlbnNpdHkgb2YgdGhlIGJvZHkgKG1hc3MgcGVyIHVuaXQgYXJlYSkuXG4gICAgICogXG4gICAgICogTWFzcyB3aWxsIGFsc28gYmUgdXBkYXRlZCB3aGVuIHNldC5cbiAgICAgKlxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBkZW5zaXR5XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4wMDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBVc2UgYEJvZHkuc2V0TWFzc2AgdG8gc2V0LiBcbiAgICAgKiBcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgbWFzcyBvZiB0aGUgYm9keS5cbiAgICAgKiBcbiAgICAgKiBEZW5zaXR5IHdpbGwgYWxzbyBiZSB1cGRhdGVkIHdoZW4gc2V0LlxuICAgICAqIFxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBtYXNzXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBfUmVhZCBvbmx5Xy4gVXNlIGBCb2R5LnNldE1hc3NgIHRvIHNldC4gXG4gICAgICogXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keSAoYDEgLyBtYXNzYCkuXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgaW52ZXJzZU1hc3NcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBBdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgd2hlbiB2ZXJ0aWNlcywgbWFzcyBvciBkZW5zaXR5IGFyZSBzZXQgb3Igc2V0IHRocm91Z2ggYEJvZHkuc2V0SW5lcnRpYWAuXG4gICAgICogXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBib2R5LiBUaGlzIGlzIHRoZSBzZWNvbmQgbW9tZW50IG9mIGFyZWEgaW4gdHdvIGRpbWVuc2lvbnMuXG4gICAgICogXG4gICAgICogQ2FuIGJlIG1hbnVhbGx5IHNldCB0byBgSW5maW5pdHlgIHRvIHByZXZlbnQgcm90YXRpb24gb2YgdGhlIGJvZHkuIFNlZSBgQm9keS5zZXRJbmVydGlhYC5cbiAgICAgKiBcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgaW5lcnRpYVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIEF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCB3aGVuIHZlcnRpY2VzLCBtYXNzIG9yIGRlbnNpdHkgYXJlIHNldCBvciBjYWxjdWxhdGVkIGJ5IGBCb2R5LnNldEluZXJ0aWFgLlxuICAgICAqIFxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBpbnZlcnNlIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBib2R5IChgMSAvIGluZXJ0aWFgKS5cbiAgICAgKiBcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgaW52ZXJzZUluZXJ0aWFcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSByZXN0aXR1dGlvbiAoZWxhc3RpY2l0eSkgb2YgdGhlIGJvZHkuIFRoZSB2YWx1ZSBpcyBhbHdheXMgcG9zaXRpdmUgYW5kIGlzIGluIHRoZSByYW5nZSBgKDAsIDEpYC5cbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyBjb2xsaXNpb25zIG1heSBiZSBwZXJmZWN0bHkgaW5lbGFzdGljIGFuZCBubyBib3VuY2luZyBtYXkgb2NjdXIuIFxuICAgICAqIEEgdmFsdWUgb2YgYDAuOGAgbWVhbnMgdGhlIGJvZHkgbWF5IGJvdW5jZSBiYWNrIHdpdGggYXBwcm94aW1hdGVseSA4MCUgb2YgaXRzIGtpbmV0aWMgZW5lcmd5LlxuICAgICAqIE5vdGUgdGhhdCBjb2xsaXNpb24gcmVzcG9uc2UgaXMgYmFzZWQgb24gX3BhaXJzXyBvZiBib2RpZXMsIGFuZCB0aGF0IGByZXN0aXR1dGlvbmAgdmFsdWVzIGFyZSBfY29tYmluZWRfIHdpdGggdGhlIGZvbGxvd2luZyBmb3JtdWxhOlxuICAgICAqXG4gICAgICogYE1hdGgubWF4KGJvZHlBLnJlc3RpdHV0aW9uLCBib2R5Qi5yZXN0aXR1dGlvbilgXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgZnJpY3Rpb24gb2YgdGhlIGJvZHkuIFRoZSB2YWx1ZSBpcyBhbHdheXMgcG9zaXRpdmUgYW5kIGlzIGluIHRoZSByYW5nZSBgKDAsIDEpYC5cbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyB0aGF0IHRoZSBib2R5IG1heSBzbGlkZSBpbmRlZmluaXRlbHkuXG4gICAgICogQSB2YWx1ZSBvZiBgMWAgbWVhbnMgdGhlIGJvZHkgbWF5IGNvbWUgdG8gYSBzdG9wIGFsbW9zdCBpbnN0YW50bHkgYWZ0ZXIgYSBmb3JjZSBpcyBhcHBsaWVkLlxuICAgICAqXG4gICAgICogVGhlIGVmZmVjdHMgb2YgdGhlIHZhbHVlIG1heSBiZSBub24tbGluZWFyLiBcbiAgICAgKiBIaWdoIHZhbHVlcyBtYXkgYmUgdW5zdGFibGUgZGVwZW5kaW5nIG9uIHRoZSBib2R5LlxuICAgICAqIFRoZSBlbmdpbmUgdXNlcyBhIENvdWxvbWIgZnJpY3Rpb24gbW9kZWwgaW5jbHVkaW5nIHN0YXRpYyBhbmQga2luZXRpYyBmcmljdGlvbi5cbiAgICAgKiBOb3RlIHRoYXQgY29sbGlzaW9uIHJlc3BvbnNlIGlzIGJhc2VkIG9uIF9wYWlyc18gb2YgYm9kaWVzLCBhbmQgdGhhdCBgZnJpY3Rpb25gIHZhbHVlcyBhcmUgX2NvbWJpbmVkXyB3aXRoIHRoZSBmb2xsb3dpbmcgZm9ybXVsYTpcbiAgICAgKlxuICAgICAqIGBNYXRoLm1pbihib2R5QS5mcmljdGlvbiwgYm9keUIuZnJpY3Rpb24pYFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgc3RhdGljIGZyaWN0aW9uIG9mIHRoZSBib2R5IChpbiB0aGUgQ291bG9tYiBmcmljdGlvbiBtb2RlbCkuIFxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoZSBib2R5IHdpbGwgbmV2ZXIgJ3N0aWNrJyB3aGVuIGl0IGlzIG5lYXJseSBzdGF0aW9uYXJ5IGFuZCBvbmx5IGR5bmFtaWMgYGZyaWN0aW9uYCBpcyB1c2VkLlxuICAgICAqIFRoZSBoaWdoZXIgdGhlIHZhbHVlIChlLmcuIGAxMGApLCB0aGUgbW9yZSBmb3JjZSBpdCB3aWxsIHRha2UgdG8gaW5pdGlhbGx5IGdldCB0aGUgYm9keSBtb3Zpbmcgd2hlbiBuZWFybHkgc3RhdGlvbmFyeS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIG11bHRpcGxpZWQgd2l0aCB0aGUgYGZyaWN0aW9uYCBwcm9wZXJ0eSB0byBtYWtlIGl0IGVhc2llciB0byBjaGFuZ2UgYGZyaWN0aW9uYCBhbmQgbWFpbnRhaW4gYW4gYXBwcm9wcmlhdGUgYW1vdW50IG9mIHN0YXRpYyBmcmljdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0YXRpY1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuNVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGFpciBmcmljdGlvbiBvZiB0aGUgYm9keSAoYWlyIHJlc2lzdGFuY2UpLiBcbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBtZWFucyB0aGUgYm9keSB3aWxsIG5ldmVyIHNsb3cgYXMgaXQgbW92ZXMgdGhyb3VnaCBzcGFjZS5cbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGZhc3RlciBhIGJvZHkgc2xvd3Mgd2hlbiBtb3ZpbmcgdGhyb3VnaCBzcGFjZS5cbiAgICAgKiBUaGUgZWZmZWN0cyBvZiB0aGUgdmFsdWUgYXJlIG5vbi1saW5lYXIuIFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uQWlyXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBmaWx0ZXJpbmcgcHJvcGVydGllcyBvZiB0aGlzIGJvZHkuXG4gICAgICpcbiAgICAgKiBDb2xsaXNpb25zIGJldHdlZW4gdHdvIGJvZGllcyB3aWxsIG9iZXkgdGhlIGZvbGxvd2luZyBydWxlczpcbiAgICAgKiAtIElmIHRoZSB0d28gYm9kaWVzIGhhdmUgdGhlIHNhbWUgbm9uLXplcm8gdmFsdWUgb2YgYGNvbGxpc2lvbkZpbHRlci5ncm91cGAsXG4gICAgICogICB0aGV5IHdpbGwgYWx3YXlzIGNvbGxpZGUgaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlLCBhbmQgdGhleSB3aWxsIG5ldmVyIGNvbGxpZGVcbiAgICAgKiAgIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZS5cbiAgICAgKiAtIElmIHRoZSB0d28gYm9kaWVzIGhhdmUgZGlmZmVyZW50IHZhbHVlcyBvZiBgY29sbGlzaW9uRmlsdGVyLmdyb3VwYCBvciBpZiBvbmVcbiAgICAgKiAgIChvciBib3RoKSBvZiB0aGUgYm9kaWVzIGhhcyBhIHZhbHVlIG9mIDAsIHRoZW4gdGhlIGNhdGVnb3J5L21hc2sgcnVsZXMgYXBwbHkgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIEVhY2ggYm9keSBiZWxvbmdzIHRvIGEgY29sbGlzaW9uIGNhdGVnb3J5LCBnaXZlbiBieSBgY29sbGlzaW9uRmlsdGVyLmNhdGVnb3J5YC4gVGhpc1xuICAgICAqIHZhbHVlIGlzIHVzZWQgYXMgYSBiaXQgZmllbGQgYW5kIHRoZSBjYXRlZ29yeSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBiaXQgc2V0LCBtZWFuaW5nIHRoYXRcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBhIHBvd2VyIG9mIHR3byBpbiB0aGUgcmFuZ2UgWzEsIDJeMzFdLiBUaHVzLCB0aGVyZSBhcmUgMzJcbiAgICAgKiBkaWZmZXJlbnQgY29sbGlzaW9uIGNhdGVnb3JpZXMgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogRWFjaCBib2R5IGFsc28gZGVmaW5lcyBhIGNvbGxpc2lvbiBiaXRtYXNrLCBnaXZlbiBieSBgY29sbGlzaW9uRmlsdGVyLm1hc2tgIHdoaWNoIHNwZWNpZmllc1xuICAgICAqIHRoZSBjYXRlZ29yaWVzIGl0IGNvbGxpZGVzIHdpdGggKHRoZSB2YWx1ZSBpcyB0aGUgYml0d2lzZSBBTkQgdmFsdWUgb2YgYWxsIHRoZXNlIGNhdGVnb3JpZXMpLlxuICAgICAqXG4gICAgICogVXNpbmcgdGhlIGNhdGVnb3J5L21hc2sgcnVsZXMsIHR3byBib2RpZXMgYEFgIGFuZCBgQmAgY29sbGlkZSBpZiBlYWNoIGluY2x1ZGVzIHRoZSBvdGhlcidzXG4gICAgICogY2F0ZWdvcnkgaW4gaXRzIG1hc2ssIGkuZS4gYChjYXRlZ29yeUEgJiBtYXNrQikgIT09IDBgIGFuZCBgKGNhdGVnb3J5QiAmIG1hc2tBKSAhPT0gMGBcbiAgICAgKiBhcmUgYm90aCB0cnVlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlclxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gSW50ZWdlciBgTnVtYmVyYCwgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBncm91cCB0aGlzIGJvZHkgYmVsb25ncyB0by5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25GaWx0ZXIuZ3JvdXBcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGJpdCBmaWVsZCB0aGF0IHNwZWNpZmllcyB0aGUgY29sbGlzaW9uIGNhdGVnb3J5IHRoaXMgYm9keSBiZWxvbmdzIHRvLlxuICAgICAqIFRoZSBjYXRlZ29yeSB2YWx1ZSBzaG91bGQgaGF2ZSBvbmx5IG9uZSBiaXQgc2V0LCBmb3IgZXhhbXBsZSBgMHgwMDAxYC5cbiAgICAgKiBUaGlzIG1lYW5zIHRoZXJlIGFyZSB1cCB0byAzMiB1bmlxdWUgY29sbGlzaW9uIGNhdGVnb3JpZXMgYXZhaWxhYmxlLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5jYXRlZ29yeVxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYml0IG1hc2sgdGhhdCBzcGVjaWZpZXMgdGhlIGNvbGxpc2lvbiBjYXRlZ29yaWVzIHRoaXMgYm9keSBtYXkgY29sbGlkZSB3aXRoLlxuICAgICAqIFNlZSBgYm9keS5jb2xsaXNpb25GaWx0ZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGNvbGxpc2lvbkZpbHRlci5tYXNrXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgYSB0aGluIGJvdW5kYXJ5IGFyb3VuZCB0aGUgYm9keSB3aGVyZSBpdCBpcyBhbGxvd2VkIHRvIHNsaWdodGx5IHNpbmsgaW50byBvdGhlciBib2RpZXMuXG4gICAgICogXG4gICAgICogVGhpcyBpcyByZXF1aXJlZCBmb3IgcHJvcGVyIGNvbGxpc2lvbiByZXNwb25zZSwgaW5jbHVkaW5nIGZyaWN0aW9uIGFuZCByZXN0aXR1dGlvbiBlZmZlY3RzLlxuICAgICAqIFxuICAgICAqIFRoZSBkZWZhdWx0IHNob3VsZCBnZW5lcmFsbHkgc3VmZmljZSBpbiBtb3N0IGNhc2VzLiBZb3UgbWF5IG5lZWQgdG8gZGVjcmVhc2UgdGhpcyB2YWx1ZSBmb3IgdmVyeSBzbWFsbCBib2RpZXMgdGhhdCBhcmUgbmVhcmluZyB0aGUgZGVmYXVsdCB2YWx1ZSBpbiBzY2FsZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzbG9wXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4wNVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyBwZXItYm9keSB0aW1lIHNjYWxpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGltZVNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogX1JlYWQgb25seV8uIFVwZGF0ZWQgZHVyaW5nIGVuZ2luZSB1cGRhdGUuXG4gICAgICogXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHJlY29yZHMgdGhlIGxhc3QgZGVsdGEgdGltZSB2YWx1ZSB1c2VkIHRvIHVwZGF0ZSB0aGlzIGJvZHkuXG4gICAgICogVXNlZCB0byBjYWxjdWxhdGUgc3BlZWQgYW5kIHZlbG9jaXR5LlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IGRlbHRhVGltZVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDEwMDAgLyA2MFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgcHJvcGVydGllcyB0byBiZSBjb25zdW1lZCBieSB0aGUgbW9kdWxlIGBNYXR0ZXIuUmVuZGVyYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgYm9keSBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnZpc2libGVcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3BhY2l0eSB0byB1c2Ugd2hlbiByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLm9wYWNpdHlcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgZGVmaW5lcyB0aGUgc3ByaXRlIHByb3BlcnRpZXMgdG8gdXNlIHdoZW4gcmVuZGVyaW5nLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnNwcml0ZVxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYFN0cmluZ2AgdGhhdCBkZWZpbmVzIHRoZSBwYXRoIHRvIHRoZSBpbWFnZSB0byB1c2UgYXMgdGhlIHNwcml0ZSB0ZXh0dXJlLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnNwcml0ZS50ZXh0dXJlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgIFxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBzY2FsaW5nIGluIHRoZSB4LWF4aXMgZm9yIHRoZSBzcHJpdGUsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnhTY2FsZVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBzY2FsaW5nIGluIHRoZSB5LWF4aXMgZm9yIHRoZSBzcHJpdGUsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnlTY2FsZVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAgKiBBIGBOdW1iZXJgIHRoYXQgZGVmaW5lcyB0aGUgb2Zmc2V0IGluIHRoZSB4LWF4aXMgZm9yIHRoZSBzcHJpdGUgKG5vcm1hbGlzZWQgYnkgdGV4dHVyZSB3aWR0aCkuXG4gICAgICAqXG4gICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3ByaXRlLnhPZmZzZXRcbiAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICovXG5cbiAgICAvKipcbiAgICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIG9mZnNldCBpbiB0aGUgeS1heGlzIGZvciB0aGUgc3ByaXRlIChub3JtYWxpc2VkIGJ5IHRleHR1cmUgaGVpZ2h0KS5cbiAgICAgICpcbiAgICAgICogQHByb3BlcnR5IHJlbmRlci5zcHJpdGUueU9mZnNldFxuICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICogQGRlZmF1bHQgMFxuICAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBkZWZpbmVzIHRoZSBsaW5lIHdpZHRoIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgYm9keSBvdXRsaW5lIChpZiBhIHNwcml0ZSBpcyBub3QgZGVmaW5lZCkuXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgbm8gb3V0bGluZSB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5saW5lV2lkdGhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgZmlsbCBzdHlsZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgKGlmIGEgc3ByaXRlIGlzIG5vdCBkZWZpbmVkKS5cbiAgICAgKiBJdCBpcyB0aGUgc2FtZSBhcyB3aGVuIHVzaW5nIGEgY2FudmFzLCBzbyBpdCBhY2NlcHRzIENTUyBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLmZpbGxTdHlsZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0IGEgcmFuZG9tIGNvbG91clxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgU3RyaW5nYCB0aGF0IGRlZmluZXMgdGhlIHN0cm9rZSBzdHlsZSB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGJvZHkgb3V0bGluZSAoaWYgYSBzcHJpdGUgaXMgbm90IGRlZmluZWQpLlxuICAgICAqIEl0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdXNpbmcgYSBjYW52YXMsIHNvIGl0IGFjY2VwdHMgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3Ryb2tlU3R5bGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBDYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB2ZXJ0aWNlcyBhcmUgc2V0LlxuICAgICAqIFxuICAgICAqIEFuIGFycmF5IG9mIHVuaXF1ZSBheGlzIHZlY3RvcnMgKGVkZ2Ugbm9ybWFscykgdXNlZCBmb3IgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAgICAgKiBUaGVzZSBhcmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIHdoZW4gdmVydGljZXMgYXJlIHNldC5cbiAgICAgKiBUaGV5IGFyZSBjb25zdGFudGx5IHVwZGF0ZWQgYnkgYEJvZHkudXBkYXRlYCBkdXJpbmcgdGhlIHNpbXVsYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkgYXhlc1xuICAgICAqIEB0eXBlIHZlY3RvcltdXG4gICAgICovXG4gICAgIFxuICAgIC8qKlxuICAgICAqIF9SZWFkIG9ubHlfLiBDYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB2ZXJ0aWNlcyBhcmUgc2V0LlxuICAgICAqIFxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBtZWFzdXJlcyB0aGUgYXJlYSBvZiB0aGUgYm9keSdzIGNvbnZleCBodWxsLlxuICAgICAqIFxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSBhcmVhXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBCb3VuZHNgIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIEFBQkIgcmVnaW9uIGZvciB0aGUgYm9keS5cbiAgICAgKiBJdCBpcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgd2hlbiB2ZXJ0aWNlcyBhcmUgc2V0IGFuZCBjb25zdGFudGx5IHVwZGF0ZWQgYnkgYEJvZHkudXBkYXRlYCBkdXJpbmcgc2ltdWxhdGlvbi5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzXG4gICAgICogQHR5cGUgYm91bmRzXG4gICAgICovXG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5FdmVudHNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIHRvIGZpcmUgYW5kIGxpc3RlbiB0byBldmVudHMgb24gb3RoZXIgb2JqZWN0cy5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIEV2ZW50c1xuKi9cblxudmFyIEV2ZW50cyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50cztcblxudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byB0aGUgZ2l2ZW4gb2JqZWN0J3MgYGV2ZW50TmFtZWAuXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgRXZlbnRzLm9uID0gZnVuY3Rpb24ob2JqZWN0LCBldmVudE5hbWVzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbmFtZXMgPSBldmVudE5hbWVzLnNwbGl0KCcgJyksXG4gICAgICAgICAgICBuYW1lO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIG9iamVjdC5ldmVudHMgPSBvYmplY3QuZXZlbnRzIHx8IHt9O1xuICAgICAgICAgICAgb2JqZWN0LmV2ZW50c1tuYW1lXSA9IG9iamVjdC5ldmVudHNbbmFtZV0gfHwgW107XG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBldmVudCBjYWxsYmFjay4gSWYgbm8gY2FsbGJhY2ssIGNsZWFycyBhbGwgY2FsbGJhY2tzIGluIGBldmVudE5hbWVzYC4gSWYgbm8gYGV2ZW50TmFtZXNgLCBjbGVhcnMgYWxsIGV2ZW50cy5cbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgRXZlbnRzLm9mZiA9IGZ1bmN0aW9uKG9iamVjdCwgZXZlbnROYW1lcywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFldmVudE5hbWVzKSB7XG4gICAgICAgICAgICBvYmplY3QuZXZlbnRzID0ge307XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgRXZlbnRzLm9mZihvYmplY3QsIGNhbGxiYWNrKVxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXZlbnROYW1lcztcbiAgICAgICAgICAgIGV2ZW50TmFtZXMgPSBDb21tb24ua2V5cyhvYmplY3QuZXZlbnRzKS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZXMgPSBldmVudE5hbWVzLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IG9iamVjdC5ldmVudHNbbmFtZXNbaV1dLFxuICAgICAgICAgICAgICAgIG5ld0NhbGxiYWNrcyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tqXSAhPT0gY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxsYmFja3MucHVzaChjYWxsYmFja3Nbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqZWN0LmV2ZW50c1tuYW1lc1tpXV0gPSBuZXdDYWxsYmFja3M7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgYWxsIHRoZSBjYWxsYmFja3Mgc3Vic2NyaWJlZCB0byB0aGUgZ2l2ZW4gb2JqZWN0J3MgYGV2ZW50TmFtZWAsIGluIHRoZSBvcmRlciB0aGV5IHN1YnNjcmliZWQsIGlmIGFueS5cbiAgICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZXNcbiAgICAgKiBAcGFyYW0ge30gZXZlbnRcbiAgICAgKi9cbiAgICBFdmVudHMudHJpZ2dlciA9IGZ1bmN0aW9uKG9iamVjdCwgZXZlbnROYW1lcywgZXZlbnQpIHtcbiAgICAgICAgdmFyIG5hbWVzLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGNhbGxiYWNrcyxcbiAgICAgICAgICAgIGV2ZW50Q2xvbmU7XG5cbiAgICAgICAgdmFyIGV2ZW50cyA9IG9iamVjdC5ldmVudHM7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXZlbnRzICYmIENvbW1vbi5rZXlzKGV2ZW50cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFldmVudClcbiAgICAgICAgICAgICAgICBldmVudCA9IHt9O1xuXG4gICAgICAgICAgICBuYW1lcyA9IGV2ZW50TmFtZXMuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBldmVudHNbbmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q2xvbmUgPSBDb21tb24uY2xvbmUoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDbG9uZS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDbG9uZS5zb3VyY2UgPSBvYmplY3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tqXS5hcHBseShvYmplY3QsIFtldmVudENsb25lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogQSBjb21wb3NpdGUgaXMgYSBjb2xsZWN0aW9uIG9mIGBNYXR0ZXIuQm9keWAsIGBNYXR0ZXIuQ29uc3RyYWludGAgYW5kIG90aGVyIGBNYXR0ZXIuQ29tcG9zaXRlYCBvYmplY3RzLlxuKlxuKiBUaGV5IGFyZSBhIGNvbnRhaW5lciB0aGF0IGNhbiByZXByZXNlbnQgY29tcGxleCBvYmplY3RzIG1hZGUgb2YgbXVsdGlwbGUgcGFydHMsIGV2ZW4gaWYgdGhleSBhcmUgbm90IHBoeXNpY2FsbHkgY29ubmVjdGVkLlxuKiBBIGNvbXBvc2l0ZSBjb3VsZCBjb250YWluIGFueXRoaW5nIGZyb20gYSBzaW5nbGUgYm9keSBhbGwgdGhlIHdheSB1cCB0byBhIHdob2xlIHdvcmxkLlxuKiBcbiogV2hlbiBtYWtpbmcgYW55IGNoYW5nZXMgdG8gY29tcG9zaXRlcywgdXNlIHRoZSBpbmNsdWRlZCBmdW5jdGlvbnMgcmF0aGVyIHRoYW4gY2hhbmdpbmcgdGhlaXIgcHJvcGVydGllcyBkaXJlY3RseS5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIENvbXBvc2l0ZVxuKi9cblxudmFyIENvbXBvc2l0ZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0ZTtcblxudmFyIEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBCb3VuZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEJvZHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBvc2l0ZS4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJpdGVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBDb21tb24uZXh0ZW5kKHsgXG4gICAgICAgICAgICBpZDogQ29tbW9uLm5leHRJZCgpLFxuICAgICAgICAgICAgdHlwZTogJ2NvbXBvc2l0ZScsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBpc01vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIGJvZGllczogW10sIFxuICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLCBcbiAgICAgICAgICAgIGNvbXBvc2l0ZXM6IFtdLFxuICAgICAgICAgICAgbGFiZWw6ICdDb21wb3NpdGUnLFxuICAgICAgICAgICAgcGx1Z2luOiB7fSxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgYWxsQm9kaWVzOiBudWxsLFxuICAgICAgICAgICAgICAgIGFsbENvbnN0cmFpbnRzOiBudWxsLFxuICAgICAgICAgICAgICAgIGFsbENvbXBvc2l0ZXM6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXBvc2l0ZSdzIGBpc01vZGlmaWVkYCBmbGFnLiBcbiAgICAgKiBJZiBgdXBkYXRlUGFyZW50c2AgaXMgdHJ1ZSwgYWxsIHBhcmVudHMgd2lsbCBiZSBzZXQgKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICAgKiBJZiBgdXBkYXRlQ2hpbGRyZW5gIGlzIHRydWUsIGFsbCBjaGlsZHJlbiB3aWxsIGJlIHNldCAoZGVmYXVsdDogZmFsc2UpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBzZXRNb2RpZmllZFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTW9kaWZpZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGVQYXJlbnRzPWZhbHNlXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZUNoaWxkcmVuPWZhbHNlXVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgaXNNb2RpZmllZCwgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pIHtcbiAgICAgICAgY29tcG9zaXRlLmlzTW9kaWZpZWQgPSBpc01vZGlmaWVkO1xuXG4gICAgICAgIGlmIChpc01vZGlmaWVkICYmIGNvbXBvc2l0ZS5jYWNoZSkge1xuICAgICAgICAgICAgY29tcG9zaXRlLmNhY2hlLmFsbEJvZGllcyA9IG51bGw7XG4gICAgICAgICAgICBjb21wb3NpdGUuY2FjaGUuYWxsQ29uc3RyYWludHMgPSBudWxsO1xuICAgICAgICAgICAgY29tcG9zaXRlLmNhY2hlLmFsbENvbXBvc2l0ZXMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZVBhcmVudHMgJiYgY29tcG9zaXRlLnBhcmVudCkge1xuICAgICAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZS5wYXJlbnQsIGlzTW9kaWZpZWQsIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVDaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZENvbXBvc2l0ZSA9IGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldO1xuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjaGlsZENvbXBvc2l0ZSwgaXNNb2RpZmllZCwgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyaWMgc2luZ2xlIG9yIG11bHRpLWFkZCBmdW5jdGlvbi4gQWRkcyBhIHNpbmdsZSBvciBhbiBhcnJheSBvZiBib2R5KHMpLCBjb25zdHJhaW50KHMpIG9yIGNvbXBvc2l0ZShzKSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIFRyaWdnZXJzIGBiZWZvcmVBZGRgIGFuZCBgYWZ0ZXJBZGRgIGV2ZW50cyBvbiB0aGUgYGNvbXBvc2l0ZWAuXG4gICAgICogQG1ldGhvZCBhZGRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R8YXJyYXl9IG9iamVjdCBBIHNpbmdsZSBvciBhbiBhcnJheSBvZiBib2R5KHMpLCBjb25zdHJhaW50KHMpIG9yIGNvbXBvc2l0ZShzKVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBvYmplY3RzIGFkZGVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFkZCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgb2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmplY3RzID0gW10uY29uY2F0KG9iamVjdCk7XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoY29tcG9zaXRlLCAnYmVmb3JlQWRkJywgeyBvYmplY3Q6IG9iamVjdCB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzW2ldO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIC8vIHNraXAgYWRkaW5nIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgICAgICAgICAgaWYgKG9iai5wYXJlbnQgIT09IG9iaikge1xuICAgICAgICAgICAgICAgICAgICBDb21tb24ud2FybignQ29tcG9zaXRlLmFkZDogc2tpcHBlZCBhZGRpbmcgYSBjb21wb3VuZCBib2R5IHBhcnQgKHlvdSBtdXN0IGFkZCBpdHMgcGFyZW50IGluc3RlYWQpJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KGNvbXBvc2l0ZSwgb2JqKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbXBvc2l0ZSc6XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbXBvc2l0ZShjb21wb3NpdGUsIG9iaik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZUNvbnN0cmFpbnQnOlxuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgb2JqLmNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdhZnRlckFkZCcsIHsgb2JqZWN0OiBvYmplY3QgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJpYyByZW1vdmUgZnVuY3Rpb24uIFJlbW92ZXMgb25lIG9yIG1hbnkgYm9keShzKSwgY29uc3RyYWludChzKSBvciBhIGNvbXBvc2l0ZShzKSB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIE9wdGlvbmFsbHkgc2VhcmNoaW5nIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseS5cbiAgICAgKiBUcmlnZ2VycyBgYmVmb3JlUmVtb3ZlYCBhbmQgYGFmdGVyUmVtb3ZlYCBldmVudHMgb24gdGhlIGBjb21wb3NpdGVgLlxuICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBvYmplY3RzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBDb21wb3NpdGUucmVtb3ZlID0gZnVuY3Rpb24oY29tcG9zaXRlLCBvYmplY3QsIGRlZXApIHtcbiAgICAgICAgdmFyIG9iamVjdHMgPSBbXS5jb25jYXQob2JqZWN0KTtcblxuICAgICAgICBFdmVudHMudHJpZ2dlcihjb21wb3NpdGUsICdiZWZvcmVSZW1vdmUnLCB7IG9iamVjdDogb2JqZWN0IH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9iaiA9IG9iamVjdHNbaV07XG5cbiAgICAgICAgICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcblxuICAgICAgICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUJvZHkoY29tcG9zaXRlLCBvYmosIGRlZXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29uc3RyYWludCc6XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnQoY29tcG9zaXRlLCBvYmosIGRlZXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tcG9zaXRlJzpcbiAgICAgICAgICAgICAgICBDb21wb3NpdGUucmVtb3ZlQ29tcG9zaXRlKGNvbXBvc2l0ZSwgb2JqLCBkZWVwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlQ29uc3RyYWludCc6XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnQoY29tcG9zaXRlLCBvYmouY29uc3RyYWludCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGNvbXBvc2l0ZSwgJ2FmdGVyUmVtb3ZlJywgeyBvYmplY3Q6IG9iamVjdCB9KTtcblxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29tcG9zaXRlIHRvIHRoZSBnaXZlbiBjb21wb3NpdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGFkZENvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVBXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZUJcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGVBIHdpdGggdGhlIG9iamVjdHMgZnJvbSBjb21wb3NpdGVCIGFkZGVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFkZENvbXBvc2l0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZUEsIGNvbXBvc2l0ZUIpIHtcbiAgICAgICAgY29tcG9zaXRlQS5jb21wb3NpdGVzLnB1c2goY29tcG9zaXRlQik7XG4gICAgICAgIGNvbXBvc2l0ZUIucGFyZW50ID0gY29tcG9zaXRlQTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZUEsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb21wb3NpdGUgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBhbmQgb3B0aW9uYWxseSBzZWFyY2hpbmcgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCByZW1vdmVDb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlQVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVCXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGVBIHdpdGggdGhlIGNvbXBvc2l0ZSByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZUEsIGNvbXBvc2l0ZUIsIGRlZXApIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gQ29tbW9uLmluZGV4T2YoY29tcG9zaXRlQS5jb21wb3NpdGVzLCBjb21wb3NpdGVCKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZUF0KGNvbXBvc2l0ZUEsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZUEuY29tcG9zaXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbXBvc2l0ZShjb21wb3NpdGVBLmNvbXBvc2l0ZXNbaV0sIGNvbXBvc2l0ZUIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb21wb3NpdGUgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCByZW1vdmVDb21wb3NpdGVBdFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgY29tcG9zaXRlIHJlbW92ZWRcbiAgICAgKi9cbiAgICBDb21wb3NpdGUucmVtb3ZlQ29tcG9zaXRlQXQgPSBmdW5jdGlvbihjb21wb3NpdGUsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbXBvc2l0ZS5jb21wb3NpdGVzLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGJvZHkgdG8gdGhlIGdpdmVuIGNvbXBvc2l0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgYm9keSBhZGRlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hZGRCb2R5ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBib2R5KSB7XG4gICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMucHVzaChib2R5KTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgYm9keSBmcm9tIHRoZSBnaXZlbiBjb21wb3NpdGUsIGFuZCBvcHRpb25hbGx5IHNlYXJjaGluZyBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUJvZHlcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IFRoZSBvcmlnaW5hbCBjb21wb3NpdGUgd2l0aCB0aGUgYm9keSByZW1vdmVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnJlbW92ZUJvZHkgPSBmdW5jdGlvbihjb21wb3NpdGUsIGJvZHksIGRlZXApIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gQ29tbW9uLmluZGV4T2YoY29tcG9zaXRlLmJvZGllcywgYm9keSk7XG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5QXQoY29tcG9zaXRlLCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUJvZHkoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0sIGJvZHksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCByZW1vdmVCb2R5QXRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGJvZHkgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVCb2R5QXQgPSBmdW5jdGlvbihjb21wb3NpdGUsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbXBvc2l0ZS5ib2RpZXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgQ29tcG9zaXRlLnNldE1vZGlmaWVkKGNvbXBvc2l0ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29uc3RyYWludCB0byB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gVGhlIG9yaWdpbmFsIGNvbXBvc2l0ZSB3aXRoIHRoZSBjb25zdHJhaW50IGFkZGVkXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjb21wb3NpdGUsIGNvbnN0cmFpbnQpIHtcbiAgICAgICAgY29tcG9zaXRlLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG4gICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZChjb21wb3NpdGUsIHRydWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbnN0cmFpbnQgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBhbmQgb3B0aW9uYWxseSBzZWFyY2hpbmcgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGNvbnN0cmFpbnQgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oY29tcG9zaXRlLCBjb25zdHJhaW50LCBkZWVwKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IENvbW1vbi5pbmRleE9mKGNvbXBvc2l0ZS5jb25zdHJhaW50cywgY29uc3RyYWludCk7XG4gICAgICAgIGlmIChwb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50QXQoY29tcG9zaXRlLCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLnJlbW92ZUNvbnN0cmFpbnQoY29tcG9zaXRlLmNvbXBvc2l0ZXNbaV0sIGNvbnN0cmFpbnQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50QXRcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgb3JpZ2luYWwgY29tcG9zaXRlIHdpdGggdGhlIGNvbnN0cmFpbnQgcmVtb3ZlZFxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZW1vdmVDb25zdHJhaW50QXQgPSBmdW5jdGlvbihjb21wb3NpdGUsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbXBvc2l0ZS5jb25zdHJhaW50cy5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGJvZGllcywgY29uc3RyYWludHMgYW5kIGNvbXBvc2l0ZXMgZnJvbSB0aGUgZ2l2ZW4gY29tcG9zaXRlLlxuICAgICAqIE9wdGlvbmFsbHkgY2xlYXJpbmcgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBrZWVwU3RhdGljXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV1cbiAgICAgKi9cbiAgICBDb21wb3NpdGUuY2xlYXIgPSBmdW5jdGlvbihjb21wb3NpdGUsIGtlZXBTdGF0aWMsIGRlZXApIHtcbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5jbGVhcihjb21wb3NpdGUuY29tcG9zaXRlc1tpXSwga2VlcFN0YXRpYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChrZWVwU3RhdGljKSB7XG4gICAgICAgICAgICBjb21wb3NpdGUuYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcy5maWx0ZXIoZnVuY3Rpb24oYm9keSkgeyByZXR1cm4gYm9keS5pc1N0YXRpYzsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb3NpdGUuYm9kaWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb3NpdGUuY29uc3RyYWludHMubGVuZ3RoID0gMDtcbiAgICAgICAgY29tcG9zaXRlLmNvbXBvc2l0ZXMubGVuZ3RoID0gMDtcblxuICAgICAgICBDb21wb3NpdGUuc2V0TW9kaWZpZWQoY29tcG9zaXRlLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIGluIHRoZSBnaXZlbiBjb21wb3NpdGUsIGluY2x1ZGluZyBhbGwgYm9kaWVzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBhbGxCb2RpZXNcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Ym9keVtdfSBBbGwgdGhlIGJvZGllc1xuICAgICAqL1xuICAgIENvbXBvc2l0ZS5hbGxCb2RpZXMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZS5jYWNoZSAmJiBjb21wb3NpdGUuY2FjaGUuYWxsQm9kaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9zaXRlLmNhY2hlLmFsbEJvZGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib2RpZXMgPSBbXS5jb25jYXQoY29tcG9zaXRlLmJvZGllcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGJvZGllcyA9IGJvZGllcy5jb25jYXQoQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUuY29tcG9zaXRlc1tpXSkpO1xuXG4gICAgICAgIGlmIChjb21wb3NpdGUuY2FjaGUpIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5jYWNoZS5hbGxCb2RpZXMgPSBib2RpZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9kaWVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjb25zdHJhaW50cyBpbiB0aGUgZ2l2ZW4gY29tcG9zaXRlLCBpbmNsdWRpbmcgYWxsIGNvbnN0cmFpbnRzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBhbGxDb25zdHJhaW50c1xuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcmV0dXJuIHtjb25zdHJhaW50W119IEFsbCB0aGUgY29uc3RyYWludHNcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZS5jYWNoZSAmJiBjb21wb3NpdGUuY2FjaGUuYWxsQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wb3NpdGUuY2FjaGUuYWxsQ29uc3RyYWludHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29uc3RyYWludHMgPSBbXS5jb25jYXQoY29tcG9zaXRlLmNvbnN0cmFpbnRzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvc2l0ZS5jb21wb3NpdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5jb25jYXQoQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKGNvbXBvc2l0ZS5jb21wb3NpdGVzW2ldKSk7XG5cbiAgICAgICAgaWYgKGNvbXBvc2l0ZS5jYWNoZSkge1xuICAgICAgICAgICAgY29tcG9zaXRlLmNhY2hlLmFsbENvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNvbXBvc2l0ZXMgaW4gdGhlIGdpdmVuIGNvbXBvc2l0ZSwgaW5jbHVkaW5nIGFsbCBjb21wb3NpdGVzIGluIGl0cyBjaGlsZHJlbiwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCBhbGxDb21wb3NpdGVzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZVtdfSBBbGwgdGhlIGNvbXBvc2l0ZXNcbiAgICAgKi9cbiAgICBDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSkge1xuICAgICAgICBpZiAoY29tcG9zaXRlLmNhY2hlICYmIGNvbXBvc2l0ZS5jYWNoZS5hbGxDb21wb3NpdGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9zaXRlLmNhY2hlLmFsbENvbXBvc2l0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcG9zaXRlcyA9IFtdLmNvbmNhdChjb21wb3NpdGUuY29tcG9zaXRlcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb3NpdGUuY29tcG9zaXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbXBvc2l0ZXMgPSBjb21wb3NpdGVzLmNvbmNhdChDb21wb3NpdGUuYWxsQ29tcG9zaXRlcyhjb21wb3NpdGUuY29tcG9zaXRlc1tpXSkpO1xuXG4gICAgICAgIGlmIChjb21wb3NpdGUuY2FjaGUpIHtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS5jYWNoZS5hbGxDb21wb3NpdGVzID0gY29tcG9zaXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aGUgY29tcG9zaXRlIHJlY3Vyc2l2ZWx5IGZvciBhbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHR5cGUgYW5kIGlkIHN1cHBsaWVkLCBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHJlcXVlc3RlZCBvYmplY3QsIGlmIGZvdW5kXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmdldCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgaWQsIHR5cGUpIHtcbiAgICAgICAgdmFyIG9iamVjdHMsXG4gICAgICAgICAgICBvYmplY3Q7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgb2JqZWN0cyA9IENvbXBvc2l0ZS5hbGxCb2RpZXMoY29tcG9zaXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb25zdHJhaW50JzpcbiAgICAgICAgICAgIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMoY29tcG9zaXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb21wb3NpdGUnOlxuICAgICAgICAgICAgb2JqZWN0cyA9IENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzKGNvbXBvc2l0ZSkuY29uY2F0KGNvbXBvc2l0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqZWN0cylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIG9iamVjdCA9IG9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkgeyBcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuaWQudG9TdHJpbmcoKSA9PT0gaWQudG9TdHJpbmcoKTsgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmplY3QubGVuZ3RoID09PSAwID8gbnVsbCA6IG9iamVjdFswXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGdpdmVuIG9iamVjdChzKSBmcm9tIGNvbXBvc2l0ZUEgdG8gY29tcG9zaXRlQiAoZXF1YWwgdG8gYSByZW1vdmUgZm9sbG93ZWQgYnkgYW4gYWRkKS5cbiAgICAgKiBAbWV0aG9kIG1vdmVcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZUF9IGNvbXBvc2l0ZUFcbiAgICAgKiBAcGFyYW0ge29iamVjdFtdfSBvYmplY3RzXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGVCfSBjb21wb3NpdGVCXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBSZXR1cm5zIGNvbXBvc2l0ZUFcbiAgICAgKi9cbiAgICBDb21wb3NpdGUubW92ZSA9IGZ1bmN0aW9uKGNvbXBvc2l0ZUEsIG9iamVjdHMsIGNvbXBvc2l0ZUIpIHtcbiAgICAgICAgQ29tcG9zaXRlLnJlbW92ZShjb21wb3NpdGVBLCBvYmplY3RzKTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZChjb21wb3NpdGVCLCBvYmplY3RzKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbmV3IGlkcyBmb3IgYWxsIG9iamVjdHMgaW4gdGhlIGNvbXBvc2l0ZSwgcmVjdXJzaXZlbHkuXG4gICAgICogQG1ldGhvZCByZWJhc2VcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBSZXR1cm5zIGNvbXBvc2l0ZVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yZWJhc2UgPSBmdW5jdGlvbihjb21wb3NpdGUpIHtcbiAgICAgICAgdmFyIG9iamVjdHMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSlcbiAgICAgICAgICAgIC5jb25jYXQoQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKGNvbXBvc2l0ZSkpXG4gICAgICAgICAgICAuY29uY2F0KENvbXBvc2l0ZS5hbGxDb21wb3NpdGVzKGNvbXBvc2l0ZSkpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2JqZWN0c1tpXS5pZCA9IENvbW1vbi5uZXh0SWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgYWxsIGNoaWxkcmVuIGluIHRoZSBjb21wb3NpdGUgYnkgYSBnaXZlbiB2ZWN0b3IgcmVsYXRpdmUgdG8gdGhlaXIgY3VycmVudCBwb3NpdGlvbnMsIFxuICAgICAqIHdpdGhvdXQgaW1wYXJ0aW5nIGFueSB2ZWxvY2l0eS5cbiAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVxuICAgICAqIEBwYXJhbSB7Y29tcG9zaXRlfSBjb21wb3NpdGVcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gdHJhbnNsYXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2x9IFtyZWN1cnNpdmU9dHJ1ZV1cbiAgICAgKi9cbiAgICBDb21wb3NpdGUudHJhbnNsYXRlID0gZnVuY3Rpb24oY29tcG9zaXRlLCB0cmFuc2xhdGlvbiwgcmVjdXJzaXZlKSB7XG4gICAgICAgIHZhciBib2RpZXMgPSByZWN1cnNpdmUgPyBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSkgOiBjb21wb3NpdGUuYm9kaWVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBCb2R5LnRyYW5zbGF0ZShib2RpZXNbaV0sIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYWxsIGNoaWxkcmVuIGluIHRoZSBjb21wb3NpdGUgYnkgYSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgZ2l2ZW4gcG9pbnQsIHdpdGhvdXQgaW1wYXJ0aW5nIGFueSBhbmd1bGFyIHZlbG9jaXR5LlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7dmVjdG9yfSBwb2ludFxuICAgICAqIEBwYXJhbSB7Ym9vbH0gW3JlY3Vyc2l2ZT10cnVlXVxuICAgICAqL1xuICAgIENvbXBvc2l0ZS5yb3RhdGUgPSBmdW5jdGlvbihjb21wb3NpdGUsIHJvdGF0aW9uLCBwb2ludCwgcmVjdXJzaXZlKSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbiksXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihyb3RhdGlvbiksXG4gICAgICAgICAgICBib2RpZXMgPSByZWN1cnNpdmUgPyBDb21wb3NpdGUuYWxsQm9kaWVzKGNvbXBvc2l0ZSkgOiBjb21wb3NpdGUuYm9kaWVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBkeCA9IGJvZHkucG9zaXRpb24ueCAtIHBvaW50LngsXG4gICAgICAgICAgICAgICAgZHkgPSBib2R5LnBvc2l0aW9uLnkgLSBwb2ludC55O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgQm9keS5zZXRQb3NpdGlvbihib2R5LCB7XG4gICAgICAgICAgICAgICAgeDogcG9pbnQueCArIChkeCAqIGNvcyAtIGR5ICogc2luKSxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55ICsgKGR4ICogc2luICsgZHkgKiBjb3MpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgQm9keS5yb3RhdGUoYm9keSwgcm90YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFsbCBjaGlsZHJlbiBpbiB0aGUgY29tcG9zaXRlLCBpbmNsdWRpbmcgdXBkYXRpbmcgcGh5c2ljYWwgcHJvcGVydGllcyAobWFzcywgYXJlYSwgYXhlcywgaW5lcnRpYSksIGZyb20gYSB3b3JsZC1zcGFjZSBwb2ludC5cbiAgICAgKiBAbWV0aG9kIHNjYWxlXG4gICAgICogQHBhcmFtIHtjb21wb3NpdGV9IGNvbXBvc2l0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHBhcmFtIHtib29sfSBbcmVjdXJzaXZlPXRydWVdXG4gICAgICovXG4gICAgQ29tcG9zaXRlLnNjYWxlID0gZnVuY3Rpb24oY29tcG9zaXRlLCBzY2FsZVgsIHNjYWxlWSwgcG9pbnQsIHJlY3Vyc2l2ZSkge1xuICAgICAgICB2YXIgYm9kaWVzID0gcmVjdXJzaXZlID8gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpIDogY29tcG9zaXRlLmJvZGllcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgZHggPSBib2R5LnBvc2l0aW9uLnggLSBwb2ludC54LFxuICAgICAgICAgICAgICAgIGR5ID0gYm9keS5wb3NpdGlvbi55IC0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIEJvZHkuc2V0UG9zaXRpb24oYm9keSwge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggKyBkeCAqIHNjYWxlWCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55ICsgZHkgKiBzY2FsZVlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBCb2R5LnNjYWxlKGJvZHksIHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuaW9uIG9mIHRoZSBib3VuZHMgb2YgYWxsIG9mIHRoZSBjb21wb3NpdGUncyBib2RpZXMuXG4gICAgICogQG1ldGhvZCBib3VuZHNcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlIFRoZSBjb21wb3NpdGUuXG4gICAgICogQHJldHVybnMge2JvdW5kc30gVGhlIGNvbXBvc2l0ZSBib3VuZHMuXG4gICAgICovXG4gICAgQ29tcG9zaXRlLmJvdW5kcyA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSkge1xuICAgICAgICB2YXIgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyhjb21wb3NpdGUpLFxuICAgICAgICAgICAgdmVydGljZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKGJvZHkuYm91bmRzLm1pbiwgYm9keS5ib3VuZHMubWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBCb3VuZHMuY3JlYXRlKHZlcnRpY2VzKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgRXZlbnRzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiBhIGNhbGwgdG8gYENvbXBvc2l0ZS5hZGRgIGlzIG1hZGUsIGJlZm9yZSBvYmplY3RzIGhhdmUgYmVlbiBhZGRlZC5cbiAgICAqXG4gICAgKiBAZXZlbnQgYmVmb3JlQWRkXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQub2JqZWN0IFRoZSBvYmplY3QocykgdG8gYmUgYWRkZWQgKG1heSBiZSBhIHNpbmdsZSBib2R5LCBjb25zdHJhaW50LCBjb21wb3NpdGUgb3IgYSBtaXhlZCBhcnJheSBvZiB0aGVzZSlcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIGEgY2FsbCB0byBgQ29tcG9zaXRlLmFkZGAgaXMgbWFkZSwgYWZ0ZXIgb2JqZWN0cyBoYXZlIGJlZW4gYWRkZWQuXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyQWRkXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge30gZXZlbnQub2JqZWN0IFRoZSBvYmplY3QocykgdGhhdCBoYXZlIGJlZW4gYWRkZWQgKG1heSBiZSBhIHNpbmdsZSBib2R5LCBjb25zdHJhaW50LCBjb21wb3NpdGUgb3IgYSBtaXhlZCBhcnJheSBvZiB0aGVzZSlcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIGEgY2FsbCB0byBgQ29tcG9zaXRlLnJlbW92ZWAgaXMgbWFkZSwgYmVmb3JlIG9iamVjdHMgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZVJlbW92ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm9iamVjdCBUaGUgb2JqZWN0KHMpIHRvIGJlIHJlbW92ZWQgKG1heSBiZSBhIHNpbmdsZSBib2R5LCBjb25zdHJhaW50LCBjb21wb3NpdGUgb3IgYSBtaXhlZCBhcnJheSBvZiB0aGVzZSlcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIGEgY2FsbCB0byBgQ29tcG9zaXRlLnJlbW92ZWAgaXMgbWFkZSwgYWZ0ZXIgb2JqZWN0cyBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICAqXG4gICAgKiBAZXZlbnQgYWZ0ZXJSZW1vdmVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7fSBldmVudC5vYmplY3QgVGhlIG9iamVjdChzKSB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIChtYXkgYmUgYSBzaW5nbGUgYm9keSwgY29uc3RyYWludCwgY29tcG9zaXRlIG9yIGEgbWl4ZWQgYXJyYXkgb2YgdGhlc2UpXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gaW50ZWdlciBgTnVtYmVyYCB1bmlxdWVseSBpZGVudGlmeWluZyBudW1iZXIgZ2VuZXJhdGVkIGluIGBDb21wb3NpdGUuY3JlYXRlYCBieSBgQ29tbW9uLm5leHRJZGAuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFN0cmluZ2AgZGVub3RpbmcgdGhlIHR5cGUgb2Ygb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcImNvbXBvc2l0ZVwiXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcmJpdHJhcnkgYFN0cmluZ2AgbmFtZSB0byBoZWxwIHRoZSB1c2VyIGlkZW50aWZ5IGFuZCBtYW5hZ2UgY29tcG9zaXRlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsYWJlbFxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0IFwiQ29tcG9zaXRlXCJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBjb21wb3NpdGUgaGFzIGJlZW4gbW9kaWZpZWQgZHVyaW5nIHRoZSBjdXJyZW50IHN0ZXAuXG4gICAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IG1hbmFnZWQgd2hlbiBib2RpZXMsIGNvbnN0cmFpbnRzIG9yIGNvbXBvc2l0ZXMgYXJlIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgaXNNb2RpZmllZFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBDb21wb3NpdGVgIHRoYXQgaXMgdGhlIHBhcmVudCBvZiB0aGlzIGNvbXBvc2l0ZS4gSXQgaXMgYXV0b21hdGljYWxseSBtYW5hZ2VkIGJ5IHRoZSBgTWF0dGVyLkNvbXBvc2l0ZWAgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwYXJlbnRcbiAgICAgKiBAdHlwZSBjb21wb3NpdGVcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBgQm9keWAgdGhhdCBhcmUgX2RpcmVjdF8gY2hpbGRyZW4gb2YgdGhpcyBjb21wb3NpdGUuXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBib2RpZXMgeW91IHNob3VsZCB1c2UgYENvbXBvc2l0ZS5hZGRgIGFuZCBgQ29tcG9zaXRlLnJlbW92ZWAgbWV0aG9kcyByYXRoZXIgdGhhbiBkaXJlY3RseSBtb2RpZnlpbmcgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKiBJZiB5b3Ugd2lzaCB0byByZWN1cnNpdmVseSBmaW5kIGFsbCBkZXNjZW5kYW50cywgeW91IHNob3VsZCB1c2UgdGhlIGBDb21wb3NpdGUuYWxsQm9kaWVzYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXG4gICAgICogQHR5cGUgYm9keVtdXG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGBDb25zdHJhaW50YCB0aGF0IGFyZSBfZGlyZWN0XyBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvc2l0ZS5cbiAgICAgKiBUbyBhZGQgb3IgcmVtb3ZlIGNvbnN0cmFpbnRzIHlvdSBzaG91bGQgdXNlIGBDb21wb3NpdGUuYWRkYCBhbmQgYENvbXBvc2l0ZS5yZW1vdmVgIG1ldGhvZHMgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcbiAgICAgKiBAdHlwZSBjb25zdHJhaW50W11cbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYENvbXBvc2l0ZWAgdGhhdCBhcmUgX2RpcmVjdF8gY2hpbGRyZW4gb2YgdGhpcyBjb21wb3NpdGUuXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBjb21wb3NpdGVzIHlvdSBzaG91bGQgdXNlIGBDb21wb3NpdGUuYWRkYCBhbmQgYENvbXBvc2l0ZS5yZW1vdmVgIG1ldGhvZHMgcmF0aGVyIHRoYW4gZGlyZWN0bHkgbW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICogSWYgeW91IHdpc2ggdG8gcmVjdXJzaXZlbHkgZmluZCBhbGwgZGVzY2VuZGFudHMsIHlvdSBzaG91bGQgdXNlIHRoZSBgQ29tcG9zaXRlLmFsbENvbXBvc2l0ZXNgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb21wb3NpdGVzXG4gICAgICogQHR5cGUgY29tcG9zaXRlW11cbiAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlc2VydmVkIGZvciBzdG9yaW5nIHBsdWdpbi1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsdWdpblxuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgdXNlZCBmb3Igc3RvcmluZyBjYWNoZWQgcmVzdWx0cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgKiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseSBvbmx5IGFuZCBpcyBhdXRvbWF0aWNhbGx5IG1hbmFnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBjYWNoZVxuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgdG8gbWFuYWdlIHRoZSBzbGVlcGluZyBzdGF0ZSBvZiBib2RpZXMuXG4qXG4qIEBjbGFzcyBTbGVlcGluZ1xuKi9cblxudmFyIFNsZWVwaW5nID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gU2xlZXBpbmc7XG5cbnZhciBCb2R5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBFdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIFNsZWVwaW5nLl9tb3Rpb25XYWtlVGhyZXNob2xkID0gMC4xODtcbiAgICBTbGVlcGluZy5fbW90aW9uU2xlZXBUaHJlc2hvbGQgPSAwLjA4O1xuICAgIFNsZWVwaW5nLl9taW5CaWFzID0gMC45O1xuXG4gICAgLyoqXG4gICAgICogUHV0cyBib2RpZXMgdG8gc2xlZXAgb3Igd2FrZXMgdGhlbSB1cCBkZXBlbmRpbmcgb24gdGhlaXIgbW90aW9uLlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICAgICAqL1xuICAgIFNsZWVwaW5nLnVwZGF0ZSA9IGZ1bmN0aW9uKGJvZGllcywgZGVsdGEpIHtcbiAgICAgICAgdmFyIHRpbWVTY2FsZSA9IGRlbHRhIC8gQ29tbW9uLl9iYXNlRGVsdGEsXG4gICAgICAgICAgICBtb3Rpb25TbGVlcFRocmVzaG9sZCA9IFNsZWVwaW5nLl9tb3Rpb25TbGVlcFRocmVzaG9sZDtcbiAgICAgICAgXG4gICAgICAgIC8vIHVwZGF0ZSBib2RpZXMgc2xlZXBpbmcgc3RhdHVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBzcGVlZCA9IEJvZHkuZ2V0U3BlZWQoYm9keSksXG4gICAgICAgICAgICAgICAgYW5ndWxhclNwZWVkID0gQm9keS5nZXRBbmd1bGFyU3BlZWQoYm9keSksXG4gICAgICAgICAgICAgICAgbW90aW9uID0gc3BlZWQgKiBzcGVlZCArIGFuZ3VsYXJTcGVlZCAqIGFuZ3VsYXJTcGVlZDtcblxuICAgICAgICAgICAgLy8gd2FrZSB1cCBib2RpZXMgaWYgdGhleSBoYXZlIGEgZm9yY2UgYXBwbGllZFxuICAgICAgICAgICAgaWYgKGJvZHkuZm9yY2UueCAhPT0gMCB8fCBib2R5LmZvcmNlLnkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWluTW90aW9uID0gTWF0aC5taW4oYm9keS5tb3Rpb24sIG1vdGlvbiksXG4gICAgICAgICAgICAgICAgbWF4TW90aW9uID0gTWF0aC5tYXgoYm9keS5tb3Rpb24sIG1vdGlvbik7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gYmlhc2VkIGF2ZXJhZ2UgbW90aW9uIGVzdGltYXRpb24gYmV0d2VlbiBmcmFtZXNcbiAgICAgICAgICAgIGJvZHkubW90aW9uID0gU2xlZXBpbmcuX21pbkJpYXMgKiBtaW5Nb3Rpb24gKyAoMSAtIFNsZWVwaW5nLl9taW5CaWFzKSAqIG1heE1vdGlvbjtcblxuICAgICAgICAgICAgaWYgKGJvZHkuc2xlZXBUaHJlc2hvbGQgPiAwICYmIGJvZHkubW90aW9uIDwgbW90aW9uU2xlZXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBib2R5LnNsZWVwQ291bnRlciArPSAxO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChib2R5LnNsZWVwQ291bnRlciA+PSBib2R5LnNsZWVwVGhyZXNob2xkIC8gdGltZVNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJvZHkuc2xlZXBDb3VudGVyID4gMCkge1xuICAgICAgICAgICAgICAgIGJvZHkuc2xlZXBDb3VudGVyIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzZXQgb2YgY29sbGlkaW5nIHBhaXJzLCB3YWtlcyB0aGUgc2xlZXBpbmcgYm9kaWVzIGludm9sdmVkLlxuICAgICAqIEBtZXRob2QgYWZ0ZXJDb2xsaXNpb25zXG4gICAgICogQHBhcmFtIHtwYWlyW119IHBhaXJzXG4gICAgICovXG4gICAgU2xlZXBpbmcuYWZ0ZXJDb2xsaXNpb25zID0gZnVuY3Rpb24ocGFpcnMpIHtcbiAgICAgICAgdmFyIG1vdGlvblNsZWVwVGhyZXNob2xkID0gU2xlZXBpbmcuX21vdGlvblNsZWVwVGhyZXNob2xkO1xuXG4gICAgICAgIC8vIHdha2UgdXAgYm9kaWVzIGludm9sdmVkIGluIGNvbGxpc2lvbnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FrZSBpbmFjdGl2ZSBwYWlyc1xuICAgICAgICAgICAgaWYgKCFwYWlyLmlzQWN0aXZlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb24sXG4gICAgICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24uYm9keUEucGFyZW50LCBcbiAgICAgICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5ib2R5Qi5wYXJlbnQ7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FrZSBpZiBhdCBsZWFzdCBvbmUgYm9keSBpcyBzdGF0aWNcbiAgICAgICAgICAgIGlmICgoYm9keUEuaXNTbGVlcGluZyAmJiBib2R5Qi5pc1NsZWVwaW5nKSB8fCBib2R5QS5pc1N0YXRpYyB8fCBib2R5Qi5pc1N0YXRpYylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgICAgICBpZiAoYm9keUEuaXNTbGVlcGluZyB8fCBib2R5Qi5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNsZWVwaW5nQm9keSA9IChib2R5QS5pc1NsZWVwaW5nICYmICFib2R5QS5pc1N0YXRpYykgPyBib2R5QSA6IGJvZHlCLFxuICAgICAgICAgICAgICAgICAgICBtb3ZpbmdCb2R5ID0gc2xlZXBpbmdCb2R5ID09PSBib2R5QSA/IGJvZHlCIDogYm9keUE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNsZWVwaW5nQm9keS5pc1N0YXRpYyAmJiBtb3ZpbmdCb2R5Lm1vdGlvbiA+IG1vdGlvblNsZWVwVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChzbGVlcGluZ0JvZHksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICBcbiAgICAvKipcbiAgICAgKiBTZXQgYSBib2R5IGFzIHNsZWVwaW5nIG9yIGF3YWtlLlxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1NsZWVwaW5nXG4gICAgICovXG4gICAgU2xlZXBpbmcuc2V0ID0gZnVuY3Rpb24oYm9keSwgaXNTbGVlcGluZykge1xuICAgICAgICB2YXIgd2FzU2xlZXBpbmcgPSBib2R5LmlzU2xlZXBpbmc7XG5cbiAgICAgICAgaWYgKGlzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgIGJvZHkuaXNTbGVlcGluZyA9IHRydWU7XG4gICAgICAgICAgICBib2R5LnNsZWVwQ291bnRlciA9IGJvZHkuc2xlZXBUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25JbXB1bHNlLnggPSAwO1xuICAgICAgICAgICAgYm9keS5wb3NpdGlvbkltcHVsc2UueSA9IDA7XG5cbiAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggPSBib2R5LnBvc2l0aW9uLng7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ID0gYm9keS5wb3NpdGlvbi55O1xuXG4gICAgICAgICAgICBib2R5LmFuZ2xlUHJldiA9IGJvZHkuYW5nbGU7XG4gICAgICAgICAgICBib2R5LnNwZWVkID0gMDtcbiAgICAgICAgICAgIGJvZHkuYW5ndWxhclNwZWVkID0gMDtcbiAgICAgICAgICAgIGJvZHkubW90aW9uID0gMDtcblxuICAgICAgICAgICAgaWYgKCF3YXNTbGVlcGluZykge1xuICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKGJvZHksICdzbGVlcFN0YXJ0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5LmlzU2xlZXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJvZHkuc2xlZXBDb3VudGVyID0gMDtcblxuICAgICAgICAgICAgaWYgKHdhc1NsZWVwaW5nKSB7XG4gICAgICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoYm9keSwgJ3NsZWVwRW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuQ29sbGlzaW9uYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgZGV0ZWN0aW5nIGNvbGxpc2lvbnMgYmV0d2VlbiBhIGdpdmVuIHBhaXIgb2YgYm9kaWVzLlxuKlxuKiBGb3IgZWZmaWNpZW50IGRldGVjdGlvbiBiZXR3ZWVuIGEgbGlzdCBvZiBib2RpZXMsIHNlZSBgTWF0dGVyLkRldGVjdG9yYCBhbmQgYE1hdHRlci5RdWVyeWAuXG4qXG4qIFNlZSBgTWF0dGVyLkVuZ2luZWAgZm9yIGNvbGxpc2lvbiBldmVudHMuXG4qXG4qIEBjbGFzcyBDb2xsaXNpb25cbiovXG5cbnZhciBDb2xsaXNpb24gPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb247XG5cbnZhciBWZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgUGFpciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbihmdW5jdGlvbigpIHtcbiAgICB2YXIgX3N1cHBvcnRzID0gW107XG5cbiAgICB2YXIgX292ZXJsYXBBQiA9IHtcbiAgICAgICAgb3ZlcmxhcDogMCxcbiAgICAgICAgYXhpczogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgX292ZXJsYXBCQSA9IHtcbiAgICAgICAgb3ZlcmxhcDogMCxcbiAgICAgICAgYXhpczogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxpc2lvbiByZWNvcmQuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlBIFRoZSBmaXJzdCBib2R5IHBhcnQgcmVwcmVzZW50ZWQgYnkgdGhlIGNvbGxpc2lvbiByZWNvcmRcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlCIFRoZSBzZWNvbmQgYm9keSBwYXJ0IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsaXNpb24gcmVjb3JkXG4gICAgICogQHJldHVybiB7Y29sbGlzaW9ufSBBIG5ldyBjb2xsaXNpb24gcmVjb3JkXG4gICAgICovXG4gICAgQ29sbGlzaW9uLmNyZWF0ZSA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qikge1xuICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgIHBhaXI6IG51bGwsXG4gICAgICAgICAgICBjb2xsaWRlZDogZmFsc2UsXG4gICAgICAgICAgICBib2R5QTogYm9keUEsXG4gICAgICAgICAgICBib2R5QjogYm9keUIsXG4gICAgICAgICAgICBwYXJlbnRBOiBib2R5QS5wYXJlbnQsXG4gICAgICAgICAgICBwYXJlbnRCOiBib2R5Qi5wYXJlbnQsXG4gICAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICAgIG5vcm1hbDogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICB0YW5nZW50OiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIHBlbmV0cmF0aW9uOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIHN1cHBvcnRzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllcy5cbiAgICAgKiBAbWV0aG9kIGNvbGxpZGVzXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcbiAgICAgKiBAcGFyYW0ge3BhaXJzfSBbcGFpcnNdIE9wdGlvbmFsbHkgcmV1c2UgY29sbGlzaW9uIHJlY29yZHMgZnJvbSBleGlzdGluZyBwYWlycy5cbiAgICAgKiBAcmV0dXJuIHtjb2xsaXNpb258bnVsbH0gQSBjb2xsaXNpb24gcmVjb3JkIGlmIGRldGVjdGVkLCBvdGhlcndpc2UgbnVsbFxuICAgICAqL1xuICAgIENvbGxpc2lvbi5jb2xsaWRlcyA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5QiwgcGFpcnMpIHtcbiAgICAgICAgQ29sbGlzaW9uLl9vdmVybGFwQXhlcyhfb3ZlcmxhcEFCLCBib2R5QS52ZXJ0aWNlcywgYm9keUIudmVydGljZXMsIGJvZHlBLmF4ZXMpO1xuXG4gICAgICAgIGlmIChfb3ZlcmxhcEFCLm92ZXJsYXAgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBDb2xsaXNpb24uX292ZXJsYXBBeGVzKF9vdmVybGFwQkEsIGJvZHlCLnZlcnRpY2VzLCBib2R5QS52ZXJ0aWNlcywgYm9keUIuYXhlcyk7XG5cbiAgICAgICAgaWYgKF9vdmVybGFwQkEub3ZlcmxhcCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldXNlIGNvbGxpc2lvbiByZWNvcmRzIGZvciBnYyBlZmZpY2llbmN5XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnMgJiYgcGFpcnMudGFibGVbUGFpci5pZChib2R5QSwgYm9keUIpXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbjtcblxuICAgICAgICBpZiAoIXBhaXIpIHtcbiAgICAgICAgICAgIGNvbGxpc2lvbiA9IENvbGxpc2lvbi5jcmVhdGUoYm9keUEsIGJvZHlCKTtcbiAgICAgICAgICAgIGNvbGxpc2lvbi5jb2xsaWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb2xsaXNpb24uYm9keUEgPSBib2R5QS5pZCA8IGJvZHlCLmlkID8gYm9keUEgOiBib2R5QjtcbiAgICAgICAgICAgIGNvbGxpc2lvbi5ib2R5QiA9IGJvZHlBLmlkIDwgYm9keUIuaWQgPyBib2R5QiA6IGJvZHlBO1xuICAgICAgICAgICAgY29sbGlzaW9uLnBhcmVudEEgPSBjb2xsaXNpb24uYm9keUEucGFyZW50O1xuICAgICAgICAgICAgY29sbGlzaW9uLnBhcmVudEIgPSBjb2xsaXNpb24uYm9keUIucGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgIH1cblxuICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5ib2R5QTtcbiAgICAgICAgYm9keUIgPSBjb2xsaXNpb24uYm9keUI7XG5cbiAgICAgICAgdmFyIG1pbk92ZXJsYXA7XG5cbiAgICAgICAgaWYgKF9vdmVybGFwQUIub3ZlcmxhcCA8IF9vdmVybGFwQkEub3ZlcmxhcCkge1xuICAgICAgICAgICAgbWluT3ZlcmxhcCA9IF9vdmVybGFwQUI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaW5PdmVybGFwID0gX292ZXJsYXBCQTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3JtYWwgPSBjb2xsaXNpb24ubm9ybWFsLFxuICAgICAgICAgICAgc3VwcG9ydHMgPSBjb2xsaXNpb24uc3VwcG9ydHMsXG4gICAgICAgICAgICBtaW5BeGlzID0gbWluT3ZlcmxhcC5heGlzLFxuICAgICAgICAgICAgbWluQXhpc1ggPSBtaW5BeGlzLngsXG4gICAgICAgICAgICBtaW5BeGlzWSA9IG1pbkF4aXMueTtcblxuICAgICAgICAvLyBlbnN1cmUgbm9ybWFsIGlzIGZhY2luZyBhd2F5IGZyb20gYm9keUFcbiAgICAgICAgaWYgKG1pbkF4aXNYICogKGJvZHlCLnBvc2l0aW9uLnggLSBib2R5QS5wb3NpdGlvbi54KSArIG1pbkF4aXNZICogKGJvZHlCLnBvc2l0aW9uLnkgLSBib2R5QS5wb3NpdGlvbi55KSA8IDApIHtcbiAgICAgICAgICAgIG5vcm1hbC54ID0gbWluQXhpc1g7XG4gICAgICAgICAgICBub3JtYWwueSA9IG1pbkF4aXNZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsLnggPSAtbWluQXhpc1g7XG4gICAgICAgICAgICBub3JtYWwueSA9IC1taW5BeGlzWTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29sbGlzaW9uLnRhbmdlbnQueCA9IC1ub3JtYWwueTtcbiAgICAgICAgY29sbGlzaW9uLnRhbmdlbnQueSA9IG5vcm1hbC54O1xuXG4gICAgICAgIGNvbGxpc2lvbi5kZXB0aCA9IG1pbk92ZXJsYXAub3ZlcmxhcDtcblxuICAgICAgICBjb2xsaXNpb24ucGVuZXRyYXRpb24ueCA9IG5vcm1hbC54ICogY29sbGlzaW9uLmRlcHRoO1xuICAgICAgICBjb2xsaXNpb24ucGVuZXRyYXRpb24ueSA9IG5vcm1hbC55ICogY29sbGlzaW9uLmRlcHRoO1xuXG4gICAgICAgIC8vIGZpbmQgc3VwcG9ydCBwb2ludHMsIHRoZXJlIGlzIGFsd2F5cyBlaXRoZXIgZXhhY3RseSBvbmUgb3IgdHdvXG4gICAgICAgIHZhciBzdXBwb3J0c0IgPSBDb2xsaXNpb24uX2ZpbmRTdXBwb3J0cyhib2R5QSwgYm9keUIsIG5vcm1hbCwgMSksXG4gICAgICAgICAgICBzdXBwb3J0Q291bnQgPSAwO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHN1cHBvcnRzIGZyb20gYm9keUIgdGhhdCBhcmUgaW5zaWRlIGJvZHlBXG4gICAgICAgIGlmIChWZXJ0aWNlcy5jb250YWlucyhib2R5QS52ZXJ0aWNlcywgc3VwcG9ydHNCWzBdKSkge1xuICAgICAgICAgICAgc3VwcG9ydHNbc3VwcG9ydENvdW50KytdID0gc3VwcG9ydHNCWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFZlcnRpY2VzLmNvbnRhaW5zKGJvZHlBLnZlcnRpY2VzLCBzdXBwb3J0c0JbMV0pKSB7XG4gICAgICAgICAgICBzdXBwb3J0c1tzdXBwb3J0Q291bnQrK10gPSBzdXBwb3J0c0JbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBzdXBwb3J0cyBmcm9tIGJvZHlBIHRoYXQgYXJlIGluc2lkZSBib2R5QlxuICAgICAgICBpZiAoc3VwcG9ydENvdW50IDwgMikge1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRzQSA9IENvbGxpc2lvbi5fZmluZFN1cHBvcnRzKGJvZHlCLCBib2R5QSwgbm9ybWFsLCAtMSk7XG5cbiAgICAgICAgICAgIGlmIChWZXJ0aWNlcy5jb250YWlucyhib2R5Qi52ZXJ0aWNlcywgc3VwcG9ydHNBWzBdKSkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzW3N1cHBvcnRDb3VudCsrXSA9IHN1cHBvcnRzQVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRDb3VudCA8IDIgJiYgVmVydGljZXMuY29udGFpbnMoYm9keUIudmVydGljZXMsIHN1cHBvcnRzQVsxXSkpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1tzdXBwb3J0Q291bnQrK10gPSBzdXBwb3J0c0FbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgZWRnZSBjYXNlIG9mIG92ZXJsYXBwaW5nIGJ1dCBubyB2ZXJ0ZXggY29udGFpbm1lbnRcbiAgICAgICAgaWYgKHN1cHBvcnRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3VwcG9ydHNbc3VwcG9ydENvdW50KytdID0gc3VwcG9ydHNCWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHN1cHBvcnRzIGFycmF5IHNpemVcbiAgICAgICAgc3VwcG9ydHMubGVuZ3RoID0gc3VwcG9ydENvdW50O1xuXG4gICAgICAgIHJldHVybiBjb2xsaXNpb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG92ZXJsYXAgYmV0d2VlbiB0d28gc2V0cyBvZiB2ZXJ0aWNlcy5cbiAgICAgKiBAbWV0aG9kIF9vdmVybGFwQXhlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzQVxuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzQlxuICAgICAqIEBwYXJhbSB7YXhlc30gYXhlc1xuICAgICAqL1xuICAgIENvbGxpc2lvbi5fb3ZlcmxhcEF4ZXMgPSBmdW5jdGlvbihyZXN1bHQsIHZlcnRpY2VzQSwgdmVydGljZXNCLCBheGVzKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlc0FMZW5ndGggPSB2ZXJ0aWNlc0EubGVuZ3RoLFxuICAgICAgICAgICAgdmVydGljZXNCTGVuZ3RoID0gdmVydGljZXNCLmxlbmd0aCxcbiAgICAgICAgICAgIHZlcnRpY2VzQVggPSB2ZXJ0aWNlc0FbMF0ueCxcbiAgICAgICAgICAgIHZlcnRpY2VzQVkgPSB2ZXJ0aWNlc0FbMF0ueSxcbiAgICAgICAgICAgIHZlcnRpY2VzQlggPSB2ZXJ0aWNlc0JbMF0ueCxcbiAgICAgICAgICAgIHZlcnRpY2VzQlkgPSB2ZXJ0aWNlc0JbMF0ueSxcbiAgICAgICAgICAgIGF4ZXNMZW5ndGggPSBheGVzLmxlbmd0aCxcbiAgICAgICAgICAgIG92ZXJsYXBNaW4gPSBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgb3ZlcmxhcEF4aXNOdW1iZXIgPSAwLFxuICAgICAgICAgICAgb3ZlcmxhcCxcbiAgICAgICAgICAgIG92ZXJsYXBBQixcbiAgICAgICAgICAgIG92ZXJsYXBCQSxcbiAgICAgICAgICAgIGRvdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBheGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gYXhlc1tpXSxcbiAgICAgICAgICAgICAgICBheGlzWCA9IGF4aXMueCxcbiAgICAgICAgICAgICAgICBheGlzWSA9IGF4aXMueSxcbiAgICAgICAgICAgICAgICBtaW5BID0gdmVydGljZXNBWCAqIGF4aXNYICsgdmVydGljZXNBWSAqIGF4aXNZLFxuICAgICAgICAgICAgICAgIG1pbkIgPSB2ZXJ0aWNlc0JYICogYXhpc1ggKyB2ZXJ0aWNlc0JZICogYXhpc1ksXG4gICAgICAgICAgICAgICAgbWF4QSA9IG1pbkEsXG4gICAgICAgICAgICAgICAgbWF4QiA9IG1pbkI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCB2ZXJ0aWNlc0FMZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGRvdCA9IHZlcnRpY2VzQVtqXS54ICogYXhpc1ggKyB2ZXJ0aWNlc0Fbal0ueSAqIGF4aXNZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRvdCA+IG1heEEpIHsgXG4gICAgICAgICAgICAgICAgICAgIG1heEEgPSBkb3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb3QgPCBtaW5BKSB7IFxuICAgICAgICAgICAgICAgICAgICBtaW5BID0gZG90O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IHZlcnRpY2VzQkxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZG90ID0gdmVydGljZXNCW2pdLnggKiBheGlzWCArIHZlcnRpY2VzQltqXS55ICogYXhpc1k7XG5cbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gbWF4QikgeyBcbiAgICAgICAgICAgICAgICAgICAgbWF4QiA9IGRvdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvdCA8IG1pbkIpIHsgXG4gICAgICAgICAgICAgICAgICAgIG1pbkIgPSBkb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdmVybGFwQUIgPSBtYXhBIC0gbWluQjtcbiAgICAgICAgICAgIG92ZXJsYXBCQSA9IG1heEIgLSBtaW5BO1xuICAgICAgICAgICAgb3ZlcmxhcCA9IG92ZXJsYXBBQiA8IG92ZXJsYXBCQSA/IG92ZXJsYXBBQiA6IG92ZXJsYXBCQTtcblxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBvdmVybGFwTWluKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcE1pbiA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcEF4aXNOdW1iZXIgPSBpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYW4gbm90IGJlIGludGVyc2VjdGluZ1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmF4aXMgPSBheGVzW292ZXJsYXBBeGlzTnVtYmVyXTtcbiAgICAgICAgcmVzdWx0Lm92ZXJsYXAgPSBvdmVybGFwTWluO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0cyB2ZXJ0aWNlcyBvbiBhbiBheGlzIGFuZCByZXR1cm5zIGFuIGludGVydmFsLlxuICAgICAqIEBtZXRob2QgX3Byb2plY3RUb0F4aXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBwcm9qZWN0aW9uXG4gICAgICogQHBhcmFtIHt9IHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHt9IGF4aXNcbiAgICAgKi9cbiAgICBDb2xsaXNpb24uX3Byb2plY3RUb0F4aXMgPSBmdW5jdGlvbihwcm9qZWN0aW9uLCB2ZXJ0aWNlcywgYXhpcykge1xuICAgICAgICB2YXIgbWluID0gdmVydGljZXNbMF0ueCAqIGF4aXMueCArIHZlcnRpY2VzWzBdLnkgKiBheGlzLnksXG4gICAgICAgICAgICBtYXggPSBtaW47XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGRvdCA9IHZlcnRpY2VzW2ldLnggKiBheGlzLnggKyB2ZXJ0aWNlc1tpXS55ICogYXhpcy55O1xuXG4gICAgICAgICAgICBpZiAoZG90ID4gbWF4KSB7IFxuICAgICAgICAgICAgICAgIG1heCA9IGRvdDsgXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvdCA8IG1pbikgeyBcbiAgICAgICAgICAgICAgICBtaW4gPSBkb3Q7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvamVjdGlvbi5taW4gPSBtaW47XG4gICAgICAgIHByb2plY3Rpb24ubWF4ID0gbWF4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBzdXBwb3J0aW5nIHZlcnRpY2VzIGdpdmVuIHR3byBib2RpZXMgYWxvbmcgYSBnaXZlbiBkaXJlY3Rpb24gdXNpbmcgaGlsbC1jbGltYmluZy5cbiAgICAgKiBAbWV0aG9kIF9maW5kU3VwcG9ydHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlCXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IG5vcm1hbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25cbiAgICAgKiBAcmV0dXJuIFt2ZWN0b3JdXG4gICAgICovXG4gICAgQ29sbGlzaW9uLl9maW5kU3VwcG9ydHMgPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIG5vcm1hbCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGJvZHlCLnZlcnRpY2VzLFxuICAgICAgICAgICAgdmVydGljZXNMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBib2R5QVBvc2l0aW9uWCA9IGJvZHlBLnBvc2l0aW9uLngsXG4gICAgICAgICAgICBib2R5QVBvc2l0aW9uWSA9IGJvZHlBLnBvc2l0aW9uLnksXG4gICAgICAgICAgICBub3JtYWxYID0gbm9ybWFsLnggKiBkaXJlY3Rpb24sXG4gICAgICAgICAgICBub3JtYWxZID0gbm9ybWFsLnkgKiBkaXJlY3Rpb24sXG4gICAgICAgICAgICBuZWFyZXN0RGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgdmVydGV4QSxcbiAgICAgICAgICAgIHZlcnRleEIsXG4gICAgICAgICAgICB2ZXJ0ZXhDLFxuICAgICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIC8vIGZpbmQgZGVlcGVzdCB2ZXJ0ZXggcmVsYXRpdmUgdG8gdGhlIGF4aXNcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZlcnRpY2VzTGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZlcnRleEIgPSB2ZXJ0aWNlc1tqXTtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gbm9ybWFsWCAqIChib2R5QVBvc2l0aW9uWCAtIHZlcnRleEIueCkgKyBub3JtYWxZICogKGJvZHlBUG9zaXRpb25ZIC0gdmVydGV4Qi55KTtcblxuICAgICAgICAgICAgLy8gY29udmV4IGhpbGwtY2xpbWJpbmdcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG5lYXJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIG5lYXJlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHZlcnRleEEgPSB2ZXJ0ZXhCO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVhc3VyZSBuZXh0IHZlcnRleFxuICAgICAgICB2ZXJ0ZXhDID0gdmVydGljZXNbKHZlcnRpY2VzTGVuZ3RoICsgdmVydGV4QS5pbmRleCAtIDEpICUgdmVydGljZXNMZW5ndGhdO1xuICAgICAgICBuZWFyZXN0RGlzdGFuY2UgPSBub3JtYWxYICogKGJvZHlBUG9zaXRpb25YIC0gdmVydGV4Qy54KSArIG5vcm1hbFkgKiAoYm9keUFQb3NpdGlvblkgLSB2ZXJ0ZXhDLnkpO1xuXG4gICAgICAgIC8vIGNvbXBhcmUgd2l0aCBwcmV2aW91cyB2ZXJ0ZXhcbiAgICAgICAgdmVydGV4QiA9IHZlcnRpY2VzWyh2ZXJ0ZXhBLmluZGV4ICsgMSkgJSB2ZXJ0aWNlc0xlbmd0aF07XG4gICAgICAgIGlmIChub3JtYWxYICogKGJvZHlBUG9zaXRpb25YIC0gdmVydGV4Qi54KSArIG5vcm1hbFkgKiAoYm9keUFQb3NpdGlvblkgLSB2ZXJ0ZXhCLnkpIDwgbmVhcmVzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBfc3VwcG9ydHNbMF0gPSB2ZXJ0ZXhBO1xuICAgICAgICAgICAgX3N1cHBvcnRzWzFdID0gdmVydGV4QjtcblxuICAgICAgICAgICAgcmV0dXJuIF9zdXBwb3J0cztcbiAgICAgICAgfVxuXG4gICAgICAgIF9zdXBwb3J0c1swXSA9IHZlcnRleEE7XG4gICAgICAgIF9zdXBwb3J0c1sxXSA9IHZlcnRleEM7XG5cbiAgICAgICAgcmV0dXJuIF9zdXBwb3J0cztcbiAgICB9O1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgcGFpciB1c2luZyB0aGlzIGNvbGxpc2lvbiByZWNvcmQsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwYWlyXG4gICAgICogQHR5cGUge3BhaXJ8bnVsbH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGJvZGllcyB3ZXJlIGNvbGxpZGluZyB3aGVuIHRoZSBjb2xsaXNpb24gd2FzIGxhc3QgdXBkYXRlZC5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgY29sbGlkZWRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBib2R5IHBhcnQgcmVwcmVzZW50ZWQgYnkgdGhlIGNvbGxpc2lvbiAoc2VlIGFsc28gYGNvbGxpc2lvbi5wYXJlbnRBYCkuXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUgYm9keVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZCBib2R5IHBhcnQgcmVwcmVzZW50ZWQgYnkgdGhlIGNvbGxpc2lvbiAoc2VlIGFsc28gYGNvbGxpc2lvbi5wYXJlbnRCYCkuXG4gICAgICogXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUgYm9keVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IGJvZHkgcmVwcmVzZW50ZWQgYnkgdGhlIGNvbGxpc2lvbiAoaS5lLiBgY29sbGlzaW9uLmJvZHlBLnBhcmVudGApLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBwYXJlbnRBXG4gICAgICogQHR5cGUgYm9keVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZCBib2R5IHJlcHJlc2VudGVkIGJ5IHRoZSBjb2xsaXNpb24gKGkuZS4gYGNvbGxpc2lvbi5ib2R5Qi5wYXJlbnRgKS5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgcGFyZW50QlxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCByZXByZXNlbnRzIHRoZSBtaW5pbXVtIHNlcGFyYXRpbmcgZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm9kaWVzIGFsb25nIHRoZSBjb2xsaXNpb24gbm9ybWFsLlxuICAgICAqXG4gICAgICogQHJlYWRPbmx5XG4gICAgICogQHByb3BlcnR5IGRlcHRoXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBub3JtYWxpc2VkIGBWZWN0b3JgIHRoYXQgcmVwcmVzZW50cyB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdGhlIGJvZGllcyB0aGF0IHByb3ZpZGVzIHRoZSBtaW5pbXVtIHNlcGFyYXRpbmcgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbm9ybWFsXG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgbm9ybWFsaXNlZCBgVmVjdG9yYCB0aGF0IGlzIHRoZSB0YW5nZW50IGRpcmVjdGlvbiB0byB0aGUgY29sbGlzaW9uIG5vcm1hbC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0YW5nZW50XG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFZlY3RvcmAgdGhhdCByZXByZXNlbnRzIHRoZSBkaXJlY3Rpb24gYW5kIGRlcHRoIG9mIHRoZSBjb2xsaXNpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcGVuZXRyYXRpb25cbiAgICAgKiBAdHlwZSB2ZWN0b3JcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYm9keSB2ZXJ0aWNlcyB0aGF0IHJlcHJlc2VudCB0aGUgc3VwcG9ydCBwb2ludHMgaW4gdGhlIGNvbGxpc2lvbi5cbiAgICAgKiBUaGVzZSBhcmUgdGhlIGRlZXBlc3QgdmVydGljZXMgKGFsb25nIHRoZSBjb2xsaXNpb24gbm9ybWFsKSBvZiBlYWNoIGJvZHkgdGhhdCBhcmUgY29udGFpbmVkIGJ5IHRoZSBvdGhlciBib2R5J3MgdmVydGljZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc3VwcG9ydHNcbiAgICAgKiBAdHlwZSB2ZWN0b3JbXVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5QYWlyYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gcGFpcnMuXG4qXG4qIEBjbGFzcyBQYWlyXG4qL1xuXG52YXIgUGFpciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhaXI7XG5cbnZhciBDb250YWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbihmdW5jdGlvbigpIHtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFpci5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7Y29sbGlzaW9ufSBjb2xsaXNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAgICogQHJldHVybiB7cGFpcn0gQSBuZXcgcGFpclxuICAgICAqL1xuICAgIFBhaXIuY3JlYXRlID0gZnVuY3Rpb24oY29sbGlzaW9uLCB0aW1lc3RhbXApIHtcbiAgICAgICAgdmFyIGJvZHlBID0gY29sbGlzaW9uLmJvZHlBLFxuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24uYm9keUI7XG5cbiAgICAgICAgdmFyIHBhaXIgPSB7XG4gICAgICAgICAgICBpZDogUGFpci5pZChib2R5QSwgYm9keUIpLFxuICAgICAgICAgICAgYm9keUE6IGJvZHlBLFxuICAgICAgICAgICAgYm9keUI6IGJvZHlCLFxuICAgICAgICAgICAgY29sbGlzaW9uOiBjb2xsaXNpb24sXG4gICAgICAgICAgICBjb250YWN0czogW10sXG4gICAgICAgICAgICBhY3RpdmVDb250YWN0czogW10sXG4gICAgICAgICAgICBzZXBhcmF0aW9uOiAwLFxuICAgICAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBjb25maXJtZWRBY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBpc1NlbnNvcjogYm9keUEuaXNTZW5zb3IgfHwgYm9keUIuaXNTZW5zb3IsXG4gICAgICAgICAgICB0aW1lQ3JlYXRlZDogdGltZXN0YW1wLFxuICAgICAgICAgICAgdGltZVVwZGF0ZWQ6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGludmVyc2VNYXNzOiAwLFxuICAgICAgICAgICAgZnJpY3Rpb246IDAsXG4gICAgICAgICAgICBmcmljdGlvblN0YXRpYzogMCxcbiAgICAgICAgICAgIHJlc3RpdHV0aW9uOiAwLFxuICAgICAgICAgICAgc2xvcDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIFBhaXIudXBkYXRlKHBhaXIsIGNvbGxpc2lvbiwgdGltZXN0YW1wKTtcblxuICAgICAgICByZXR1cm4gcGFpcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHBhaXIgZ2l2ZW4gYSBjb2xsaXNpb24uXG4gICAgICogQG1ldGhvZCB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge3BhaXJ9IHBhaXJcbiAgICAgKiBAcGFyYW0ge2NvbGxpc2lvbn0gY29sbGlzaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcFxuICAgICAqL1xuICAgIFBhaXIudXBkYXRlID0gZnVuY3Rpb24ocGFpciwgY29sbGlzaW9uLCB0aW1lc3RhbXApIHtcbiAgICAgICAgdmFyIGNvbnRhY3RzID0gcGFpci5jb250YWN0cyxcbiAgICAgICAgICAgIHN1cHBvcnRzID0gY29sbGlzaW9uLnN1cHBvcnRzLFxuICAgICAgICAgICAgYWN0aXZlQ29udGFjdHMgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzLFxuICAgICAgICAgICAgcGFyZW50QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxuICAgICAgICAgICAgcGFyZW50QiA9IGNvbGxpc2lvbi5wYXJlbnRCLFxuICAgICAgICAgICAgcGFyZW50QVZlcnRpY2VzTGVuZ3RoID0gcGFyZW50QS52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICBwYWlyLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgcGFpci50aW1lVXBkYXRlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgcGFpci5jb2xsaXNpb24gPSBjb2xsaXNpb247XG4gICAgICAgIHBhaXIuc2VwYXJhdGlvbiA9IGNvbGxpc2lvbi5kZXB0aDtcbiAgICAgICAgcGFpci5pbnZlcnNlTWFzcyA9IHBhcmVudEEuaW52ZXJzZU1hc3MgKyBwYXJlbnRCLmludmVyc2VNYXNzO1xuICAgICAgICBwYWlyLmZyaWN0aW9uID0gcGFyZW50QS5mcmljdGlvbiA8IHBhcmVudEIuZnJpY3Rpb24gPyBwYXJlbnRBLmZyaWN0aW9uIDogcGFyZW50Qi5mcmljdGlvbjtcbiAgICAgICAgcGFpci5mcmljdGlvblN0YXRpYyA9IHBhcmVudEEuZnJpY3Rpb25TdGF0aWMgPiBwYXJlbnRCLmZyaWN0aW9uU3RhdGljID8gcGFyZW50QS5mcmljdGlvblN0YXRpYyA6IHBhcmVudEIuZnJpY3Rpb25TdGF0aWM7XG4gICAgICAgIHBhaXIucmVzdGl0dXRpb24gPSBwYXJlbnRBLnJlc3RpdHV0aW9uID4gcGFyZW50Qi5yZXN0aXR1dGlvbiA/IHBhcmVudEEucmVzdGl0dXRpb24gOiBwYXJlbnRCLnJlc3RpdHV0aW9uO1xuICAgICAgICBwYWlyLnNsb3AgPSBwYXJlbnRBLnNsb3AgPiBwYXJlbnRCLnNsb3AgPyBwYXJlbnRBLnNsb3AgOiBwYXJlbnRCLnNsb3A7XG5cbiAgICAgICAgY29sbGlzaW9uLnBhaXIgPSBwYWlyO1xuICAgICAgICBhY3RpdmVDb250YWN0cy5sZW5ndGggPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdXBwb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1cHBvcnQgPSBzdXBwb3J0c1tpXSxcbiAgICAgICAgICAgICAgICBjb250YWN0SWQgPSBzdXBwb3J0LmJvZHkgPT09IHBhcmVudEEgPyBzdXBwb3J0LmluZGV4IDogcGFyZW50QVZlcnRpY2VzTGVuZ3RoICsgc3VwcG9ydC5pbmRleCxcbiAgICAgICAgICAgICAgICBjb250YWN0ID0gY29udGFjdHNbY29udGFjdElkXTtcblxuICAgICAgICAgICAgaWYgKGNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDb250YWN0cy5wdXNoKGNvbnRhY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDb250YWN0cy5wdXNoKGNvbnRhY3RzW2NvbnRhY3RJZF0gPSBDb250YWN0LmNyZWF0ZShzdXBwb3J0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFNldCBhIHBhaXIgYXMgYWN0aXZlIG9yIGluYWN0aXZlLlxuICAgICAqIEBtZXRob2Qgc2V0QWN0aXZlXG4gICAgICogQHBhcmFtIHtwYWlyfSBwYWlyXG4gICAgICogQHBhcmFtIHtib29sfSBpc0FjdGl2ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBQYWlyLnNldEFjdGl2ZSA9IGZ1bmN0aW9uKHBhaXIsIGlzQWN0aXZlLCB0aW1lc3RhbXApIHtcbiAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICBwYWlyLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhaXIudGltZVVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWlyLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZCBmb3IgdGhlIGdpdmVuIHBhaXIuXG4gICAgICogQG1ldGhvZCBpZFxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlCXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBVbmlxdWUgcGFpcklkXG4gICAgICovXG4gICAgUGFpci5pZCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qikge1xuICAgICAgICBpZiAoYm9keUEuaWQgPCBib2R5Qi5pZCkge1xuICAgICAgICAgICAgcmV0dXJuICdBJyArIGJvZHlBLmlkICsgJ0InICsgYm9keUIuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ0EnICsgYm9keUIuaWQgKyAnQicgKyBib2R5QS5pZDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuQ29uc3RyYWludGAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29uc3RyYWludHMuXG4qIENvbnN0cmFpbnRzIGFyZSB1c2VkIGZvciBzcGVjaWZ5aW5nIHRoYXQgYSBmaXhlZCBkaXN0YW5jZSBtdXN0IGJlIG1haW50YWluZWQgYmV0d2VlbiB0d28gYm9kaWVzIChvciBhIGJvZHkgYW5kIGEgZml4ZWQgd29ybGQtc3BhY2UgcG9zaXRpb24pLlxuKiBUaGUgc3RpZmZuZXNzIG9mIGNvbnN0cmFpbnRzIGNhbiBiZSBtb2RpZmllZCB0byBjcmVhdGUgc3ByaW5ncyBvciBlbGFzdGljLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgQ29uc3RyYWludFxuKi9cblxudmFyIENvbnN0cmFpbnQgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xuXG52YXIgVmVydGljZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIFZlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgU2xlZXBpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIEJvdW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQXhlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIENvbnN0cmFpbnQuX3dhcm1pbmcgPSAwLjQ7XG4gICAgQ29uc3RyYWludC5fdG9ycXVlRGFtcGVuID0gMTtcbiAgICBDb25zdHJhaW50Ll9taW5MZW5ndGggPSAwLjAwMDAwMTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29uc3RyYWludC5cbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIFRvIHNpbXVsYXRlIGEgcmV2b2x1dGUgY29uc3RyYWludCAob3IgcGluIGpvaW50KSBzZXQgYGxlbmd0aDogMGAgYW5kIGEgaGlnaCBgc3RpZmZuZXNzYCB2YWx1ZSAoZS5nLiBgMC43YCBvciBhYm92ZSkuXG4gICAgICogSWYgdGhlIGNvbnN0cmFpbnQgaXMgdW5zdGFibGUsIHRyeSBsb3dlcmluZyB0aGUgYHN0aWZmbmVzc2AgdmFsdWUgYW5kIC8gb3IgaW5jcmVhc2luZyBgZW5naW5lLmNvbnN0cmFpbnRJdGVyYXRpb25zYC5cbiAgICAgKiBGb3IgY29tcG91bmQgYm9kaWVzLCBjb25zdHJhaW50cyBtdXN0IGJlIGFwcGxpZWQgdG8gdGhlIHBhcmVudCBib2R5IChub3Qgb25lIG9mIGl0cyBwYXJ0cykuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqL1xuICAgIENvbnN0cmFpbnQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgY29uc3RyYWludCA9IG9wdGlvbnM7XG5cbiAgICAgICAgLy8gaWYgYm9kaWVzIGRlZmluZWQgYnV0IG5vIHBvaW50cywgdXNlIGJvZHkgY2VudHJlXG4gICAgICAgIGlmIChjb25zdHJhaW50LmJvZHlBICYmICFjb25zdHJhaW50LnBvaW50QSlcbiAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRBID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGlmIChjb25zdHJhaW50LmJvZHlCICYmICFjb25zdHJhaW50LnBvaW50QilcbiAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRCID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHN0YXRpYyBsZW5ndGggdXNpbmcgaW5pdGlhbCB3b3JsZCBzcGFjZSBwb2ludHNcbiAgICAgICAgdmFyIGluaXRpYWxQb2ludEEgPSBjb25zdHJhaW50LmJvZHlBID8gVmVjdG9yLmFkZChjb25zdHJhaW50LmJvZHlBLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50QSkgOiBjb25zdHJhaW50LnBvaW50QSxcbiAgICAgICAgICAgIGluaXRpYWxQb2ludEIgPSBjb25zdHJhaW50LmJvZHlCID8gVmVjdG9yLmFkZChjb25zdHJhaW50LmJvZHlCLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50QikgOiBjb25zdHJhaW50LnBvaW50QixcbiAgICAgICAgICAgIGxlbmd0aCA9IFZlY3Rvci5tYWduaXR1ZGUoVmVjdG9yLnN1Yihpbml0aWFsUG9pbnRBLCBpbml0aWFsUG9pbnRCKSk7XG4gICAgXG4gICAgICAgIGNvbnN0cmFpbnQubGVuZ3RoID0gdHlwZW9mIGNvbnN0cmFpbnQubGVuZ3RoICE9PSAndW5kZWZpbmVkJyA/IGNvbnN0cmFpbnQubGVuZ3RoIDogbGVuZ3RoO1xuXG4gICAgICAgIC8vIG9wdGlvbiBkZWZhdWx0c1xuICAgICAgICBjb25zdHJhaW50LmlkID0gY29uc3RyYWludC5pZCB8fCBDb21tb24ubmV4dElkKCk7XG4gICAgICAgIGNvbnN0cmFpbnQubGFiZWwgPSBjb25zdHJhaW50LmxhYmVsIHx8ICdDb25zdHJhaW50JztcbiAgICAgICAgY29uc3RyYWludC50eXBlID0gJ2NvbnN0cmFpbnQnO1xuICAgICAgICBjb25zdHJhaW50LnN0aWZmbmVzcyA9IGNvbnN0cmFpbnQuc3RpZmZuZXNzIHx8IChjb25zdHJhaW50Lmxlbmd0aCA+IDAgPyAxIDogMC43KTtcbiAgICAgICAgY29uc3RyYWludC5kYW1waW5nID0gY29uc3RyYWludC5kYW1waW5nIHx8IDA7XG4gICAgICAgIGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyA9IGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyB8fCAwO1xuICAgICAgICBjb25zdHJhaW50LmFuZ2xlQSA9IGNvbnN0cmFpbnQuYm9keUEgPyBjb25zdHJhaW50LmJvZHlBLmFuZ2xlIDogY29uc3RyYWludC5hbmdsZUE7XG4gICAgICAgIGNvbnN0cmFpbnQuYW5nbGVCID0gY29uc3RyYWludC5ib2R5QiA/IGNvbnN0cmFpbnQuYm9keUIuYW5nbGUgOiBjb25zdHJhaW50LmFuZ2xlQjtcbiAgICAgICAgY29uc3RyYWludC5wbHVnaW4gPSB7fTtcblxuICAgICAgICAvLyByZW5kZXJcbiAgICAgICAgdmFyIHJlbmRlciA9IHtcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogJyNmZmZmZmYnLFxuICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgYW5jaG9yczogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb25zdHJhaW50Lmxlbmd0aCA9PT0gMCAmJiBjb25zdHJhaW50LnN0aWZmbmVzcyA+IDAuMSkge1xuICAgICAgICAgICAgcmVuZGVyLnR5cGUgPSAncGluJztcbiAgICAgICAgICAgIHJlbmRlci5hbmNob3JzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc3RyYWludC5zdGlmZm5lc3MgPCAwLjkpIHtcbiAgICAgICAgICAgIHJlbmRlci50eXBlID0gJ3NwcmluZyc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdHJhaW50LnJlbmRlciA9IENvbW1vbi5leHRlbmQocmVuZGVyLCBjb25zdHJhaW50LnJlbmRlcik7XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGZvciBzb2x2aW5nIGJ5IGNvbnN0cmFpbnQgd2FybWluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcHJlU29sdmVBbGxcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICovXG4gICAgQ29uc3RyYWludC5wcmVTb2x2ZUFsbCA9IGZ1bmN0aW9uKGJvZGllcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IGJvZHkuY29uc3RyYWludEltcHVsc2U7XG5cbiAgICAgICAgICAgIGlmIChib2R5LmlzU3RhdGljIHx8IChpbXB1bHNlLnggPT09IDAgJiYgaW1wdWxzZS55ID09PSAwICYmIGltcHVsc2UuYW5nbGUgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvZHkucG9zaXRpb24ueCArPSBpbXB1bHNlLng7XG4gICAgICAgICAgICBib2R5LnBvc2l0aW9uLnkgKz0gaW1wdWxzZS55O1xuICAgICAgICAgICAgYm9keS5hbmdsZSArPSBpbXB1bHNlLmFuZ2xlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNvbHZlcyBhbGwgY29uc3RyYWludHMgaW4gYSBsaXN0IG9mIGNvbGxpc2lvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHNvbHZlQWxsXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50W119IGNvbnN0cmFpbnRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhXG4gICAgICovXG4gICAgQ29uc3RyYWludC5zb2x2ZUFsbCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBkZWx0YSkge1xuICAgICAgICB2YXIgdGltZVNjYWxlID0gQ29tbW9uLmNsYW1wKGRlbHRhIC8gQ29tbW9uLl9iYXNlRGVsdGEsIDAsIDEpO1xuXG4gICAgICAgIC8vIFNvbHZlIGZpeGVkIGNvbnN0cmFpbnRzIGZpcnN0LlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldLFxuICAgICAgICAgICAgICAgIGZpeGVkQSA9ICFjb25zdHJhaW50LmJvZHlBIHx8IChjb25zdHJhaW50LmJvZHlBICYmIGNvbnN0cmFpbnQuYm9keUEuaXNTdGF0aWMpLFxuICAgICAgICAgICAgICAgIGZpeGVkQiA9ICFjb25zdHJhaW50LmJvZHlCIHx8IChjb25zdHJhaW50LmJvZHlCICYmIGNvbnN0cmFpbnQuYm9keUIuaXNTdGF0aWMpO1xuXG4gICAgICAgICAgICBpZiAoZml4ZWRBIHx8IGZpeGVkQikge1xuICAgICAgICAgICAgICAgIENvbnN0cmFpbnQuc29sdmUoY29uc3RyYWludHNbaV0sIHRpbWVTY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb2x2ZSBmcmVlIGNvbnN0cmFpbnRzIGxhc3QuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgICAgZml4ZWRBID0gIWNvbnN0cmFpbnQuYm9keUEgfHwgKGNvbnN0cmFpbnQuYm9keUEgJiYgY29uc3RyYWludC5ib2R5QS5pc1N0YXRpYyk7XG4gICAgICAgICAgICBmaXhlZEIgPSAhY29uc3RyYWludC5ib2R5QiB8fCAoY29uc3RyYWludC5ib2R5QiAmJiBjb25zdHJhaW50LmJvZHlCLmlzU3RhdGljKTtcblxuICAgICAgICAgICAgaWYgKCFmaXhlZEEgJiYgIWZpeGVkQikge1xuICAgICAgICAgICAgICAgIENvbnN0cmFpbnQuc29sdmUoY29uc3RyYWludHNbaV0sIHRpbWVTY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU29sdmVzIGEgZGlzdGFuY2UgY29uc3RyYWludCB3aXRoIEdhdXNzLVNpZWRlbCBtZXRob2QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIHNvbHZlXG4gICAgICogQHBhcmFtIHtjb25zdHJhaW50fSBjb25zdHJhaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVTY2FsZVxuICAgICAqL1xuICAgIENvbnN0cmFpbnQuc29sdmUgPSBmdW5jdGlvbihjb25zdHJhaW50LCB0aW1lU2NhbGUpIHtcbiAgICAgICAgdmFyIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcbiAgICAgICAgICAgIGJvZHlCID0gY29uc3RyYWludC5ib2R5QixcbiAgICAgICAgICAgIHBvaW50QSA9IGNvbnN0cmFpbnQucG9pbnRBLFxuICAgICAgICAgICAgcG9pbnRCID0gY29uc3RyYWludC5wb2ludEI7XG5cbiAgICAgICAgaWYgKCFib2R5QSAmJiAhYm9keUIpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gdXBkYXRlIHJlZmVyZW5jZSBhbmdsZVxuICAgICAgICBpZiAoYm9keUEgJiYgIWJvZHlBLmlzU3RhdGljKSB7XG4gICAgICAgICAgICBWZWN0b3Iucm90YXRlKHBvaW50QSwgYm9keUEuYW5nbGUgLSBjb25zdHJhaW50LmFuZ2xlQSwgcG9pbnRBKTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQuYW5nbGVBID0gYm9keUEuYW5nbGU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHVwZGF0ZSByZWZlcmVuY2UgYW5nbGVcbiAgICAgICAgaWYgKGJvZHlCICYmICFib2R5Qi5pc1N0YXRpYykge1xuICAgICAgICAgICAgVmVjdG9yLnJvdGF0ZShwb2ludEIsIGJvZHlCLmFuZ2xlIC0gY29uc3RyYWludC5hbmdsZUIsIHBvaW50Qik7XG4gICAgICAgICAgICBjb25zdHJhaW50LmFuZ2xlQiA9IGJvZHlCLmFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvaW50QVdvcmxkID0gcG9pbnRBLFxuICAgICAgICAgICAgcG9pbnRCV29ybGQgPSBwb2ludEI7XG5cbiAgICAgICAgaWYgKGJvZHlBKSBwb2ludEFXb3JsZCA9IFZlY3Rvci5hZGQoYm9keUEucG9zaXRpb24sIHBvaW50QSk7XG4gICAgICAgIGlmIChib2R5QikgcG9pbnRCV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlCLnBvc2l0aW9uLCBwb2ludEIpO1xuXG4gICAgICAgIGlmICghcG9pbnRBV29ybGQgfHwgIXBvaW50QldvcmxkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IFZlY3Rvci5zdWIocG9pbnRBV29ybGQsIHBvaW50QldvcmxkKSxcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBWZWN0b3IubWFnbml0dWRlKGRlbHRhKTtcblxuICAgICAgICAvLyBwcmV2ZW50IHNpbmd1bGFyaXR5XG4gICAgICAgIGlmIChjdXJyZW50TGVuZ3RoIDwgQ29uc3RyYWludC5fbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoID0gQ29uc3RyYWludC5fbWluTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc29sdmUgZGlzdGFuY2UgY29uc3RyYWludCB3aXRoIEdhdXNzLVNpZWRlbCBtZXRob2RcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAoY3VycmVudExlbmd0aCAtIGNvbnN0cmFpbnQubGVuZ3RoKSAvIGN1cnJlbnRMZW5ndGgsXG4gICAgICAgICAgICBpc1JpZ2lkID0gY29uc3RyYWludC5zdGlmZm5lc3MgPj0gMSB8fCBjb25zdHJhaW50Lmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIHN0aWZmbmVzcyA9IGlzUmlnaWQgPyBjb25zdHJhaW50LnN0aWZmbmVzcyAqIHRpbWVTY2FsZSBcbiAgICAgICAgICAgICAgICA6IGNvbnN0cmFpbnQuc3RpZmZuZXNzICogdGltZVNjYWxlICogdGltZVNjYWxlLFxuICAgICAgICAgICAgZGFtcGluZyA9IGNvbnN0cmFpbnQuZGFtcGluZyAqIHRpbWVTY2FsZSxcbiAgICAgICAgICAgIGZvcmNlID0gVmVjdG9yLm11bHQoZGVsdGEsIGRpZmZlcmVuY2UgKiBzdGlmZm5lc3MpLFxuICAgICAgICAgICAgbWFzc1RvdGFsID0gKGJvZHlBID8gYm9keUEuaW52ZXJzZU1hc3MgOiAwKSArIChib2R5QiA/IGJvZHlCLmludmVyc2VNYXNzIDogMCksXG4gICAgICAgICAgICBpbmVydGlhVG90YWwgPSAoYm9keUEgPyBib2R5QS5pbnZlcnNlSW5lcnRpYSA6IDApICsgKGJvZHlCID8gYm9keUIuaW52ZXJzZUluZXJ0aWEgOiAwKSxcbiAgICAgICAgICAgIHJlc2lzdGFuY2VUb3RhbCA9IG1hc3NUb3RhbCArIGluZXJ0aWFUb3RhbCxcbiAgICAgICAgICAgIHRvcnF1ZSxcbiAgICAgICAgICAgIHNoYXJlLFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgbm9ybWFsVmVsb2NpdHksXG4gICAgICAgICAgICByZWxhdGl2ZVZlbG9jaXR5O1xuICAgIFxuICAgICAgICBpZiAoZGFtcGluZyA+IDApIHtcbiAgICAgICAgICAgIHZhciB6ZXJvID0gVmVjdG9yLmNyZWF0ZSgpO1xuICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLmRpdihkZWx0YSwgY3VycmVudExlbmd0aCk7XG5cbiAgICAgICAgICAgIHJlbGF0aXZlVmVsb2NpdHkgPSBWZWN0b3Iuc3ViKFxuICAgICAgICAgICAgICAgIGJvZHlCICYmIFZlY3Rvci5zdWIoYm9keUIucG9zaXRpb24sIGJvZHlCLnBvc2l0aW9uUHJldikgfHwgemVybyxcbiAgICAgICAgICAgICAgICBib2R5QSAmJiBWZWN0b3Iuc3ViKGJvZHlBLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvblByZXYpIHx8IHplcm9cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG5vcm1hbFZlbG9jaXR5ID0gVmVjdG9yLmRvdChub3JtYWwsIHJlbGF0aXZlVmVsb2NpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvZHlBICYmICFib2R5QS5pc1N0YXRpYykge1xuICAgICAgICAgICAgc2hhcmUgPSBib2R5QS5pbnZlcnNlTWFzcyAvIG1hc3NUb3RhbDtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBhcHBsaWVkIGltcHVsc2VzIGZvciBwb3N0IHNvbHZpbmdcbiAgICAgICAgICAgIGJvZHlBLmNvbnN0cmFpbnRJbXB1bHNlLnggLT0gZm9yY2UueCAqIHNoYXJlO1xuICAgICAgICAgICAgYm9keUEuY29uc3RyYWludEltcHVsc2UueSAtPSBmb3JjZS55ICogc2hhcmU7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IGZvcmNlc1xuICAgICAgICAgICAgYm9keUEucG9zaXRpb24ueCAtPSBmb3JjZS54ICogc2hhcmU7XG4gICAgICAgICAgICBib2R5QS5wb3NpdGlvbi55IC09IGZvcmNlLnkgKiBzaGFyZTtcblxuICAgICAgICAgICAgLy8gYXBwbHkgZGFtcGluZ1xuICAgICAgICAgICAgaWYgKGRhbXBpbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnggLT0gZGFtcGluZyAqIG5vcm1hbC54ICogbm9ybWFsVmVsb2NpdHkgKiBzaGFyZTtcbiAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvblByZXYueSAtPSBkYW1waW5nICogbm9ybWFsLnkgKiBub3JtYWxWZWxvY2l0eSAqIHNoYXJlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhcHBseSB0b3JxdWVcbiAgICAgICAgICAgIHRvcnF1ZSA9IChWZWN0b3IuY3Jvc3MocG9pbnRBLCBmb3JjZSkgLyByZXNpc3RhbmNlVG90YWwpICogQ29uc3RyYWludC5fdG9ycXVlRGFtcGVuICogYm9keUEuaW52ZXJzZUluZXJ0aWEgKiAoMSAtIGNvbnN0cmFpbnQuYW5ndWxhclN0aWZmbmVzcyk7XG4gICAgICAgICAgICBib2R5QS5jb25zdHJhaW50SW1wdWxzZS5hbmdsZSAtPSB0b3JxdWU7XG4gICAgICAgICAgICBib2R5QS5hbmdsZSAtPSB0b3JxdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9keUIgJiYgIWJvZHlCLmlzU3RhdGljKSB7XG4gICAgICAgICAgICBzaGFyZSA9IGJvZHlCLmludmVyc2VNYXNzIC8gbWFzc1RvdGFsO1xuXG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGFwcGxpZWQgaW1wdWxzZXMgZm9yIHBvc3Qgc29sdmluZ1xuICAgICAgICAgICAgYm9keUIuY29uc3RyYWludEltcHVsc2UueCArPSBmb3JjZS54ICogc2hhcmU7XG4gICAgICAgICAgICBib2R5Qi5jb25zdHJhaW50SW1wdWxzZS55ICs9IGZvcmNlLnkgKiBzaGFyZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYXBwbHkgZm9yY2VzXG4gICAgICAgICAgICBib2R5Qi5wb3NpdGlvbi54ICs9IGZvcmNlLnggKiBzaGFyZTtcbiAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uLnkgKz0gZm9yY2UueSAqIHNoYXJlO1xuXG4gICAgICAgICAgICAvLyBhcHBseSBkYW1waW5nXG4gICAgICAgICAgICBpZiAoZGFtcGluZyA+IDApIHtcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvblByZXYueCArPSBkYW1waW5nICogbm9ybWFsLnggKiBub3JtYWxWZWxvY2l0eSAqIHNoYXJlO1xuICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55ICs9IGRhbXBpbmcgKiBub3JtYWwueSAqIG5vcm1hbFZlbG9jaXR5ICogc2hhcmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IHRvcnF1ZVxuICAgICAgICAgICAgdG9ycXVlID0gKFZlY3Rvci5jcm9zcyhwb2ludEIsIGZvcmNlKSAvIHJlc2lzdGFuY2VUb3RhbCkgKiBDb25zdHJhaW50Ll90b3JxdWVEYW1wZW4gKiBib2R5Qi5pbnZlcnNlSW5lcnRpYSAqICgxIC0gY29uc3RyYWludC5hbmd1bGFyU3RpZmZuZXNzKTtcbiAgICAgICAgICAgIGJvZHlCLmNvbnN0cmFpbnRJbXB1bHNlLmFuZ2xlICs9IHRvcnF1ZTtcbiAgICAgICAgICAgIGJvZHlCLmFuZ2xlICs9IHRvcnF1ZTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGJvZHkgdXBkYXRlcyByZXF1aXJlZCBhZnRlciBzb2x2aW5nIGNvbnN0cmFpbnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBwb3N0U29sdmVBbGxcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICovXG4gICAgQ29uc3RyYWludC5wb3N0U29sdmVBbGwgPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBib2R5LmNvbnN0cmFpbnRJbXB1bHNlO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYyB8fCAoaW1wdWxzZS54ID09PSAwICYmIGltcHVsc2UueSA9PT0gMCAmJiBpbXB1bHNlLmFuZ2xlID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgZ2VvbWV0cnkgYW5kIHJlc2V0XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHkucGFydHNbal07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgVmVydGljZXMudHJhbnNsYXRlKHBhcnQudmVydGljZXMsIGltcHVsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueCArPSBpbXB1bHNlLng7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBpbXB1bHNlLnk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGltcHVsc2UuYW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgVmVydGljZXMucm90YXRlKHBhcnQudmVydGljZXMsIGltcHVsc2UuYW5nbGUsIGJvZHkucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBBeGVzLnJvdGF0ZShwYXJ0LmF4ZXMsIGltcHVsc2UuYW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3Rvci5yb3RhdGVBYm91dChwYXJ0LnBvc2l0aW9uLCBpbXB1bHNlLmFuZ2xlLCBib2R5LnBvc2l0aW9uLCBwYXJ0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEJvdW5kcy51cGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIGJvZHkudmVsb2NpdHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkYW1wZW4gdGhlIGNhY2hlZCBpbXB1bHNlIGZvciB3YXJtaW5nIG5leHQgc3RlcFxuICAgICAgICAgICAgaW1wdWxzZS5hbmdsZSAqPSBDb25zdHJhaW50Ll93YXJtaW5nO1xuICAgICAgICAgICAgaW1wdWxzZS54ICo9IENvbnN0cmFpbnQuX3dhcm1pbmc7XG4gICAgICAgICAgICBpbXB1bHNlLnkgKj0gQ29uc3RyYWludC5fd2FybWluZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiBgY29uc3RyYWludC5wb2ludEFgLCBhY2NvdW50aW5nIGZvciBgY29uc3RyYWludC5ib2R5QWAuXG4gICAgICogQG1ldGhvZCBwb2ludEFXb3JsZFxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEByZXR1cm5zIHt2ZWN0b3J9IHRoZSB3b3JsZC1zcGFjZSBwb3NpdGlvblxuICAgICAqL1xuICAgIENvbnN0cmFpbnQucG9pbnRBV29ybGQgPSBmdW5jdGlvbihjb25zdHJhaW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAoY29uc3RyYWludC5ib2R5QSA/IGNvbnN0cmFpbnQuYm9keUEucG9zaXRpb24ueCA6IDApIFxuICAgICAgICAgICAgICAgICsgKGNvbnN0cmFpbnQucG9pbnRBID8gY29uc3RyYWludC5wb2ludEEueCA6IDApLFxuICAgICAgICAgICAgeTogKGNvbnN0cmFpbnQuYm9keUEgPyBjb25zdHJhaW50LmJvZHlBLnBvc2l0aW9uLnkgOiAwKSBcbiAgICAgICAgICAgICAgICArIChjb25zdHJhaW50LnBvaW50QSA/IGNvbnN0cmFpbnQucG9pbnRBLnkgOiAwKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiBgY29uc3RyYWludC5wb2ludEJgLCBhY2NvdW50aW5nIGZvciBgY29uc3RyYWludC5ib2R5QmAuXG4gICAgICogQG1ldGhvZCBwb2ludEJXb3JsZFxuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludH0gY29uc3RyYWludFxuICAgICAqIEByZXR1cm5zIHt2ZWN0b3J9IHRoZSB3b3JsZC1zcGFjZSBwb3NpdGlvblxuICAgICAqL1xuICAgIENvbnN0cmFpbnQucG9pbnRCV29ybGQgPSBmdW5jdGlvbihjb25zdHJhaW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAoY29uc3RyYWludC5ib2R5QiA/IGNvbnN0cmFpbnQuYm9keUIucG9zaXRpb24ueCA6IDApIFxuICAgICAgICAgICAgICAgICsgKGNvbnN0cmFpbnQucG9pbnRCID8gY29uc3RyYWludC5wb2ludEIueCA6IDApLFxuICAgICAgICAgICAgeTogKGNvbnN0cmFpbnQuYm9keUIgPyBjb25zdHJhaW50LmJvZHlCLnBvc2l0aW9uLnkgOiAwKSBcbiAgICAgICAgICAgICAgICArIChjb25zdHJhaW50LnBvaW50QiA/IGNvbnN0cmFpbnQucG9pbnRCLnkgOiAwKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdW5pcXVlbHkgaWRlbnRpZnlpbmcgbnVtYmVyIGdlbmVyYXRlZCBpbiBgQ29tcG9zaXRlLmNyZWF0ZWAgYnkgYENvbW1vbi5uZXh0SWRgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIGRlbm90aW5nIHRoZSB0eXBlIG9mIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgXCJjb25zdHJhaW50XCJcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGFyYml0cmFyeSBgU3RyaW5nYCBuYW1lIHRvIGhlbHAgdGhlIHVzZXIgaWRlbnRpZnkgYW5kIG1hbmFnZSBib2RpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbGFiZWxcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcIkNvbnN0cmFpbnRcIlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgdGhhdCBkZWZpbmVzIHRoZSByZW5kZXJpbmcgcHJvcGVydGllcyB0byBiZSBjb25zdW1lZCBieSB0aGUgbW9kdWxlIGBNYXR0ZXIuUmVuZGVyYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXJcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgY29uc3RyYWludCBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLnZpc2libGVcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IGRlZmluZXMgdGhlIGxpbmUgd2lkdGggdG8gdXNlIHdoZW4gcmVuZGVyaW5nIHRoZSBjb25zdHJhaW50IG91dGxpbmUuXG4gICAgICogQSB2YWx1ZSBvZiBgMGAgbWVhbnMgbm8gb3V0bGluZSB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHJlbmRlci5saW5lV2lkdGhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBTdHJpbmdgIHRoYXQgZGVmaW5lcyB0aGUgc3Ryb2tlIHN0eWxlIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgY29uc3RyYWludCBvdXRsaW5lLlxuICAgICAqIEl0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdXNpbmcgYSBjYW52YXMsIHNvIGl0IGFjY2VwdHMgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIuc3Ryb2tlU3R5bGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBhIHJhbmRvbSBjb2xvdXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFN0cmluZ2AgdGhhdCBkZWZpbmVzIHRoZSBjb25zdHJhaW50IHJlbmRlcmluZyB0eXBlLiBcbiAgICAgKiBUaGUgcG9zc2libGUgdmFsdWVzIGFyZSAnbGluZScsICdwaW4nLCAnc3ByaW5nJy5cbiAgICAgKiBBbiBhcHByb3ByaWF0ZSByZW5kZXIgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2hvc2VuIHVubGVzcyBvbmUgaXMgZ2l2ZW4gaW4gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSByZW5kZXIudHlwZVxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdsaW5lJ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgQm9vbGVhbmAgdGhhdCBkZWZpbmVzIGlmIHRoZSBjb25zdHJhaW50J3MgYW5jaG9yIHBvaW50cyBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcmVuZGVyLmFuY2hvcnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IHBvc3NpYmxlIGBCb2R5YCB0aGF0IHRoaXMgY29uc3RyYWludCBpcyBhdHRhY2hlZCB0by5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kIHBvc3NpYmxlIGBCb2R5YCB0aGF0IHRoaXMgY29uc3RyYWludCBpcyBhdHRhY2hlZCB0by5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBWZWN0b3JgIHRoYXQgc3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhlIGNvbnN0cmFpbnQgZnJvbSBjZW50ZXIgb2YgdGhlIGBjb25zdHJhaW50LmJvZHlBYCBpZiBkZWZpbmVkLCBvdGhlcndpc2UgYSB3b3JsZC1zcGFjZSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwb2ludEFcbiAgICAgKiBAdHlwZSB2ZWN0b3JcbiAgICAgKiBAZGVmYXVsdCB7IHg6IDAsIHk6IDAgfVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgVmVjdG9yYCB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBjb25zdHJhaW50IGZyb20gY2VudGVyIG9mIHRoZSBgY29uc3RyYWludC5ib2R5QmAgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIGEgd29ybGQtc3BhY2UgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgcG9pbnRCXG4gICAgICogQHR5cGUgdmVjdG9yXG4gICAgICogQGRlZmF1bHQgeyB4OiAwLCB5OiAwIH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIHN0aWZmbmVzcyBvZiB0aGUgY29uc3RyYWludCwgaS5lLiB0aGUgcmF0ZSBhdCB3aGljaCBpdCByZXR1cm5zIHRvIGl0cyByZXN0aW5nIGBjb25zdHJhaW50Lmxlbmd0aGAuXG4gICAgICogQSB2YWx1ZSBvZiBgMWAgbWVhbnMgdGhlIGNvbnN0cmFpbnQgc2hvdWxkIGJlIHZlcnkgc3RpZmYuXG4gICAgICogQSB2YWx1ZSBvZiBgMC4yYCBtZWFucyB0aGUgY29uc3RyYWludCBhY3RzIGxpa2UgYSBzb2Z0IHNwcmluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBkYW1waW5nIG9mIHRoZSBjb25zdHJhaW50LCBcbiAgICAgKiBpLmUuIHRoZSBhbW91bnQgb2YgcmVzaXN0YW5jZSBhcHBsaWVkIHRvIGVhY2ggYm9keSBiYXNlZCBvbiB0aGVpciB2ZWxvY2l0aWVzIHRvIGxpbWl0IHRoZSBhbW91bnQgb2Ygb3NjaWxsYXRpb24uXG4gICAgICogRGFtcGluZyB3aWxsIG9ubHkgYmUgYXBwYXJlbnQgd2hlbiB0aGUgY29uc3RyYWludCBhbHNvIGhhcyBhIHZlcnkgbG93IGBzdGlmZm5lc3NgLlxuICAgICAqIEEgdmFsdWUgb2YgYDAuMWAgbWVhbnMgdGhlIGNvbnN0cmFpbnQgd2lsbCBhcHBseSBoZWF2eSBkYW1waW5nLCByZXN1bHRpbmcgaW4gbGl0dGxlIHRvIG5vIG9zY2lsbGF0aW9uLlxuICAgICAqIEEgdmFsdWUgb2YgYDBgIG1lYW5zIHRoZSBjb25zdHJhaW50IHdpbGwgYXBwbHkgbm8gZGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkYW1waW5nXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlc3RpbmcgbGVuZ3RoIG9mIHRoZSBjb25zdHJhaW50LiBcbiAgICAgKiBJdCBpcyBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgaW4gYENvbnN0cmFpbnQuY3JlYXRlYCBmcm9tIGluaXRpYWwgcG9zaXRpb25zIG9mIHRoZSBgY29uc3RyYWludC5ib2R5QWAgYW5kIGBjb25zdHJhaW50LmJvZHlCYC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBsZW5ndGhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXNlcnZlZCBmb3Igc3RvcmluZyBwbHVnaW4tc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwbHVnaW5cbiAgICAgKiBAdHlwZSB7fVxuICAgICAqL1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkF4ZXNgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNldHMgb2YgYXhlcy5cbipcbiogQGNsYXNzIEF4ZXNcbiovXG5cbnZhciBBeGVzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQXhlcztcblxudmFyIFZlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzZXQgb2YgYXhlcyBmcm9tIHRoZSBnaXZlbiB2ZXJ0aWNlcy5cbiAgICAgKiBAbWV0aG9kIGZyb21WZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7dmVydGljZXN9IHZlcnRpY2VzXG4gICAgICogQHJldHVybiB7YXhlc30gQSBuZXcgYXhlcyBmcm9tIHRoZSBnaXZlbiB2ZXJ0aWNlc1xuICAgICAqL1xuICAgIEF4ZXMuZnJvbVZlcnRpY2VzID0gZnVuY3Rpb24odmVydGljZXMpIHtcbiAgICAgICAgdmFyIGF4ZXMgPSB7fTtcblxuICAgICAgICAvLyBmaW5kIHRoZSB1bmlxdWUgYXhlcywgdXNpbmcgZWRnZSBub3JtYWwgZ3JhZGllbnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqID0gKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aCwgXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yLm5vcm1hbGlzZSh7IFxuICAgICAgICAgICAgICAgICAgICB4OiB2ZXJ0aWNlc1tqXS55IC0gdmVydGljZXNbaV0ueSwgXG4gICAgICAgICAgICAgICAgICAgIHk6IHZlcnRpY2VzW2ldLnggLSB2ZXJ0aWNlc1tqXS54XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQgPSAobm9ybWFsLnkgPT09IDApID8gSW5maW5pdHkgOiAobm9ybWFsLnggLyBub3JtYWwueSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGxpbWl0IHByZWNpc2lvblxuICAgICAgICAgICAgZ3JhZGllbnQgPSBncmFkaWVudC50b0ZpeGVkKDMpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBheGVzW2dyYWRpZW50XSA9IG5vcm1hbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDb21tb24udmFsdWVzKGF4ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGEgc2V0IG9mIGF4ZXMgYnkgdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIEBtZXRob2Qgcm90YXRlXG4gICAgICogQHBhcmFtIHtheGVzfSBheGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICovXG4gICAgQXhlcy5yb3RhdGUgPSBmdW5jdGlvbihheGVzLCBhbmdsZSkge1xuICAgICAgICBpZiAoYW5nbGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSBheGVzW2ldLFxuICAgICAgICAgICAgICAgIHh4O1xuICAgICAgICAgICAgeHggPSBheGlzLnggKiBjb3MgLSBheGlzLnkgKiBzaW47XG4gICAgICAgICAgICBheGlzLnkgPSBheGlzLnggKiBzaW4gKyBheGlzLnkgKiBjb3M7XG4gICAgICAgICAgICBheGlzLnggPSB4eDtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuQm9kaWVzYCBtb2R1bGUgY29udGFpbnMgZmFjdG9yeSBtZXRob2RzIGZvciBjcmVhdGluZyByaWdpZCBib2R5IG1vZGVscyBcbiogd2l0aCBjb21tb25seSB1c2VkIGJvZHkgY29uZmlndXJhdGlvbnMgKHN1Y2ggYXMgcmVjdGFuZ2xlcywgY2lyY2xlcyBhbmQgb3RoZXIgcG9seWdvbnMpLlxuKlxuKiBTZWUgdGhlIGluY2x1ZGVkIHVzYWdlIFtleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL2xpYWJydS9tYXR0ZXItanMvdHJlZS9tYXN0ZXIvZXhhbXBsZXMpLlxuKlxuKiBAY2xhc3MgQm9kaWVzXG4qL1xuXG4vLyBUT0RPOiB0cnVlIGNpcmNsZSBib2RpZXNcblxudmFyIEJvZGllcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvZGllcztcblxudmFyIFZlcnRpY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIEJvZHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIEJvdW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgVmVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSByZWN0YW5nbGUgaHVsbC4gXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyByZWN0YW5nbGUgYm9keVxuICAgICAqL1xuICAgIEJvZGllcy5yZWN0YW5nbGUgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciByZWN0YW5nbGUgPSB7IFxuICAgICAgICAgICAgbGFiZWw6ICdSZWN0YW5nbGUgQm9keScsXG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiB4LCB5OiB5IH0sXG4gICAgICAgICAgICB2ZXJ0aWNlczogVmVydGljZXMuZnJvbVBhdGgoJ0wgMCAwIEwgJyArIHdpZHRoICsgJyAwIEwgJyArIHdpZHRoICsgJyAnICsgaGVpZ2h0ICsgJyBMIDAgJyArIGhlaWdodClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jaGFtZmVyKSB7XG4gICAgICAgICAgICB2YXIgY2hhbWZlciA9IG9wdGlvbnMuY2hhbWZlcjtcbiAgICAgICAgICAgIHJlY3RhbmdsZS52ZXJ0aWNlcyA9IFZlcnRpY2VzLmNoYW1mZXIocmVjdGFuZ2xlLnZlcnRpY2VzLCBjaGFtZmVyLnJhZGl1cywgXG4gICAgICAgICAgICAgICAgY2hhbWZlci5xdWFsaXR5LCBjaGFtZmVyLnF1YWxpdHlNaW4sIGNoYW1mZXIucXVhbGl0eU1heCk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQoe30sIHJlY3RhbmdsZSwgb3B0aW9ucykpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSB0cmFwZXpvaWQgaHVsbC4gXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCB0cmFwZXpvaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbG9wZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuIHtib2R5fSBBIG5ldyB0cmFwZXpvaWQgYm9keVxuICAgICAqL1xuICAgIEJvZGllcy50cmFwZXpvaWQgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzbG9wZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBzbG9wZSAqPSAwLjU7XG4gICAgICAgIHZhciByb29mID0gKDEgLSAoc2xvcGUgKiAyKSkgKiB3aWR0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciB4MSA9IHdpZHRoICogc2xvcGUsXG4gICAgICAgICAgICB4MiA9IHgxICsgcm9vZixcbiAgICAgICAgICAgIHgzID0geDIgKyB4MSxcbiAgICAgICAgICAgIHZlcnRpY2VzUGF0aDtcblxuICAgICAgICBpZiAoc2xvcGUgPCAwLjUpIHtcbiAgICAgICAgICAgIHZlcnRpY2VzUGF0aCA9ICdMIDAgMCBMICcgKyB4MSArICcgJyArICgtaGVpZ2h0KSArICcgTCAnICsgeDIgKyAnICcgKyAoLWhlaWdodCkgKyAnIEwgJyArIHgzICsgJyAwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRpY2VzUGF0aCA9ICdMIDAgMCBMICcgKyB4MiArICcgJyArICgtaGVpZ2h0KSArICcgTCAnICsgeDMgKyAnIDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYXBlem9pZCA9IHsgXG4gICAgICAgICAgICBsYWJlbDogJ1RyYXBlem9pZCBCb2R5JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHg6IHgsIHk6IHkgfSxcbiAgICAgICAgICAgIHZlcnRpY2VzOiBWZXJ0aWNlcy5mcm9tUGF0aCh2ZXJ0aWNlc1BhdGgpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbWZlcikge1xuICAgICAgICAgICAgdmFyIGNoYW1mZXIgPSBvcHRpb25zLmNoYW1mZXI7XG4gICAgICAgICAgICB0cmFwZXpvaWQudmVydGljZXMgPSBWZXJ0aWNlcy5jaGFtZmVyKHRyYXBlem9pZC52ZXJ0aWNlcywgY2hhbWZlci5yYWRpdXMsIFxuICAgICAgICAgICAgICAgIGNoYW1mZXIucXVhbGl0eSwgY2hhbWZlci5xdWFsaXR5TWluLCBjaGFtZmVyLnF1YWxpdHlNYXgpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbWZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHt9LCB0cmFwZXpvaWQsIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZCBib2R5IG1vZGVsIHdpdGggYSBjaXJjbGUgaHVsbC4gXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW21heFNpZGVzXVxuICAgICAqIEByZXR1cm4ge2JvZHl9IEEgbmV3IGNpcmNsZSBib2R5XG4gICAgICovXG4gICAgQm9kaWVzLmNpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgb3B0aW9ucywgbWF4U2lkZXMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIGNpcmNsZSA9IHtcbiAgICAgICAgICAgIGxhYmVsOiAnQ2lyY2xlIEJvZHknLFxuICAgICAgICAgICAgY2lyY2xlUmFkaXVzOiByYWRpdXNcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIGFwcHJveGltYXRlIGNpcmNsZXMgd2l0aCBwb2x5Z29ucyB1bnRpbCB0cnVlIGNpcmNsZXMgaW1wbGVtZW50ZWQgaW4gU0FUXG4gICAgICAgIG1heFNpZGVzID0gbWF4U2lkZXMgfHwgMjU7XG4gICAgICAgIHZhciBzaWRlcyA9IE1hdGguY2VpbChNYXRoLm1heCgxMCwgTWF0aC5taW4obWF4U2lkZXMsIHJhZGl1cykpKTtcblxuICAgICAgICAvLyBvcHRpbWlzYXRpb246IGFsd2F5cyB1c2UgZXZlbiBudW1iZXIgb2Ygc2lkZXMgKGhhbGYgdGhlIG51bWJlciBvZiB1bmlxdWUgYXhlcylcbiAgICAgICAgaWYgKHNpZGVzICUgMiA9PT0gMSlcbiAgICAgICAgICAgIHNpZGVzICs9IDE7XG5cbiAgICAgICAgcmV0dXJuIEJvZGllcy5wb2x5Z29uKHgsIHksIHNpZGVzLCByYWRpdXMsIENvbW1vbi5leHRlbmQoe30sIGNpcmNsZSwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJpZ2lkIGJvZHkgbW9kZWwgd2l0aCBhIHJlZ3VsYXIgcG9seWdvbiBodWxsIHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiBzaWRlcy4gXG4gICAgICogVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gb2YgdGhlIGBNYXR0ZXIuQm9keWAgbW9kdWxlIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBwb2x5Z29uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWRlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7Ym9keX0gQSBuZXcgcmVndWxhciBwb2x5Z29uIGJvZHlcbiAgICAgKi9cbiAgICBCb2RpZXMucG9seWdvbiA9IGZ1bmN0aW9uKHgsIHksIHNpZGVzLCByYWRpdXMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKHNpZGVzIDwgMylcbiAgICAgICAgICAgIHJldHVybiBCb2RpZXMuY2lyY2xlKHgsIHksIHJhZGl1cywgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBzaWRlcyxcbiAgICAgICAgICAgIHBhdGggPSAnJyxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoZXRhICogMC41O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gb2Zmc2V0ICsgKGkgKiB0aGV0YSksXG4gICAgICAgICAgICAgICAgeHggPSBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgICAgICAgICAgeXkgPSBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXM7XG5cbiAgICAgICAgICAgIHBhdGggKz0gJ0wgJyArIHh4LnRvRml4ZWQoMykgKyAnICcgKyB5eS50b0ZpeGVkKDMpICsgJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvbHlnb24gPSB7IFxuICAgICAgICAgICAgbGFiZWw6ICdQb2x5Z29uIEJvZHknLFxuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogeCwgeTogeSB9LFxuICAgICAgICAgICAgdmVydGljZXM6IFZlcnRpY2VzLmZyb21QYXRoKHBhdGgpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbWZlcikge1xuICAgICAgICAgICAgdmFyIGNoYW1mZXIgPSBvcHRpb25zLmNoYW1mZXI7XG4gICAgICAgICAgICBwb2x5Z29uLnZlcnRpY2VzID0gVmVydGljZXMuY2hhbWZlcihwb2x5Z29uLnZlcnRpY2VzLCBjaGFtZmVyLnJhZGl1cywgXG4gICAgICAgICAgICAgICAgY2hhbWZlci5xdWFsaXR5LCBjaGFtZmVyLnF1YWxpdHlNaW4sIGNoYW1mZXIucXVhbGl0eU1heCk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFtZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEJvZHkuY3JlYXRlKENvbW1vbi5leHRlbmQoe30sIHBvbHlnb24sIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBjcmVhdGUgYSBjb21wb3VuZCBib2R5IGJhc2VkIG9uIHNldChzKSBvZiB2ZXJ0aWNlcy5cbiAgICAgKiBcbiAgICAgKiBfTm90ZTpfIFRvIG9wdGlvbmFsbHkgZW5hYmxlIGF1dG9tYXRpYyBjb25jYXZlIHZlcnRpY2VzIGRlY29tcG9zaXRpb24gdGhlIFtwb2x5LWRlY29tcF0oaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL3BvbHktZGVjb21wLmpzKSBcbiAgICAgKiBwYWNrYWdlIG11c3QgYmUgZmlyc3QgaW5zdGFsbGVkIGFuZCBwcm92aWRlZCBzZWUgYENvbW1vbi5zZXREZWNvbXBgLCBvdGhlcndpc2UgdGhlIGNvbnZleCBodWxsIG9mIGVhY2ggdmVydGV4IHNldCB3aWxsIGJlIHVzZWQuXG4gICAgICogXG4gICAgICogVGhlIHJlc3VsdGluZyB2ZXJ0aWNlcyBhcmUgcmVvcmllbnRhdGVkIGFib3V0IHRoZWlyIGNlbnRyZSBvZiBtYXNzLFxuICAgICAqIGFuZCBvZmZzZXQgc3VjaCB0aGF0IGBib2R5LnBvc2l0aW9uYCBjb3JyZXNwb25kcyB0byB0aGlzIHBvaW50LlxuICAgICAqIFxuICAgICAqIFRoZSByZXN1bHRpbmcgb2Zmc2V0IG1heSBiZSBmb3VuZCBpZiBuZWVkZWQgYnkgc3VidHJhY3RpbmcgYGJvZHkuYm91bmRzYCBmcm9tIHRoZSBvcmlnaW5hbCBpbnB1dCBib3VuZHMuXG4gICAgICogVG8gbGF0ZXIgbW92ZSB0aGUgY2VudHJlIG9mIG1hc3Mgc2VlIGBCb2R5LnNldENlbnRyZWAuXG4gICAgICogXG4gICAgICogTm90ZSB0aGF0IGF1dG9tYXRpYyBjb25jb25jYXZlIGRlY29tcG9zaXRpb24gcmVzdWx0cyBhcmUgbm90IGFsd2F5cyBvcHRpbWFsLiBcbiAgICAgKiBGb3IgYmVzdCByZXN1bHRzLCBzaW1wbGlmeSB0aGUgaW5wdXQgdmVydGljZXMgYXMgbXVjaCBhcyBwb3NzaWJsZSBmaXJzdC5cbiAgICAgKiBCeSBkZWZhdWx0IHRoaXMgZnVuY3Rpb24gYXBwbGllcyBzb21lIGFkZHRpb25hbCBzaW1wbGlmaWNhdGlvbiB0byBoZWxwLlxuICAgICAqIFxuICAgICAqIFNvbWUgb3V0cHV0cyBtYXkgYWxzbyByZXF1aXJlIGZ1cnRoZXIgbWFudWFsIHByb2Nlc3NpbmcgYWZ0ZXJ3YXJkcyB0byBiZSByb2J1c3QuXG4gICAgICogSW4gcGFydGljdWxhciBzb21lIHBhcnRzIG1heSBuZWVkIHRvIGJlIG92ZXJsYXBwZWQgdG8gYXZvaWQgY29sbGlzaW9uIGdhcHMuXG4gICAgICogVGhpbiBwYXJ0cyBhbmQgc2hhcnAgcG9pbnRzIHNob3VsZCBiZSBhdm9pZGVkIG9yIHJlbW92ZWQgd2hlcmUgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2JqZWN0IHNwZWNpZmllcyBhbnkgYE1hdHRlci5Cb2R5YCBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBcbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBvZiB0aGUgYE1hdHRlci5Cb2R5YCBtb2R1bGUgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGZyb21WZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge2FycmF5fSB2ZXJ0ZXhTZXRzIE9uZSBvciBtb3JlIGFycmF5cyBvZiB2ZXJ0ZXggcG9pbnRzIGUuZy4gYFtbeyB4OiAwLCB5OiAwIH0uLi5dLCAuLi5dYC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBib2R5IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtib29sfSBbZmxhZ0ludGVybmFsPWZhbHNlXSBPcHRpb25hbGx5IG1hcmtzIGludGVybmFsIGVkZ2VzIHdpdGggYGlzSW50ZXJuYWxgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVtb3ZlQ29sbGluZWFyPTAuMDFdIFRocmVzaG9sZCB3aGVuIHNpbXBsaWZ5aW5nIHZlcnRpY2VzIGFsb25nIHRoZSBzYW1lIGVkZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW5pbXVtQXJlYT0xMF0gVGhyZXNob2xkIHdoZW4gcmVtb3Zpbmcgc21hbGwgcGFydHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZW1vdmVEdXBsaWNhdGVQb2ludHM9MC4wMV0gVGhyZXNob2xkIHdoZW4gc2ltcGxpZnlpbmcgbmVhcmJ5IHZlcnRpY2VzLlxuICAgICAqIEByZXR1cm4ge2JvZHl9XG4gICAgICovXG4gICAgQm9kaWVzLmZyb21WZXJ0aWNlcyA9IGZ1bmN0aW9uKHgsIHksIHZlcnRleFNldHMsIG9wdGlvbnMsIGZsYWdJbnRlcm5hbCwgcmVtb3ZlQ29sbGluZWFyLCBtaW5pbXVtQXJlYSwgcmVtb3ZlRHVwbGljYXRlUG9pbnRzKSB7XG4gICAgICAgIHZhciBkZWNvbXAgPSBDb21tb24uZ2V0RGVjb21wKCksXG4gICAgICAgICAgICBjYW5EZWNvbXAsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICBpc0NvbnZleCxcbiAgICAgICAgICAgIGlzQ29uY2F2ZSxcbiAgICAgICAgICAgIHZlcnRpY2VzLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIHo7XG5cbiAgICAgICAgLy8gY2hlY2sgZGVjb21wIGlzIGFzIGV4cGVjdGVkXG4gICAgICAgIGNhbkRlY29tcCA9IEJvb2xlYW4oZGVjb21wICYmIGRlY29tcC5xdWlja0RlY29tcCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHBhcnRzID0gW107XG5cbiAgICAgICAgZmxhZ0ludGVybmFsID0gdHlwZW9mIGZsYWdJbnRlcm5hbCAhPT0gJ3VuZGVmaW5lZCcgPyBmbGFnSW50ZXJuYWwgOiBmYWxzZTtcbiAgICAgICAgcmVtb3ZlQ29sbGluZWFyID0gdHlwZW9mIHJlbW92ZUNvbGxpbmVhciAhPT0gJ3VuZGVmaW5lZCcgPyByZW1vdmVDb2xsaW5lYXIgOiAwLjAxO1xuICAgICAgICBtaW5pbXVtQXJlYSA9IHR5cGVvZiBtaW5pbXVtQXJlYSAhPT0gJ3VuZGVmaW5lZCcgPyBtaW5pbXVtQXJlYSA6IDEwO1xuICAgICAgICByZW1vdmVEdXBsaWNhdGVQb2ludHMgPSB0eXBlb2YgcmVtb3ZlRHVwbGljYXRlUG9pbnRzICE9PSAndW5kZWZpbmVkJyA/IHJlbW92ZUR1cGxpY2F0ZVBvaW50cyA6IDAuMDE7XG5cbiAgICAgICAgLy8gZW5zdXJlIHZlcnRleFNldHMgaXMgYW4gYXJyYXkgb2YgYXJyYXlzXG4gICAgICAgIGlmICghQ29tbW9uLmlzQXJyYXkodmVydGV4U2V0c1swXSkpIHtcbiAgICAgICAgICAgIHZlcnRleFNldHMgPSBbdmVydGV4U2V0c107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgdmVydGV4U2V0cy5sZW5ndGg7IHYgKz0gMSkge1xuICAgICAgICAgICAgdmVydGljZXMgPSB2ZXJ0ZXhTZXRzW3ZdO1xuICAgICAgICAgICAgaXNDb252ZXggPSBWZXJ0aWNlcy5pc0NvbnZleCh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICBpc0NvbmNhdmUgPSAhaXNDb252ZXg7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbmNhdmUgJiYgIWNhbkRlY29tcCkge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuT25jZShcbiAgICAgICAgICAgICAgICAgICAgJ0JvZGllcy5mcm9tVmVydGljZXM6IEluc3RhbGwgdGhlIFxcJ3BvbHktZGVjb21wXFwnIGxpYnJhcnkgYW5kIHVzZSBDb21tb24uc2V0RGVjb21wIG9yIHByb3ZpZGUgXFwnZGVjb21wXFwnIGFzIGEgZ2xvYmFsIHRvIGRlY29tcG9zZSBjb25jYXZlIHZlcnRpY2VzLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNDb252ZXggfHwgIWNhbkRlY29tcCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbnZleCkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IFZlcnRpY2VzLmNsb2Nrd2lzZVNvcnQodmVydGljZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGNvbnZleCBodWxsIHdoZW4gZGVjb21wb3NpdGlvbiBpcyBub3QgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBWZXJ0aWNlcy5odWxsKHZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgeDogeCwgeTogeSB9LFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlczogdmVydGljZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSBhIGRlY29tcG9zaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgY29uY2F2ZSA9IHZlcnRpY2VzLm1hcChmdW5jdGlvbih2ZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt2ZXJ0ZXgueCwgdmVydGV4LnldO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gdmVydGljZXMgYXJlIGNvbmNhdmUgYW5kIHNpbXBsZSwgd2UgY2FuIGRlY29tcG9zZSBpbnRvIHBhcnRzXG4gICAgICAgICAgICAgICAgZGVjb21wLm1ha2VDQ1coY29uY2F2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZUNvbGxpbmVhciAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGRlY29tcC5yZW1vdmVDb2xsaW5lYXJQb2ludHMoY29uY2F2ZSwgcmVtb3ZlQ29sbGluZWFyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlRHVwbGljYXRlUG9pbnRzICE9PSBmYWxzZSAmJiBkZWNvbXAucmVtb3ZlRHVwbGljYXRlUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICBkZWNvbXAucmVtb3ZlRHVwbGljYXRlUG9pbnRzKGNvbmNhdmUsIHJlbW92ZUR1cGxpY2F0ZVBvaW50cyk7XG5cbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHF1aWNrIGRlY29tcG9zaXRpb24gYWxnb3JpdGhtIChCYXlheml0KVxuICAgICAgICAgICAgICAgIHZhciBkZWNvbXBvc2VkID0gZGVjb21wLnF1aWNrRGVjb21wKGNvbmNhdmUpO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggZGVjb21wb3NlZCBjaHVua1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZWNvbXBvc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IGRlY29tcG9zZWRbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB2ZXJ0aWNlcyBpbnRvIHRoZSBjb3JyZWN0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtWZXJ0aWNlcyA9IGNodW5rLm1hcChmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB2ZXJ0aWNlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB2ZXJ0aWNlc1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBzbWFsbCBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmltdW1BcmVhID4gMCAmJiBWZXJ0aWNlcy5hcmVhKGNodW5rVmVydGljZXMpIDwgbWluaW11bUFyZWEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb21wb3VuZCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFZlcnRpY2VzLmNlbnRyZShjaHVua1ZlcnRpY2VzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzOiBjaHVua1ZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBib2R5IHBhcnRzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFydHNbaV0gPSBCb2R5LmNyZWF0ZShDb21tb24uZXh0ZW5kKHBhcnRzW2ldLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmbGFnIGludGVybmFsIGVkZ2VzIChjb2luY2lkZW50IHBhcnQgZWRnZXMpXG4gICAgICAgIGlmIChmbGFnSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHZhciBjb2luY2lkZW50X21heF9kaXN0ID0gNTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRBID0gcGFydHNbaV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QiA9IHBhcnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChCb3VuZHMub3ZlcmxhcHMocGFydEEuYm91bmRzLCBwYXJ0Qi5ib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF2ID0gcGFydEEudmVydGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGJ2ID0gcGFydEIudmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgdmVydGljZXMgb2YgYm90aCBwYXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHBhcnRBLnZlcnRpY2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh6ID0gMDsgeiA8IHBhcnRCLnZlcnRpY2VzLmxlbmd0aDsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgZGlzdGFuY2VzIGJldHdlZW4gdGhlIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYSA9IFZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkKFZlY3Rvci5zdWIocGF2WyhrICsgMSkgJSBwYXYubGVuZ3RoXSwgcGJ2W3pdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYiA9IFZlY3Rvci5tYWduaXR1ZGVTcXVhcmVkKFZlY3Rvci5zdWIocGF2W2tdLCBwYnZbKHogKyAxKSAlIHBidi5sZW5ndGhdKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYm90aCB2ZXJ0aWNlcyBhcmUgdmVyeSBjbG9zZSwgY29uc2lkZXIgdGhlIGVkZ2UgY29uY2lkZW50IChpbnRlcm5hbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhIDwgY29pbmNpZGVudF9tYXhfZGlzdCAmJiBkYiA8IGNvaW5jaWRlbnRfbWF4X2Rpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdltrXS5pc0ludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBidlt6XS5pc0ludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcGFyZW50IGJvZHkgdG8gYmUgcmV0dXJuZWQsIHRoYXQgY29udGFpbnMgZ2VuZXJhdGVkIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgICAgICBib2R5ID0gQm9keS5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IHBhcnRzOiBwYXJ0cy5zbGljZSgwKSB9LCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgIC8vIG9mZnNldCBzdWNoIHRoYXQgYm9keS5wb3NpdGlvbiBpcyBhdCB0aGUgY2VudHJlIG9mZiBtYXNzXG4gICAgICAgICAgICBCb2R5LnNldFBvc2l0aW9uKGJvZHksIHsgeDogeCwgeTogeSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkRldGVjdG9yYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgZWZmaWNpZW50bHkgZGV0ZWN0aW5nIGNvbGxpc2lvbnMgYmV0d2VlbiBhIGxpc3Qgb2YgYm9kaWVzIHVzaW5nIGEgYnJvYWRwaGFzZSBhbGdvcml0aG0uXG4qXG4qIEBjbGFzcyBEZXRlY3RvclxuKi9cblxudmFyIERldGVjdG9yID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gRGV0ZWN0b3I7XG5cbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIENvbGxpc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sbGlzaW9uIGRldGVjdG9yLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtkZXRlY3Rvcn0gQSBuZXcgY29sbGlzaW9uIGRldGVjdG9yXG4gICAgICovXG4gICAgRGV0ZWN0b3IuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBib2RpZXM6IFtdLFxuICAgICAgICAgICAgcGFpcnM6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3Qgb2YgYm9kaWVzIGluIHRoZSBkZXRlY3Rvci5cbiAgICAgKiBAbWV0aG9kIHNldEJvZGllc1xuICAgICAqIEBwYXJhbSB7ZGV0ZWN0b3J9IGRldGVjdG9yXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqL1xuICAgIERldGVjdG9yLnNldEJvZGllcyA9IGZ1bmN0aW9uKGRldGVjdG9yLCBib2RpZXMpIHtcbiAgICAgICAgZGV0ZWN0b3IuYm9kaWVzID0gYm9kaWVzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGRldGVjdG9yIGluY2x1ZGluZyBpdHMgbGlzdCBvZiBib2RpZXMuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7ZGV0ZWN0b3J9IGRldGVjdG9yXG4gICAgICovXG4gICAgRGV0ZWN0b3IuY2xlYXIgPSBmdW5jdGlvbihkZXRlY3Rvcikge1xuICAgICAgICBkZXRlY3Rvci5ib2RpZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRWZmaWNpZW50bHkgZmluZHMgYWxsIGNvbGxpc2lvbnMgYW1vbmcgYWxsIHRoZSBib2RpZXMgaW4gYGRldGVjdG9yLmJvZGllc2AgdXNpbmcgYSBicm9hZHBoYXNlIGFsZ29yaXRobS5cbiAgICAgKiBcbiAgICAgKiBfTm90ZTpfIFRoZSBzcGVjaWZpYyBvcmRlcmluZyBvZiBjb2xsaXNpb25zIHJldHVybmVkIGlzIG5vdCBndWFyYW50ZWVkIGJldHdlZW4gcmVsZWFzZXMgYW5kIG1heSBjaGFuZ2UgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICogSWYgYSBzcGVjaWZpYyBvcmRlcmluZyBpcyByZXF1aXJlZCB0aGVuIGFwcGx5IGEgc29ydCB0byB0aGUgcmVzdWx0aW5nIGFycmF5LlxuICAgICAqIEBtZXRob2QgY29sbGlzaW9uc1xuICAgICAqIEBwYXJhbSB7ZGV0ZWN0b3J9IGRldGVjdG9yXG4gICAgICogQHJldHVybiB7Y29sbGlzaW9uW119IGNvbGxpc2lvbnNcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5jb2xsaXNpb25zID0gZnVuY3Rpb24oZGV0ZWN0b3IpIHtcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBbXSxcbiAgICAgICAgICAgIHBhaXJzID0gZGV0ZWN0b3IucGFpcnMsXG4gICAgICAgICAgICBib2RpZXMgPSBkZXRlY3Rvci5ib2RpZXMsXG4gICAgICAgICAgICBib2RpZXNMZW5ndGggPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICAgICAgY2FuQ29sbGlkZSA9IERldGVjdG9yLmNhbkNvbGxpZGUsXG4gICAgICAgICAgICBjb2xsaWRlcyA9IENvbGxpc2lvbi5jb2xsaWRlcyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGJvZGllcy5zb3J0KERldGVjdG9yLl9jb21wYXJlQm91bmRzWCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgYm91bmRzQSA9IGJvZHlBLmJvdW5kcyxcbiAgICAgICAgICAgICAgICBib3VuZFhNYXggPSBib2R5QS5ib3VuZHMubWF4LngsXG4gICAgICAgICAgICAgICAgYm91bmRZTWF4ID0gYm9keUEuYm91bmRzLm1heC55LFxuICAgICAgICAgICAgICAgIGJvdW5kWU1pbiA9IGJvZHlBLmJvdW5kcy5taW4ueSxcbiAgICAgICAgICAgICAgICBib2R5QVN0YXRpYyA9IGJvZHlBLmlzU3RhdGljIHx8IGJvZHlBLmlzU2xlZXBpbmcsXG4gICAgICAgICAgICAgICAgcGFydHNBTGVuZ3RoID0gYm9keUEucGFydHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBhcnRzQVNpbmdsZSA9IHBhcnRzQUxlbmd0aCA9PT0gMTtcblxuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBib2RpZXNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5QiA9IGJvZGllc1tqXSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzQiA9IGJvZHlCLmJvdW5kcztcblxuICAgICAgICAgICAgICAgIGlmIChib3VuZHNCLm1pbi54ID4gYm91bmRYTWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChib3VuZFlNYXggPCBib3VuZHNCLm1pbi55IHx8IGJvdW5kWU1pbiA+IGJvdW5kc0IubWF4LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBU3RhdGljICYmIChib2R5Qi5pc1N0YXRpYyB8fCBib2R5Qi5pc1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNhbkNvbGxpZGUoYm9keUEuY29sbGlzaW9uRmlsdGVyLCBib2R5Qi5jb2xsaXNpb25GaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXJ0c0JMZW5ndGggPSBib2R5Qi5wYXJ0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFydHNBU2luZ2xlICYmIHBhcnRzQkxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gY29sbGlkZXMoYm9keUEsIGJvZHlCLCBwYWlycyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxpc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9ucy5wdXNoKGNvbGxpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHNBU3RhcnQgPSBwYXJ0c0FMZW5ndGggPiAxID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c0JTdGFydCA9IHBhcnRzQkxlbmd0aCA+IDEgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBwYXJ0c0FTdGFydDsgayA8IHBhcnRzQUxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydEEgPSBib2R5QS5wYXJ0c1trXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHNBID0gcGFydEEuYm91bmRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gcGFydHNCU3RhcnQ7IHogPCBwYXJ0c0JMZW5ndGg7IHorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0QiA9IGJvZHlCLnBhcnRzW3pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHNCID0gcGFydEIuYm91bmRzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kc0EubWluLnggPiBib3VuZHNCLm1heC54IHx8IGJvdW5kc0EubWF4LnggPCBib3VuZHNCLm1pbi54XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGJvdW5kc0EubWF4LnkgPCBib3VuZHNCLm1pbi55IHx8IGJvdW5kc0EubWluLnkgPiBib3VuZHNCLm1heC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsaXNpb24gPSBjb2xsaWRlcyhwYXJ0QSwgcGFydEIsIHBhaXJzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9ucy5wdXNoKGNvbGxpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbGxpc2lvbnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGJvdGggc3VwcGxpZWQgY29sbGlzaW9uIGZpbHRlcnMgd2lsbCBhbGxvdyBhIGNvbGxpc2lvbiB0byBvY2N1ci5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAbWV0aG9kIGNhbkNvbGxpZGVcbiAgICAgKiBAcGFyYW0ge30gZmlsdGVyQVxuICAgICAqIEBwYXJhbSB7fSBmaWx0ZXJCXG4gICAgICogQHJldHVybiB7Ym9vbH0gYHRydWVgIGlmIGNvbGxpc2lvbiBjYW4gb2NjdXJcbiAgICAgKi9cbiAgICBEZXRlY3Rvci5jYW5Db2xsaWRlID0gZnVuY3Rpb24oZmlsdGVyQSwgZmlsdGVyQikge1xuICAgICAgICBpZiAoZmlsdGVyQS5ncm91cCA9PT0gZmlsdGVyQi5ncm91cCAmJiBmaWx0ZXJBLmdyb3VwICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckEuZ3JvdXAgPiAwO1xuXG4gICAgICAgIHJldHVybiAoZmlsdGVyQS5tYXNrICYgZmlsdGVyQi5jYXRlZ29yeSkgIT09IDAgJiYgKGZpbHRlckIubWFzayAmIGZpbHRlckEuY2F0ZWdvcnkpICE9PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiB1c2VkIGluIHRoZSBicm9hZHBoYXNlIGFsZ29yaXRobS5cbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduZWQgZGVsdGEgb2YgdGhlIGJvZGllcyBib3VuZHMgb24gdGhlIHgtYXhpcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgX3NvcnRDb21wYXJlXG4gICAgICogQHBhcmFtIHtib2R5fSBib2R5QVxuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzaWduZWQgZGVsdGEgdXNlZCBmb3Igc29ydGluZ1xuICAgICAqL1xuICAgIERldGVjdG9yLl9jb21wYXJlQm91bmRzWCA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qikge1xuICAgICAgICByZXR1cm4gYm9keUEuYm91bmRzLm1pbi54IC0gYm9keUIuYm91bmRzLm1pbi54O1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiBgTWF0dGVyLkJvZHlgIGJldHdlZW4gd2hpY2ggdGhlIGRldGVjdG9yIGZpbmRzIGNvbGxpc2lvbnMuXG4gICAgICogXG4gICAgICogX05vdGU6XyBUaGUgb3JkZXIgb2YgYm9kaWVzIGluIHRoaXMgYXJyYXkgX2lzIG5vdCBmaXhlZF8gYW5kIHdpbGwgYmUgY29udGludWFsbHkgbWFuYWdlZCBieSB0aGUgZGV0ZWN0b3IuXG4gICAgICogQHByb3BlcnR5IGJvZGllc1xuICAgICAqIEB0eXBlIGJvZHlbXVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbC4gQSBgTWF0dGVyLlBhaXJzYCBvYmplY3QgZnJvbSB3aGljaCBwcmV2aW91cyBjb2xsaXNpb24gb2JqZWN0cyBtYXkgYmUgcmV1c2VkLiBJbnRlbmRlZCBmb3IgaW50ZXJuYWwgYE1hdHRlci5FbmdpbmVgIHVzYWdlLlxuICAgICAqIEBwcm9wZXJ0eSBwYWlyc1xuICAgICAqIEB0eXBlIHtwYWlyc3xudWxsfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5Nb3VzZWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgbW91c2UgaW5wdXRzLlxuKlxuKiBAY2xhc3MgTW91c2VcbiovXG5cbnZhciBNb3VzZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlO1xuXG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1vdXNlIGlucHV0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge21vdXNlfSBBIG5ldyBtb3VzZVxuICAgICAqL1xuICAgIE1vdXNlLmNyZWF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG1vdXNlID0ge307XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBDb21tb24ubG9nKCdNb3VzZS5jcmVhdGU6IGVsZW1lbnQgd2FzIHVuZGVmaW5lZCwgZGVmYXVsdGluZyB0byBkb2N1bWVudC5ib2R5JywgJ3dhcm4nKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbW91c2UuZWxlbWVudCA9IGVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgbW91c2UuYWJzb2x1dGUgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgbW91c2UucG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgbW91c2UubW91c2Vkb3duUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgbW91c2UubW91c2V1cFBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIG1vdXNlLm9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBtb3VzZS5zY2FsZSA9IHsgeDogMSwgeTogMSB9O1xuICAgICAgICBtb3VzZS53aGVlbERlbHRhID0gMDtcbiAgICAgICAgbW91c2UuYnV0dG9uID0gLTE7XG4gICAgICAgIG1vdXNlLnBpeGVsUmF0aW8gPSBwYXJzZUludChtb3VzZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1waXhlbC1yYXRpbycpLCAxMCkgfHwgMTtcblxuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMgPSB7XG4gICAgICAgICAgICBtb3VzZW1vdmU6IG51bGwsXG4gICAgICAgICAgICBtb3VzZWRvd246IG51bGwsXG4gICAgICAgICAgICBtb3VzZXVwOiBudWxsLFxuICAgICAgICAgICAgbW91c2V3aGVlbDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbW91c2UubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHsgXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBNb3VzZS5fZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gMDtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZW1vdmUgPSBldmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIG1vdXNlLm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBNb3VzZS5fZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uKGV2ZW50LCBtb3VzZS5lbGVtZW50LCBtb3VzZS5waXhlbFJhdGlvKSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UuYnV0dG9uID0gMDtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VzZS5idXR0b24gPSBldmVudC5idXR0b247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdXNlLmFic29sdXRlLnggPSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueSA9IHBvc2l0aW9uLnk7XG4gICAgICAgICAgICBtb3VzZS5wb3NpdGlvbi54ID0gbW91c2UuYWJzb2x1dGUueCAqIG1vdXNlLnNjYWxlLnggKyBtb3VzZS5vZmZzZXQueDtcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xuICAgICAgICAgICAgbW91c2UubW91c2Vkb3duUG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZWRvd25Qb3NpdGlvbi55ID0gbW91c2UucG9zaXRpb24ueTtcbiAgICAgICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZWRvd24gPSBldmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIG1vdXNlLm1vdXNldXAgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gTW91c2UuX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbihldmVudCwgbW91c2UuZWxlbWVudCwgbW91c2UucGl4ZWxSYXRpbyksXG4gICAgICAgICAgICAgICAgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuXG4gICAgICAgICAgICBpZiAodG91Y2hlcykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vdXNlLmJ1dHRvbiA9IC0xO1xuICAgICAgICAgICAgbW91c2UuYWJzb2x1dGUueCA9IHBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5hYnNvbHV0ZS55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xuICAgICAgICAgICAgbW91c2UucG9zaXRpb24ueSA9IG1vdXNlLmFic29sdXRlLnkgKiBtb3VzZS5zY2FsZS55ICsgbW91c2Uub2Zmc2V0Lnk7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24ueCA9IG1vdXNlLnBvc2l0aW9uLng7XG4gICAgICAgICAgICBtb3VzZS5tb3VzZXVwUG9zaXRpb24ueSA9IG1vdXNlLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V1cCA9IGV2ZW50O1xuICAgICAgICB9O1xuXG4gICAgICAgIG1vdXNlLm1vdXNld2hlZWwgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgbW91c2Uud2hlZWxEZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBldmVudC53aGVlbERlbHRhIHx8IC1ldmVudC5kZXRhaWwpKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgTW91c2Uuc2V0RWxlbWVudChtb3VzZSwgbW91c2UuZWxlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIG1vdXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBlbGVtZW50IHRoZSBtb3VzZSBpcyBib3VuZCB0byAoYW5kIHJlbGF0aXZlIHRvKS5cbiAgICAgKiBAbWV0aG9kIHNldEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBNb3VzZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24obW91c2UsIGVsZW1lbnQpIHtcbiAgICAgICAgbW91c2UuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZS5tb3VzZW1vdmUpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlLm1vdXNlZG93bik7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlLm1vdXNldXApO1xuICAgICAgICBcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2UubW91c2V3aGVlbCk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBtb3VzZS5tb3VzZXdoZWVsKTtcblxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdXNlLm1vdXNlbW92ZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG1vdXNlLm1vdXNlZG93bik7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBtb3VzZS5tb3VzZXVwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjYXB0dXJlZCBzb3VyY2UgZXZlbnRzLlxuICAgICAqIEBtZXRob2QgY2xlYXJTb3VyY2VFdmVudHNcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqL1xuICAgIE1vdXNlLmNsZWFyU291cmNlRXZlbnRzID0gZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgbW91c2Uuc291cmNlRXZlbnRzLm1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZWRvd24gPSBudWxsO1xuICAgICAgICBtb3VzZS5zb3VyY2VFdmVudHMubW91c2V1cCA9IG51bGw7XG4gICAgICAgIG1vdXNlLnNvdXJjZUV2ZW50cy5tb3VzZXdoZWVsID0gbnVsbDtcbiAgICAgICAgbW91c2Uud2hlZWxEZWx0YSA9IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vdXNlIHBvc2l0aW9uIG9mZnNldC5cbiAgICAgKiBAbWV0aG9kIHNldE9mZnNldFxuICAgICAqIEBwYXJhbSB7bW91c2V9IG1vdXNlXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IG9mZnNldFxuICAgICAqL1xuICAgIE1vdXNlLnNldE9mZnNldCA9IGZ1bmN0aW9uKG1vdXNlLCBvZmZzZXQpIHtcbiAgICAgICAgbW91c2Uub2Zmc2V0LnggPSBvZmZzZXQueDtcbiAgICAgICAgbW91c2Uub2Zmc2V0LnkgPSBvZmZzZXQueTtcbiAgICAgICAgbW91c2UucG9zaXRpb24ueCA9IG1vdXNlLmFic29sdXRlLnggKiBtb3VzZS5zY2FsZS54ICsgbW91c2Uub2Zmc2V0Lng7XG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnkgPSBtb3VzZS5hYnNvbHV0ZS55ICogbW91c2Uuc2NhbGUueSArIG1vdXNlLm9mZnNldC55O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiBzY2FsZS5cbiAgICAgKiBAbWV0aG9kIHNldFNjYWxlXG4gICAgICogQHBhcmFtIHttb3VzZX0gbW91c2VcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gc2NhbGVcbiAgICAgKi9cbiAgICBNb3VzZS5zZXRTY2FsZSA9IGZ1bmN0aW9uKG1vdXNlLCBzY2FsZSkge1xuICAgICAgICBtb3VzZS5zY2FsZS54ID0gc2NhbGUueDtcbiAgICAgICAgbW91c2Uuc2NhbGUueSA9IHNjYWxlLnk7XG4gICAgICAgIG1vdXNlLnBvc2l0aW9uLnggPSBtb3VzZS5hYnNvbHV0ZS54ICogbW91c2Uuc2NhbGUueCArIG1vdXNlLm9mZnNldC54O1xuICAgICAgICBtb3VzZS5wb3NpdGlvbi55ID0gbW91c2UuYWJzb2x1dGUueSAqIG1vdXNlLnNjYWxlLnkgKyBtb3VzZS5vZmZzZXQueTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGFuIGVsZW1lbnQgZ2l2ZW4gYSBzY3JlZW4gcGl4ZWwgcmF0aW8uXG4gICAgICogQG1ldGhvZCBfZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvXG4gICAgICogQHJldHVybiB7fVxuICAgICAqL1xuICAgIE1vdXNlLl9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihldmVudCwgZWxlbWVudCwgcGl4ZWxSYXRpbykge1xuICAgICAgICB2YXIgZWxlbWVudEJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICByb290Tm9kZSA9IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHkpLFxuICAgICAgICAgICAgc2Nyb2xsWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiByb290Tm9kZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgc2Nyb2xsWSA9ICh3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZCkgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiByb290Tm9kZS5zY3JvbGxUb3AsXG4gICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgICAgICB4LCB5O1xuICAgICAgICBcbiAgICAgICAgaWYgKHRvdWNoZXMpIHtcbiAgICAgICAgICAgIHggPSB0b3VjaGVzWzBdLnBhZ2VYIC0gZWxlbWVudEJvdW5kcy5sZWZ0IC0gc2Nyb2xsWDtcbiAgICAgICAgICAgIHkgPSB0b3VjaGVzWzBdLnBhZ2VZIC0gZWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IGV2ZW50LnBhZ2VYIC0gZWxlbWVudEJvdW5kcy5sZWZ0IC0gc2Nyb2xsWDtcbiAgICAgICAgICAgIHkgPSBldmVudC5wYWdlWSAtIGVsZW1lbnRCb3VuZHMudG9wIC0gc2Nyb2xsWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgeDogeCAvIChlbGVtZW50LmNsaWVudFdpZHRoIC8gKGVsZW1lbnQud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCkgKiBwaXhlbFJhdGlvKSxcbiAgICAgICAgICAgIHk6IHkgLyAoZWxlbWVudC5jbGllbnRIZWlnaHQgLyAoZWxlbWVudC5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQpICogcGl4ZWxSYXRpbylcbiAgICAgICAgfTtcbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLlBsdWdpbmAgbW9kdWxlIGNvbnRhaW5zIGZ1bmN0aW9ucyBmb3IgcmVnaXN0ZXJpbmcgYW5kIGluc3RhbGxpbmcgcGx1Z2lucyBvbiBtb2R1bGVzLlxuKlxuKiBAY2xhc3MgUGx1Z2luXG4qL1xuXG52YXIgUGx1Z2luID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUGx1Z2luO1xuXG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgUGx1Z2luLl9yZWdpc3RyeSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgcGx1Z2luIG9iamVjdCBzbyBpdCBjYW4gYmUgcmVzb2x2ZWQgbGF0ZXIgYnkgbmFtZS5cbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXG4gICAgICogQHBhcmFtIHBsdWdpbiB7fSBUaGUgcGx1Z2luIHRvIHJlZ2lzdGVyLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHBsdWdpbi5cbiAgICAgKi9cbiAgICBQbHVnaW4ucmVnaXN0ZXIgPSBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICAgICAgaWYgKCFQbHVnaW4uaXNQbHVnaW4ocGx1Z2luKSkge1xuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSwgJ2RvZXMgbm90IGltcGxlbWVudCBhbGwgcmVxdWlyZWQgZmllbGRzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBsdWdpbi5uYW1lIGluIFBsdWdpbi5fcmVnaXN0cnkpIHtcbiAgICAgICAgICAgIHZhciByZWdpc3RlcmVkID0gUGx1Z2luLl9yZWdpc3RyeVtwbHVnaW4ubmFtZV0sXG4gICAgICAgICAgICAgICAgcGx1Z2luVmVyc2lvbiA9IFBsdWdpbi52ZXJzaW9uUGFyc2UocGx1Z2luLnZlcnNpb24pLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkVmVyc2lvbiA9IFBsdWdpbi52ZXJzaW9uUGFyc2UocmVnaXN0ZXJlZC52ZXJzaW9uKS5udW1iZXI7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW5WZXJzaW9uID4gcmVnaXN0ZXJlZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLnJlZ2lzdGVyOicsIFBsdWdpbi50b1N0cmluZyhyZWdpc3RlcmVkKSwgJ3dhcyB1cGdyYWRlZCB0bycsIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pKTtcbiAgICAgICAgICAgICAgICBQbHVnaW4uX3JlZ2lzdHJ5W3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luVmVyc2lvbiA8IHJlZ2lzdGVyZWRWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi5yZWdpc3RlcjonLCBQbHVnaW4udG9TdHJpbmcocmVnaXN0ZXJlZCksICdjYW4gbm90IGJlIGRvd25ncmFkZWQgdG8nLCBQbHVnaW4udG9TdHJpbmcocGx1Z2luKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbiAhPT0gcmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4ucmVnaXN0ZXI6JywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbiksICdpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgdG8gZGlmZmVyZW50IHBsdWdpbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFBsdWdpbi5fcmVnaXN0cnlbcGx1Z2luLm5hbWVdID0gcGx1Z2luO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsdWdpbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSBkZXBlbmRlbmN5IHRvIGEgcGx1Z2luIG9iamVjdCBmcm9tIHRoZSByZWdpc3RyeSBpZiBpdCBleGlzdHMuIFxuICAgICAqIFRoZSBgZGVwZW5kZW5jeWAgbWF5IGNvbnRhaW4gYSB2ZXJzaW9uLCBidXQgb25seSB0aGUgbmFtZSBtYXR0ZXJzIHdoZW4gcmVzb2x2aW5nLlxuICAgICAqIEBtZXRob2QgcmVzb2x2ZVxuICAgICAqIEBwYXJhbSBkZXBlbmRlbmN5IHtzdHJpbmd9IFRoZSBkZXBlbmRlbmN5LlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHBsdWdpbiBpZiByZXNvbHZlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIFBsdWdpbi5yZXNvbHZlID0gZnVuY3Rpb24oZGVwZW5kZW5jeSkge1xuICAgICAgICByZXR1cm4gUGx1Z2luLl9yZWdpc3RyeVtQbHVnaW4uZGVwZW5kZW5jeVBhcnNlKGRlcGVuZGVuY3kpLm5hbWVdO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJldHR5IHByaW50ZWQgcGx1Z2luIG5hbWUgYW5kIHZlcnNpb24uXG4gICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAqIEBwYXJhbSBwbHVnaW4ge30gVGhlIHBsdWdpbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFByZXR0eSBwcmludGVkIHBsdWdpbiBuYW1lIGFuZCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIFBsdWdpbi50b1N0cmluZyA9IGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBsdWdpbiA9PT0gJ3N0cmluZycgPyBwbHVnaW4gOiAocGx1Z2luLm5hbWUgfHwgJ2Fub255bW91cycpICsgJ0AnICsgKHBsdWdpbi52ZXJzaW9uIHx8IHBsdWdpbi5yYW5nZSB8fCAnMC4wLjAnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBtZWV0cyB0aGUgbWluaW11bSBzdGFuZGFyZCB0byBiZSBjb25zaWRlcmVkIGEgcGx1Z2luLlxuICAgICAqIFRoaXMgbWVhbnMgaXQgbXVzdCBkZWZpbmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIC0gYG5hbWVgXG4gICAgICogLSBgdmVyc2lvbmBcbiAgICAgKiAtIGBpbnN0YWxsYFxuICAgICAqIEBtZXRob2QgaXNQbHVnaW5cbiAgICAgKiBAcGFyYW0gb2JqIHt9IFRoZSBvYmogdG8gdGVzdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBjYW4gYmUgY29uc2lkZXJlZCBhIHBsdWdpbiBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBQbHVnaW4uaXNQbHVnaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmoubmFtZSAmJiBvYmoudmVyc2lvbiAmJiBvYmouaW5zdGFsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYSBwbHVnaW4gd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgIGJlZW4gaW5zdGFsbGVkIG9uIGBtb2R1bGVgLlxuICAgICAqIEBtZXRob2QgaXNVc2VkXG4gICAgICogQHBhcmFtIG1vZHVsZSB7fSBUaGUgbW9kdWxlLlxuICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IFRoZSBwbHVnaW4gbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYSBwbHVnaW4gd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgIGJlZW4gaW5zdGFsbGVkIG9uIGBtb2R1bGVgLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBQbHVnaW4uaXNVc2VkID0gZnVuY3Rpb24obW9kdWxlLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUudXNlZC5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGBwbHVnaW4uZm9yYCBpcyBhcHBsaWNhYmxlIHRvIGBtb2R1bGVgIGJ5IGNvbXBhcmluZyBhZ2FpbnN0IGBtb2R1bGUubmFtZWAgYW5kIGBtb2R1bGUudmVyc2lvbmAuXG4gICAgICogSWYgYHBsdWdpbi5mb3JgIGlzIG5vdCBzcGVjaWZpZWQgdGhlbiBpdCBpcyBhc3N1bWVkIHRvIGJlIGFwcGxpY2FibGUuXG4gICAgICogVGhlIHZhbHVlIG9mIGBwbHVnaW4uZm9yYCBpcyBhIHN0cmluZyBvZiB0aGUgZm9ybWF0IGAnbW9kdWxlLW5hbWUnYCBvciBgJ21vZHVsZS1uYW1lQHZlcnNpb24nYC5cbiAgICAgKiBAbWV0aG9kIGlzRm9yXG4gICAgICogQHBhcmFtIHBsdWdpbiB7fSBUaGUgcGx1Z2luLlxuICAgICAqIEBwYXJhbSBtb2R1bGUge30gVGhlIG1vZHVsZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYHBsdWdpbi5mb3JgIGlzIGFwcGxpY2FibGUgdG8gYG1vZHVsZWAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIFBsdWdpbi5pc0ZvciA9IGZ1bmN0aW9uKHBsdWdpbiwgbW9kdWxlKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwbHVnaW4uZm9yICYmIFBsdWdpbi5kZXBlbmRlbmN5UGFyc2UocGx1Z2luLmZvcik7XG4gICAgICAgIHJldHVybiAhcGx1Z2luLmZvciB8fCAobW9kdWxlLm5hbWUgPT09IHBhcnNlZC5uYW1lICYmIFBsdWdpbi52ZXJzaW9uU2F0aXNmaWVzKG1vZHVsZS52ZXJzaW9uLCBwYXJzZWQucmFuZ2UpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zdGFsbHMgdGhlIHBsdWdpbnMgYnkgY2FsbGluZyBgcGx1Z2luLmluc3RhbGxgIG9uIGVhY2ggcGx1Z2luIHNwZWNpZmllZCBpbiBgcGx1Z2luc2AgaWYgcGFzc2VkLCBvdGhlcndpc2UgYG1vZHVsZS51c2VzYC5cbiAgICAgKiBGb3IgaW5zdGFsbGluZyBwbHVnaW5zIG9uIGBNYXR0ZXJgIHNlZSB0aGUgY29udmVuaWVuY2UgZnVuY3Rpb24gYE1hdHRlci51c2VgLlxuICAgICAqIFBsdWdpbnMgbWF5IGJlIHNwZWNpZmllZCBlaXRoZXIgYnkgdGhlaXIgbmFtZSBvciBhIHJlZmVyZW5jZSB0byB0aGUgcGx1Z2luIG9iamVjdC5cbiAgICAgKiBQbHVnaW5zIHRoZW1zZWx2ZXMgbWF5IHNwZWNpZnkgZnVydGhlciBkZXBlbmRlbmNpZXMsIGJ1dCBlYWNoIHBsdWdpbiBpcyBpbnN0YWxsZWQgb25seSBvbmNlLlxuICAgICAqIE9yZGVyIGlzIGltcG9ydGFudCwgYSB0b3BvbG9naWNhbCBzb3J0IGlzIHBlcmZvcm1lZCB0byBmaW5kIHRoZSBiZXN0IHJlc3VsdGluZyBvcmRlciBvZiBpbnN0YWxsYXRpb24uXG4gICAgICogVGhpcyBzb3J0aW5nIGF0dGVtcHRzIHRvIHNhdGlzZnkgZXZlcnkgZGVwZW5kZW5jeSdzIHJlcXVlc3RlZCBvcmRlcmluZywgYnV0IG1heSBub3QgYmUgZXhhY3QgaW4gYWxsIGNhc2VzLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbG9ncyB0aGUgcmVzdWx0aW5nIHN0YXR1cyBvZiBlYWNoIGRlcGVuZGVuY3kgaW4gdGhlIGNvbnNvbGUsIGFsb25nIHdpdGggYW55IHdhcm5pbmdzLlxuICAgICAqIC0gQSBncmVlbiB0aWNrIOKchSBpbmRpY2F0ZXMgYSBkZXBlbmRlbmN5IHdhcyByZXNvbHZlZCBhbmQgaW5zdGFsbGVkLlxuICAgICAqIC0gQW4gb3JhbmdlIGRpYW1vbmQg8J+UtiBpbmRpY2F0ZXMgYSBkZXBlbmRlbmN5IHdhcyByZXNvbHZlZCBidXQgYSB3YXJuaW5nIHdhcyB0aHJvd24gZm9yIGl0IG9yIG9uZSBpZiBpdHMgZGVwZW5kZW5jaWVzLlxuICAgICAqIC0gQSByZWQgY3Jvc3Mg4p2MIGluZGljYXRlcyBhIGRlcGVuZGVuY3kgY291bGQgbm90IGJlIHJlc29sdmVkLlxuICAgICAqIEF2b2lkIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBtb2R1bGUgdW5sZXNzIHlvdSBpbnRlbmQgdG8gbWFudWFsbHkgY29udHJvbCBpbnN0YWxsYXRpb24gb3JkZXIuXG4gICAgICogQG1ldGhvZCB1c2VcbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUgaW5zdGFsbCBwbHVnaW5zIG9uLlxuICAgICAqIEBwYXJhbSBbcGx1Z2lucz1tb2R1bGUudXNlc10ge30gVGhlIHBsdWdpbnMgdG8gaW5zdGFsbCBvbiBtb2R1bGUgKG9wdGlvbmFsLCBkZWZhdWx0cyB0byBgbW9kdWxlLnVzZXNgKS5cbiAgICAgKi9cbiAgICBQbHVnaW4udXNlID0gZnVuY3Rpb24obW9kdWxlLCBwbHVnaW5zKSB7XG4gICAgICAgIG1vZHVsZS51c2VzID0gKG1vZHVsZS51c2VzIHx8IFtdKS5jb25jYXQocGx1Z2lucyB8fCBbXSk7XG5cbiAgICAgICAgaWYgKG1vZHVsZS51c2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi51c2U6JywgUGx1Z2luLnRvU3RyaW5nKG1vZHVsZSksICdkb2VzIG5vdCBzcGVjaWZ5IGFueSBkZXBlbmRlbmNpZXMgdG8gaW5zdGFsbC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBQbHVnaW4uZGVwZW5kZW5jaWVzKG1vZHVsZSksXG4gICAgICAgICAgICBzb3J0ZWREZXBlbmRlbmNpZXMgPSBDb21tb24udG9wb2xvZ2ljYWxTb3J0KGRlcGVuZGVuY2llcyksXG4gICAgICAgICAgICBzdGF0dXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHNvcnRlZERlcGVuZGVuY2llc1tpXSA9PT0gbW9kdWxlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IFBsdWdpbi5yZXNvbHZlKHNvcnRlZERlcGVuZGVuY2llc1tpXSk7XG5cbiAgICAgICAgICAgIGlmICghcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnB1c2goJ+KdjCAnICsgc29ydGVkRGVwZW5kZW5jaWVzW2ldKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFBsdWdpbi5pc1VzZWQobW9kdWxlLCBwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFQbHVnaW4uaXNGb3IocGx1Z2luLCBtb2R1bGUpKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ1BsdWdpbi51c2U6JywgUGx1Z2luLnRvU3RyaW5nKHBsdWdpbiksICdpcyBmb3InLCBwbHVnaW4uZm9yLCAnYnV0IGluc3RhbGxlZCBvbicsIFBsdWdpbi50b1N0cmluZyhtb2R1bGUpICsgJy4nKTtcbiAgICAgICAgICAgICAgICBwbHVnaW4uX3dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4uaW5zdGFsbCkge1xuICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKG1vZHVsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4udXNlOicsIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pLCAnZG9lcyBub3Qgc3BlY2lmeSBhbiBpbnN0YWxsIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgICAgIHBsdWdpbi5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBsdWdpbi5fd2FybmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnB1c2goJ/CflLYgJyArIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGx1Z2luLl93YXJuZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5wdXNoKCfinIUgJyArIFBsdWdpbi50b1N0cmluZyhwbHVnaW4pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW9kdWxlLnVzZWQucHVzaChwbHVnaW4ubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdHVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIENvbW1vbi5pbmZvKHN0YXR1cy5qb2luKCcgICcpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmaW5kcyBhbGwgb2YgYSBtb2R1bGUncyBkZXBlbmRlbmNpZXMgYW5kIHJldHVybnMgYSBmbGF0IGRlcGVuZGVuY3kgZ3JhcGguXG4gICAgICogQG1ldGhvZCBkZXBlbmRlbmNpZXNcbiAgICAgKiBAcGFyYW0gbW9kdWxlIHt9IFRoZSBtb2R1bGUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIGRlcGVuZGVuY3kgZ3JhcGguXG4gICAgICovXG4gICAgUGx1Z2luLmRlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKG1vZHVsZSwgdHJhY2tlZCkge1xuICAgICAgICB2YXIgcGFyc2VkQmFzZSA9IFBsdWdpbi5kZXBlbmRlbmN5UGFyc2UobW9kdWxlKSxcbiAgICAgICAgICAgIG5hbWUgPSBwYXJzZWRCYXNlLm5hbWU7XG5cbiAgICAgICAgdHJhY2tlZCA9IHRyYWNrZWQgfHwge307XG5cbiAgICAgICAgaWYgKG5hbWUgaW4gdHJhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kdWxlID0gUGx1Z2luLnJlc29sdmUobW9kdWxlKSB8fCBtb2R1bGU7XG5cbiAgICAgICAgdHJhY2tlZFtuYW1lXSA9IENvbW1vbi5tYXAobW9kdWxlLnVzZXMgfHwgW10sIGZ1bmN0aW9uKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgIGlmIChQbHVnaW4uaXNQbHVnaW4oZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgICAgICBQbHVnaW4ucmVnaXN0ZXIoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBQbHVnaW4uZGVwZW5kZW5jeVBhcnNlKGRlcGVuZGVuY3kpLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gUGx1Z2luLnJlc29sdmUoZGVwZW5kZW5jeSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCAmJiAhUGx1Z2luLnZlcnNpb25TYXRpc2ZpZXMocmVzb2x2ZWQudmVyc2lvbiwgcGFyc2VkLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKFxuICAgICAgICAgICAgICAgICAgICAnUGx1Z2luLmRlcGVuZGVuY2llczonLCBQbHVnaW4udG9TdHJpbmcocmVzb2x2ZWQpLCAnZG9lcyBub3Qgc2F0aXNmeScsXG4gICAgICAgICAgICAgICAgICAgIFBsdWdpbi50b1N0cmluZyhwYXJzZWQpLCAndXNlZCBieScsIFBsdWdpbi50b1N0cmluZyhwYXJzZWRCYXNlKSArICcuJ1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlZC5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtb2R1bGUuX3dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIENvbW1vbi53YXJuKFxuICAgICAgICAgICAgICAgICAgICAnUGx1Z2luLmRlcGVuZGVuY2llczonLCBQbHVnaW4udG9TdHJpbmcoZGVwZW5kZW5jeSksICd1c2VkIGJ5JyxcbiAgICAgICAgICAgICAgICAgICAgUGx1Z2luLnRvU3RyaW5nKHBhcnNlZEJhc2UpLCAnY291bGQgbm90IGJlIHJlc29sdmVkLidcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgbW9kdWxlLl93YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkLm5hbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tlZFtuYW1lXS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgUGx1Z2luLmRlcGVuZGVuY2llcyh0cmFja2VkW25hbWVdW2ldLCB0cmFja2VkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFja2VkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBkZXBlbmRlbmN5IHN0cmluZyBpbnRvIGl0cyBjb21wb25lbnRzLlxuICAgICAqIFRoZSBgZGVwZW5kZW5jeWAgaXMgYSBzdHJpbmcgb2YgdGhlIGZvcm1hdCBgJ21vZHVsZS1uYW1lJ2Agb3IgYCdtb2R1bGUtbmFtZUB2ZXJzaW9uJ2AuXG4gICAgICogU2VlIGRvY3VtZW50YXRpb24gZm9yIGBQbHVnaW4udmVyc2lvblBhcnNlYCBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZm9ybWF0LlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGFsc28gaGFuZGxlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBhbHJlYWR5IHJlc29sdmVkIChlLmcuIGEgbW9kdWxlIG9iamVjdCkuXG4gICAgICogQG1ldGhvZCBkZXBlbmRlbmN5UGFyc2VcbiAgICAgKiBAcGFyYW0gZGVwZW5kZW5jeSB7c3RyaW5nfSBUaGUgZGVwZW5kZW5jeSBvZiB0aGUgZm9ybWF0IGAnbW9kdWxlLW5hbWUnYCBvciBgJ21vZHVsZS1uYW1lQHZlcnNpb24nYC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBkZXBlbmRlbmN5IHBhcnNlZCBpbnRvIGl0cyBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIFBsdWdpbi5kZXBlbmRlbmN5UGFyc2UgPSBmdW5jdGlvbihkZXBlbmRlbmN5KSB7XG4gICAgICAgIGlmIChDb21tb24uaXNTdHJpbmcoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gL15bXFx3LV0rKEAoXFwqfFtcXF5+XT9cXGQrXFwuXFxkK1xcLlxcZCsoLVswLTlBLVphLXotK10rKT8pKT8kLztcblxuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuLnRlc3QoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgICAgICBDb21tb24ud2FybignUGx1Z2luLmRlcGVuZGVuY3lQYXJzZTonLCBkZXBlbmRlbmN5LCAnaXMgbm90IGEgdmFsaWQgZGVwZW5kZW5jeSBzdHJpbmcuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZGVwZW5kZW5jeS5zcGxpdCgnQCcpWzBdLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBkZXBlbmRlbmN5LnNwbGl0KCdAJylbMV0gfHwgJyonXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGRlcGVuZGVuY3kubmFtZSxcbiAgICAgICAgICAgIHJhbmdlOiBkZXBlbmRlbmN5LnJhbmdlIHx8IGRlcGVuZGVuY3kudmVyc2lvblxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSB2ZXJzaW9uIHN0cmluZyBpbnRvIGl0cyBjb21wb25lbnRzLiAgXG4gICAgICogVmVyc2lvbnMgYXJlIHN0cmljdGx5IG9mIHRoZSBmb3JtYXQgYHgueS56YCAoYXMgaW4gW3NlbXZlcl0oaHR0cDovL3NlbXZlci5vcmcvKSkuXG4gICAgICogVmVyc2lvbnMgbWF5IG9wdGlvbmFsbHkgaGF2ZSBhIHByZXJlbGVhc2UgdGFnIGluIHRoZSBmb3JtYXQgYHgueS56LWFscGhhYC5cbiAgICAgKiBSYW5nZXMgYXJlIGEgc3RyaWN0IHN1YnNldCBvZiBbbnBtIHJhbmdlc10oaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9taXNjL3NlbXZlciNhZHZhbmNlZC1yYW5nZS1zeW50YXgpLlxuICAgICAqIE9ubHkgdGhlIGZvbGxvd2luZyByYW5nZSB0eXBlcyBhcmUgc3VwcG9ydGVkOlxuICAgICAqIC0gVGlsZGUgcmFuZ2VzIGUuZy4gYH4xLjIuM2BcbiAgICAgKiAtIENhcmV0IHJhbmdlcyBlLmcuIGBeMS4yLjNgXG4gICAgICogLSBHcmVhdGVyIHRoYW4gcmFuZ2VzIGUuZy4gYD4xLjIuM2BcbiAgICAgKiAtIEdyZWF0ZXIgdGhhbiBvciBlcXVhbCByYW5nZXMgZS5nLiBgPj0xLjIuM2BcbiAgICAgKiAtIEV4YWN0IHZlcnNpb24gZS5nLiBgMS4yLjNgXG4gICAgICogLSBBbnkgdmVyc2lvbiBgKmBcbiAgICAgKiBAbWV0aG9kIHZlcnNpb25QYXJzZVxuICAgICAqIEBwYXJhbSByYW5nZSB7c3RyaW5nfSBUaGUgdmVyc2lvbiBzdHJpbmcuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgdmVyc2lvbiByYW5nZSBwYXJzZWQgaW50byBpdHMgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICBQbHVnaW4udmVyc2lvblBhcnNlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSAvXihcXCopfChcXF58fnw+PXw+KT9cXHMqKChcXGQrKVxcLihcXGQrKVxcLihcXGQrKSkoLVswLTlBLVphLXotK10rKT8kLztcblxuICAgICAgICBpZiAoIXBhdHRlcm4udGVzdChyYW5nZSkpIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdQbHVnaW4udmVyc2lvblBhcnNlOicsIHJhbmdlLCAnaXMgbm90IGEgdmFsaWQgdmVyc2lvbiBvciByYW5nZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdHRlcm4uZXhlYyhyYW5nZSk7XG4gICAgICAgIHZhciBtYWpvciA9IE51bWJlcihwYXJ0c1s0XSk7XG4gICAgICAgIHZhciBtaW5vciA9IE51bWJlcihwYXJ0c1s1XSk7XG4gICAgICAgIHZhciBwYXRjaCA9IE51bWJlcihwYXJ0c1s2XSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzUmFuZ2U6IEJvb2xlYW4ocGFydHNbMV0gfHwgcGFydHNbMl0pLFxuICAgICAgICAgICAgdmVyc2lvbjogcGFydHNbM10sXG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBvcGVyYXRvcjogcGFydHNbMV0gfHwgcGFydHNbMl0gfHwgJycsXG4gICAgICAgICAgICBtYWpvcjogbWFqb3IsXG4gICAgICAgICAgICBtaW5vcjogbWlub3IsXG4gICAgICAgICAgICBwYXRjaDogcGF0Y2gsXG4gICAgICAgICAgICBwYXJ0czogW21ham9yLCBtaW5vciwgcGF0Y2hdLFxuICAgICAgICAgICAgcHJlcmVsZWFzZTogcGFydHNbN10sXG4gICAgICAgICAgICBudW1iZXI6IG1ham9yICogMWU4ICsgbWlub3IgKiAxZTQgKyBwYXRjaFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgdmVyc2lvbmAgc2F0aXNmaWVzIHRoZSBnaXZlbiBgcmFuZ2VgLlxuICAgICAqIFNlZSBkb2N1bWVudGF0aW9uIGZvciBgUGx1Z2luLnZlcnNpb25QYXJzZWAgZm9yIGEgZGVzY3JpcHRpb24gb2YgdGhlIGZvcm1hdC5cbiAgICAgKiBJZiBhIHZlcnNpb24gb3IgcmFuZ2UgaXMgbm90IHNwZWNpZmllZCwgdGhlbiBhbnkgdmVyc2lvbiAoYCpgKSBpcyBhc3N1bWVkIHRvIHNhdGlzZnkuXG4gICAgICogQG1ldGhvZCB2ZXJzaW9uU2F0aXNmaWVzXG4gICAgICogQHBhcmFtIHZlcnNpb24ge3N0cmluZ30gVGhlIHZlcnNpb24gc3RyaW5nLlxuICAgICAqIEBwYXJhbSByYW5nZSB7c3RyaW5nfSBUaGUgcmFuZ2Ugc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBgdmVyc2lvbmAgc2F0aXNmaWVzIGByYW5nZWAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIFBsdWdpbi52ZXJzaW9uU2F0aXNmaWVzID0gZnVuY3Rpb24odmVyc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSByYW5nZSB8fCAnKic7XG5cbiAgICAgICAgdmFyIHIgPSBQbHVnaW4udmVyc2lvblBhcnNlKHJhbmdlKSxcbiAgICAgICAgICAgIHYgPSBQbHVnaW4udmVyc2lvblBhcnNlKHZlcnNpb24pO1xuXG4gICAgICAgIGlmIChyLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChyLm9wZXJhdG9yID09PSAnKicgfHwgdmVyc2lvbiA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyLm9wZXJhdG9yID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5udW1iZXIgPiByLm51bWJlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHIub3BlcmF0b3IgPT09ICc+PScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5udW1iZXIgPj0gci5udW1iZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyLm9wZXJhdG9yID09PSAnficpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5tYWpvciA9PT0gci5tYWpvciAmJiB2Lm1pbm9yID09PSByLm1pbm9yICYmIHYucGF0Y2ggPj0gci5wYXRjaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHIub3BlcmF0b3IgPT09ICdeJykge1xuICAgICAgICAgICAgICAgIGlmIChyLm1ham9yID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdi5tYWpvciA9PT0gci5tYWpvciAmJiB2Lm51bWJlciA+PSByLm51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoci5taW5vciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYubWlub3IgPT09IHIubWlub3IgJiYgdi5wYXRjaCA+PSByLnBhdGNoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2LnBhdGNoID09PSByLnBhdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZlcnNpb24gPT09IHJhbmdlIHx8IHZlcnNpb24gPT09ICcqJztcbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkNvbnRhY3RgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGNvbGxpc2lvbiBjb250YWN0cy5cbipcbiogQGNsYXNzIENvbnRhY3RcbiovXG5cbnZhciBDb250YWN0ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdDtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb250YWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt2ZXJ0ZXh9IHZlcnRleFxuICAgICAqIEByZXR1cm4ge2NvbnRhY3R9IEEgbmV3IGNvbnRhY3RcbiAgICAgKi9cbiAgICBDb250YWN0LmNyZWF0ZSA9IGZ1bmN0aW9uKHZlcnRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVydGV4OiB2ZXJ0ZXgsXG4gICAgICAgICAgICBub3JtYWxJbXB1bHNlOiAwLFxuICAgICAgICAgICAgdGFuZ2VudEltcHVsc2U6IDBcbiAgICAgICAgfTtcbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLkVuZ2luZWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgZW5naW5lcy5cbiogQW4gZW5naW5lIGlzIGEgY29udHJvbGxlciB0aGF0IG1hbmFnZXMgdXBkYXRpbmcgdGhlIHNpbXVsYXRpb24gb2YgdGhlIHdvcmxkLlxuKiBTZWUgYE1hdHRlci5SdW5uZXJgIGZvciBhbiBvcHRpb25hbCBnYW1lIGxvb3AgdXRpbGl0eS5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIEVuZ2luZVxuKi9cblxudmFyIEVuZ2luZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVuZ2luZTtcblxudmFyIFNsZWVwaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBSZXNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xudmFyIERldGVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgUGFpcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbnZhciBFdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvbXBvc2l0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgQ29uc3RyYWludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgQm9keSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZW5naW5lLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBBbGwgcHJvcGVydGllcyBoYXZlIGRlZmF1bHQgdmFsdWVzLCBhbmQgbWFueSBhcmUgcHJlLWNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBvdGhlciBwcm9wZXJ0aWVzLlxuICAgICAqIFNlZSB0aGUgcHJvcGVydGllcyBzZWN0aW9uIGJlbG93IGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IHlvdSBjYW4gcGFzcyB2aWEgdGhlIGBvcHRpb25zYCBvYmplY3QuXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybiB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cbiAgICBFbmdpbmUuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbkl0ZXJhdGlvbnM6IDYsXG4gICAgICAgICAgICB2ZWxvY2l0eUl0ZXJhdGlvbnM6IDQsXG4gICAgICAgICAgICBjb25zdHJhaW50SXRlcmF0aW9uczogMixcbiAgICAgICAgICAgIGVuYWJsZVNsZWVwaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICBwbHVnaW46IHt9LFxuICAgICAgICAgICAgZ3Jhdml0eToge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMSxcbiAgICAgICAgICAgICAgICBzY2FsZTogMC4wMDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1pbmc6IHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IDAsXG4gICAgICAgICAgICAgICAgdGltZVNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIGxhc3REZWx0YTogMCxcbiAgICAgICAgICAgICAgICBsYXN0RWxhcHNlZDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBlbmdpbmUgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBlbmdpbmUud29ybGQgPSBvcHRpb25zLndvcmxkIHx8IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ1dvcmxkJyB9KTtcbiAgICAgICAgZW5naW5lLnBhaXJzID0gb3B0aW9ucy5wYWlycyB8fCBQYWlycy5jcmVhdGUoKTtcbiAgICAgICAgZW5naW5lLmRldGVjdG9yID0gb3B0aW9ucy5kZXRlY3RvciB8fCBEZXRlY3Rvci5jcmVhdGUoKTtcblxuICAgICAgICAvLyBmb3IgdGVtcG9yYXJ5IGJhY2sgY29tcGF0aWJpbGl0eSBvbmx5XG4gICAgICAgIGVuZ2luZS5ncmlkID0geyBidWNrZXRzOiBbXSB9O1xuICAgICAgICBlbmdpbmUud29ybGQuZ3Jhdml0eSA9IGVuZ2luZS5ncmF2aXR5O1xuICAgICAgICBlbmdpbmUuYnJvYWRwaGFzZSA9IGVuZ2luZS5ncmlkO1xuICAgICAgICBlbmdpbmUubWV0cmljcyA9IHt9O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGVuZ2luZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHNpbXVsYXRpb24gZm9yd2FyZCBpbiB0aW1lIGJ5IGBkZWx0YWAgbWlsbGlzZWNvbmRzLlxuICAgICAqIFRyaWdnZXJzIGBiZWZvcmVVcGRhdGVgIGFuZCBgYWZ0ZXJVcGRhdGVgIGV2ZW50cy5cbiAgICAgKiBUcmlnZ2VycyBgY29sbGlzaW9uU3RhcnRgLCBgY29sbGlzaW9uQWN0aXZlYCBhbmQgYGNvbGxpc2lvbkVuZGAgZXZlbnRzLlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtlbmdpbmV9IGVuZ2luZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGE9MTYuNjY2XVxuICAgICAqL1xuICAgIEVuZ2luZS51cGRhdGUgPSBmdW5jdGlvbihlbmdpbmUsIGRlbHRhKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBDb21tb24ubm93KCk7XG5cbiAgICAgICAgdmFyIHdvcmxkID0gZW5naW5lLndvcmxkLFxuICAgICAgICAgICAgZGV0ZWN0b3IgPSBlbmdpbmUuZGV0ZWN0b3IsXG4gICAgICAgICAgICBwYWlycyA9IGVuZ2luZS5wYWlycyxcbiAgICAgICAgICAgIHRpbWluZyA9IGVuZ2luZS50aW1pbmcsXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aW1pbmcudGltZXN0YW1wLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICBkZWx0YSA9IHR5cGVvZiBkZWx0YSAhPT0gJ3VuZGVmaW5lZCcgPyBkZWx0YSA6IENvbW1vbi5fYmFzZURlbHRhO1xuICAgICAgICBkZWx0YSAqPSB0aW1pbmcudGltZVNjYWxlO1xuXG4gICAgICAgIC8vIGluY3JlbWVudCB0aW1lc3RhbXBcbiAgICAgICAgdGltaW5nLnRpbWVzdGFtcCArPSBkZWx0YTtcbiAgICAgICAgdGltaW5nLmxhc3REZWx0YSA9IGRlbHRhO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBldmVudCBvYmplY3RcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1pbmcudGltZXN0YW1wLFxuICAgICAgICAgICAgZGVsdGE6IGRlbHRhXG4gICAgICAgIH07XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnYmVmb3JlVXBkYXRlJywgZXZlbnQpO1xuXG4gICAgICAgIC8vIGdldCBhbGwgYm9kaWVzIGFuZCBhbGwgY29uc3RyYWludHMgaW4gdGhlIHdvcmxkXG4gICAgICAgIHZhciBhbGxCb2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKHdvcmxkKSxcbiAgICAgICAgICAgIGFsbENvbnN0cmFpbnRzID0gQ29tcG9zaXRlLmFsbENvbnN0cmFpbnRzKHdvcmxkKTtcblxuICAgICAgICAvLyBpZiB0aGUgd29ybGQgaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKHdvcmxkLmlzTW9kaWZpZWQpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZGV0ZWN0b3IgYm9kaWVzXG4gICAgICAgICAgICBEZXRlY3Rvci5zZXRCb2RpZXMoZGV0ZWN0b3IsIGFsbEJvZGllcyk7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGFsbCBjb21wb3NpdGUgbW9kaWZpZWQgZmxhZ3NcbiAgICAgICAgICAgIENvbXBvc2l0ZS5zZXRNb2RpZmllZCh3b3JsZCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBzbGVlcGluZyBpZiBlbmFibGVkXG4gICAgICAgIGlmIChlbmdpbmUuZW5hYmxlU2xlZXBpbmcpXG4gICAgICAgICAgICBTbGVlcGluZy51cGRhdGUoYWxsQm9kaWVzLCBkZWx0YSk7XG5cbiAgICAgICAgLy8gYXBwbHkgZ3Jhdml0eSB0byBhbGwgYm9kaWVzXG4gICAgICAgIEVuZ2luZS5fYm9kaWVzQXBwbHlHcmF2aXR5KGFsbEJvZGllcywgZW5naW5lLmdyYXZpdHkpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBhbGwgYm9keSBwb3NpdGlvbiBhbmQgcm90YXRpb24gYnkgaW50ZWdyYXRpb25cbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgRW5naW5lLl9ib2RpZXNVcGRhdGUoYWxsQm9kaWVzLCBkZWx0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgYWxsIGNvbnN0cmFpbnRzIChmaXJzdCBwYXNzKVxuICAgICAgICBDb25zdHJhaW50LnByZVNvbHZlQWxsKGFsbEJvZGllcyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmdpbmUuY29uc3RyYWludEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgQ29uc3RyYWludC5zb2x2ZUFsbChhbGxDb25zdHJhaW50cywgZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIENvbnN0cmFpbnQucG9zdFNvbHZlQWxsKGFsbEJvZGllcyk7XG5cbiAgICAgICAgLy8gZmluZCBhbGwgY29sbGlzaW9uc1xuICAgICAgICBkZXRlY3Rvci5wYWlycyA9IGVuZ2luZS5wYWlycztcbiAgICAgICAgdmFyIGNvbGxpc2lvbnMgPSBEZXRlY3Rvci5jb2xsaXNpb25zKGRldGVjdG9yKTtcblxuICAgICAgICAvLyB1cGRhdGUgY29sbGlzaW9uIHBhaXJzXG4gICAgICAgIFBhaXJzLnVwZGF0ZShwYWlycywgY29sbGlzaW9ucywgdGltZXN0YW1wKTtcblxuICAgICAgICAvLyB3YWtlIHVwIGJvZGllcyBpbnZvbHZlZCBpbiBjb2xsaXNpb25zXG4gICAgICAgIGlmIChlbmdpbmUuZW5hYmxlU2xlZXBpbmcpXG4gICAgICAgICAgICBTbGVlcGluZy5hZnRlckNvbGxpc2lvbnMocGFpcnMubGlzdCk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBjb2xsaXNpb24gZXZlbnRzXG4gICAgICAgIGlmIChwYWlycy5jb2xsaXNpb25TdGFydC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnY29sbGlzaW9uU3RhcnQnLCB7IHBhaXJzOiBwYWlycy5jb2xsaXNpb25TdGFydCB9KTtcblxuICAgICAgICAvLyBpdGVyYXRpdmVseSByZXNvbHZlIHBvc2l0aW9uIGJldHdlZW4gY29sbGlzaW9uc1xuICAgICAgICB2YXIgcG9zaXRpb25EYW1waW5nID0gQ29tbW9uLmNsYW1wKDIwIC8gZW5naW5lLnBvc2l0aW9uSXRlcmF0aW9ucywgMCwgMSk7XG4gICAgICAgIFxuICAgICAgICBSZXNvbHZlci5wcmVTb2x2ZVBvc2l0aW9uKHBhaXJzLmxpc3QpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5naW5lLnBvc2l0aW9uSXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBSZXNvbHZlci5zb2x2ZVBvc2l0aW9uKHBhaXJzLmxpc3QsIGRlbHRhLCBwb3NpdGlvbkRhbXBpbmcpO1xuICAgICAgICB9XG4gICAgICAgIFJlc29sdmVyLnBvc3RTb2x2ZVBvc2l0aW9uKGFsbEJvZGllcyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGFsbCBjb25zdHJhaW50cyAoc2Vjb25kIHBhc3MpXG4gICAgICAgIENvbnN0cmFpbnQucHJlU29sdmVBbGwoYWxsQm9kaWVzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVuZ2luZS5jb25zdHJhaW50SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBDb25zdHJhaW50LnNvbHZlQWxsKGFsbENvbnN0cmFpbnRzLCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgQ29uc3RyYWludC5wb3N0U29sdmVBbGwoYWxsQm9kaWVzKTtcblxuICAgICAgICAvLyBpdGVyYXRpdmVseSByZXNvbHZlIHZlbG9jaXR5IGJldHdlZW4gY29sbGlzaW9uc1xuICAgICAgICBSZXNvbHZlci5wcmVTb2x2ZVZlbG9jaXR5KHBhaXJzLmxpc3QpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW5naW5lLnZlbG9jaXR5SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBSZXNvbHZlci5zb2x2ZVZlbG9jaXR5KHBhaXJzLmxpc3QsIGRlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBib2R5IHNwZWVkIGFuZCB2ZWxvY2l0eSBwcm9wZXJ0aWVzXG4gICAgICAgIEVuZ2luZS5fYm9kaWVzVXBkYXRlVmVsb2NpdGllcyhhbGxCb2RpZXMpO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgY29sbGlzaW9uIGV2ZW50c1xuICAgICAgICBpZiAocGFpcnMuY29sbGlzaW9uQWN0aXZlLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihlbmdpbmUsICdjb2xsaXNpb25BY3RpdmUnLCB7IHBhaXJzOiBwYWlycy5jb2xsaXNpb25BY3RpdmUgfSk7XG5cbiAgICAgICAgaWYgKHBhaXJzLmNvbGxpc2lvbkVuZC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgRXZlbnRzLnRyaWdnZXIoZW5naW5lLCAnY29sbGlzaW9uRW5kJywgeyBwYWlyczogcGFpcnMuY29sbGlzaW9uRW5kIH0pO1xuXG4gICAgICAgIC8vIGNsZWFyIGZvcmNlIGJ1ZmZlcnNcbiAgICAgICAgRW5naW5lLl9ib2RpZXNDbGVhckZvcmNlcyhhbGxCb2RpZXMpO1xuXG4gICAgICAgIEV2ZW50cy50cmlnZ2VyKGVuZ2luZSwgJ2FmdGVyVXBkYXRlJywgZXZlbnQpO1xuXG4gICAgICAgIC8vIGxvZyB0aGUgdGltZSBlbGFwc2VkIGNvbXB1dGluZyB0aGlzIHVwZGF0ZVxuICAgICAgICBlbmdpbmUudGltaW5nLmxhc3RFbGFwc2VkID0gQ29tbW9uLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdHdvIGVuZ2luZXMgYnkga2VlcGluZyB0aGUgY29uZmlndXJhdGlvbiBvZiBgZW5naW5lQWAgYnV0IHJlcGxhY2luZyB0aGUgd29ybGQgd2l0aCB0aGUgb25lIGZyb20gYGVuZ2luZUJgLlxuICAgICAqIEBtZXRob2QgbWVyZ2VcbiAgICAgKiBAcGFyYW0ge2VuZ2luZX0gZW5naW5lQVxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVCXG4gICAgICovXG4gICAgRW5naW5lLm1lcmdlID0gZnVuY3Rpb24oZW5naW5lQSwgZW5naW5lQikge1xuICAgICAgICBDb21tb24uZXh0ZW5kKGVuZ2luZUEsIGVuZ2luZUIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVuZ2luZUIud29ybGQpIHtcbiAgICAgICAgICAgIGVuZ2luZUEud29ybGQgPSBlbmdpbmVCLndvcmxkO1xuXG4gICAgICAgICAgICBFbmdpbmUuY2xlYXIoZW5naW5lQSk7XG5cbiAgICAgICAgICAgIHZhciBib2RpZXMgPSBDb21wb3NpdGUuYWxsQm9kaWVzKGVuZ2luZUEud29ybGQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChib2R5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYm9keS5pZCA9IENvbW1vbi5uZXh0SWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGVuZ2luZSBwYWlycyBhbmQgZGV0ZWN0b3IuXG4gICAgICogQG1ldGhvZCBjbGVhclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cbiAgICBFbmdpbmUuY2xlYXIgPSBmdW5jdGlvbihlbmdpbmUpIHtcbiAgICAgICAgUGFpcnMuY2xlYXIoZW5naW5lLnBhaXJzKTtcbiAgICAgICAgRGV0ZWN0b3IuY2xlYXIoZW5naW5lLmRldGVjdG9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogWmVyb2VzIHRoZSBgYm9keS5mb3JjZWAgYW5kIGBib2R5LnRvcnF1ZWAgZm9yY2UgYnVmZmVycy5cbiAgICAgKiBAbWV0aG9kIF9ib2RpZXNDbGVhckZvcmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzQ2xlYXJGb3JjZXMgPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgdmFyIGJvZGllc0xlbmd0aCA9IGJvZGllcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGZvcmNlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGJvZHkuZm9yY2UueCA9IDA7XG4gICAgICAgICAgICBib2R5LmZvcmNlLnkgPSAwO1xuICAgICAgICAgICAgYm9keS50b3JxdWUgPSAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZ3Jhdml0YXRpb25hbCBhY2NlbGVyYXRpb24gdG8gYWxsIGBib2RpZXNgLlxuICAgICAqIFRoaXMgbW9kZWxzIGEgW3VuaWZvcm0gZ3Jhdml0YXRpb25hbCBmaWVsZF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3Jhdml0eV9vZl9FYXJ0aCksIHNpbWlsYXIgdG8gbmVhciB0aGUgc3VyZmFjZSBvZiBhIHBsYW5ldC5cbiAgICAgKiBcbiAgICAgKiBAbWV0aG9kIF9ib2RpZXNBcHBseUdyYXZpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gZ3Jhdml0eVxuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzQXBwbHlHcmF2aXR5ID0gZnVuY3Rpb24oYm9kaWVzLCBncmF2aXR5KSB7XG4gICAgICAgIHZhciBncmF2aXR5U2NhbGUgPSB0eXBlb2YgZ3Jhdml0eS5zY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBncmF2aXR5LnNjYWxlIDogMC4wMDEsXG4gICAgICAgICAgICBib2RpZXNMZW5ndGggPSBib2RpZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICgoZ3Jhdml0eS54ID09PSAwICYmIGdyYXZpdHkueSA9PT0gMCkgfHwgZ3Jhdml0eVNjYWxlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5pc1N0YXRpYyB8fCBib2R5LmlzU2xlZXBpbmcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcmVzdWx0YW50IGZvcmNlIG9mIGdyYXZpdHlcbiAgICAgICAgICAgIGJvZHkuZm9yY2UueSArPSBib2R5Lm1hc3MgKiBncmF2aXR5LnkgKiBncmF2aXR5U2NhbGU7XG4gICAgICAgICAgICBib2R5LmZvcmNlLnggKz0gYm9keS5tYXNzICogZ3Jhdml0eS54ICogZ3Jhdml0eVNjYWxlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYEJvZHkudXBkYXRlYCB0byBhbGwgZ2l2ZW4gYGJvZGllc2AuXG4gICAgICogQG1ldGhvZCBfYm9kaWVzVXBkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIFRoZSBhbW91bnQgb2YgdGltZSBlbGFwc2VkIGJldHdlZW4gdXBkYXRlc1xuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzVXBkYXRlID0gZnVuY3Rpb24oYm9kaWVzLCBkZWx0YSkge1xuICAgICAgICB2YXIgYm9kaWVzTGVuZ3RoID0gYm9kaWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaXNTdGF0aWMgfHwgYm9keS5pc1NsZWVwaW5nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBCb2R5LnVwZGF0ZShib2R5LCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBgQm9keS51cGRhdGVWZWxvY2l0aWVzYCB0byBhbGwgZ2l2ZW4gYGJvZGllc2AuXG4gICAgICogQG1ldGhvZCBfYm9kaWVzVXBkYXRlVmVsb2NpdGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqL1xuICAgIEVuZ2luZS5fYm9kaWVzVXBkYXRlVmVsb2NpdGllcyA9IGZ1bmN0aW9uKGJvZGllcykge1xuICAgICAgICB2YXIgYm9kaWVzTGVuZ3RoID0gYm9kaWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBCb2R5LnVwZGF0ZVZlbG9jaXRpZXMoYm9kaWVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGRlcHJlY2F0ZWQgYWxpYXMgZm9yIGBSdW5uZXIucnVuYCwgdXNlIGBNYXR0ZXIuUnVubmVyLnJ1bihlbmdpbmUpYCBpbnN0ZWFkIGFuZCBzZWUgYE1hdHRlci5SdW5uZXJgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBNYXR0ZXIuUnVubmVyLnJ1bihlbmdpbmUpIGluc3RlYWRcbiAgICAgKiBAbWV0aG9kIHJ1blxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQganVzdCBiZWZvcmUgYW4gdXBkYXRlXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZVVwZGF0ZVxuICAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZGVsdGEgVGhlIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHZhbHVlIHVzZWQgaW4gdGhlIHVwZGF0ZVxuICAgICogQHBhcmFtIHtlbmdpbmV9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGFmdGVyIGVuZ2luZSB1cGRhdGUgYW5kIGFsbCBjb2xsaXNpb24gZXZlbnRzXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyVXBkYXRlXG4gICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC5kZWx0YSBUaGUgZGVsdGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdmFsdWUgdXNlZCBpbiB0aGUgdXBkYXRlXG4gICAgKiBAcGFyYW0ge2VuZ2luZX0gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGhhdmUgc3RhcnRlZCB0byBjb2xsaWRlIGluIHRoZSBjdXJyZW50IHRpY2sgKGlmIGFueSlcbiAgICAqXG4gICAgKiBAZXZlbnQgY29sbGlzaW9uU3RhcnRcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7cGFpcltdfSBldmVudC5wYWlycyBMaXN0IG9mIGFmZmVjdGVkIHBhaXJzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC5kZWx0YSBUaGUgZGVsdGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdmFsdWUgdXNlZCBpbiB0aGUgdXBkYXRlXG4gICAgKiBAcGFyYW0ge2VuZ2luZX0gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGFyZSBjb2xsaWRpbmcgaW4gdGhlIGN1cnJlbnQgdGljayAoaWYgYW55KVxuICAgICpcbiAgICAqIEBldmVudCBjb2xsaXNpb25BY3RpdmVcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7cGFpcltdfSBldmVudC5wYWlycyBMaXN0IG9mIGFmZmVjdGVkIHBhaXJzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC5kZWx0YSBUaGUgZGVsdGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdmFsdWUgdXNlZCBpbiB0aGUgdXBkYXRlXG4gICAgKiBAcGFyYW0ge2VuZ2luZX0gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgZW5naW5lIHVwZGF0ZSwgcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBwYWlycyB0aGF0IGhhdmUgZW5kZWQgY29sbGlzaW9uIGluIHRoZSBjdXJyZW50IHRpY2sgKGlmIGFueSlcbiAgICAqXG4gICAgKiBAZXZlbnQgY29sbGlzaW9uRW5kXG4gICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge3BhaXJbXX0gZXZlbnQucGFpcnMgTGlzdCBvZiBhZmZlY3RlZCBwYWlyc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZGVsdGEgVGhlIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHZhbHVlIHVzZWQgaW4gdGhlIHVwZGF0ZVxuICAgICogQHBhcmFtIHtlbmdpbmV9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbiBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBoaWdoZXIgcXVhbGl0eSB0aGUgc2ltdWxhdGlvbiB3aWxsIGJlIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uSXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDZcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB2ZWxvY2l0eSBpdGVyYXRpb25zIHRvIHBlcmZvcm0gZWFjaCB1cGRhdGUuXG4gICAgICogVGhlIGhpZ2hlciB0aGUgdmFsdWUsIHRoZSBoaWdoZXIgcXVhbGl0eSB0aGUgc2ltdWxhdGlvbiB3aWxsIGJlIGF0IHRoZSBleHBlbnNlIG9mIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHZlbG9jaXR5SXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGludGVnZXIgYE51bWJlcmAgdGhhdCBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiBjb25zdHJhaW50IGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBlYWNoIHVwZGF0ZS5cbiAgICAgKiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGhpZ2hlciBxdWFsaXR5IHRoZSBzaW11bGF0aW9uIHdpbGwgYmUgYXQgdGhlIGV4cGVuc2Ugb2YgcGVyZm9ybWFuY2UuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgYDJgIGlzIHVzdWFsbHkgdmVyeSBhZGVxdWF0ZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb25zdHJhaW50SXRlcmF0aW9uc1xuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBlbmdpbmUgc2hvdWxkIGFsbG93IHNsZWVwaW5nIHZpYSB0aGUgYE1hdHRlci5TbGVlcGluZ2AgbW9kdWxlLlxuICAgICAqIFNsZWVwaW5nIGNhbiBpbXByb3ZlIHN0YWJpbGl0eSBhbmQgcGVyZm9ybWFuY2UsIGJ1dCBvZnRlbiBhdCB0aGUgZXhwZW5zZSBvZiBhY2N1cmFjeS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVTbGVlcGluZ1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gYE9iamVjdGAgY29udGFpbmluZyBwcm9wZXJ0aWVzIHJlZ2FyZGluZyB0aGUgdGltaW5nIHN5c3RlbXMgb2YgdGhlIGVuZ2luZS4gXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSBnbG9iYWwgc2NhbGluZyBmYWN0b3Igb2YgdGltZSBmb3IgYWxsIGJvZGllcy5cbiAgICAgKiBBIHZhbHVlIG9mIGAwYCBmcmVlemVzIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIEEgdmFsdWUgb2YgYDAuMWAgZ2l2ZXMgYSBzbG93LW1vdGlvbiBlZmZlY3QuXG4gICAgICogQSB2YWx1ZSBvZiBgMS4yYCBnaXZlcyBhIHNwZWVkLXVwIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcudGltZVNjYWxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHNwZWNpZmllcyB0aGUgY3VycmVudCBzaW11bGF0aW9uLXRpbWUgaW4gbWlsbGlzZWNvbmRzIHN0YXJ0aW5nIGZyb20gYDBgLiBcbiAgICAgKiBJdCBpcyBpbmNyZW1lbnRlZCBvbiBldmVyeSBgRW5naW5lLnVwZGF0ZWAgYnkgdGhlIGdpdmVuIGBkZWx0YWAgYXJndW1lbnQuIFxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcudGltZXN0YW1wXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHJlcHJlc2VudHMgdGhlIHRvdGFsIGV4ZWN1dGlvbiB0aW1lIGVsYXBzZWQgZHVyaW5nIHRoZSBsYXN0IGBFbmdpbmUudXBkYXRlYCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogSXQgaXMgdXBkYXRlZCBieSB0aW1pbmcgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxhc3QgYEVuZ2luZS51cGRhdGVgIGNhbGwgdW50aWwgaXQgZW5kcy5cbiAgICAgKlxuICAgICAqIFRoaXMgdmFsdWUgd2lsbCBhbHNvIGluY2x1ZGUgdGhlIHRvdGFsIGV4ZWN1dGlvbiB0aW1lIG9mIGFsbCBldmVudCBoYW5kbGVycyBkaXJlY3RseSBvciBpbmRpcmVjdGx5IHRyaWdnZXJlZCBieSB0aGUgZW5naW5lIHVwZGF0ZS5cbiAgICAgKiBcbiAgICAgKiBAcHJvcGVydHkgdGltaW5nLmxhc3RFbGFwc2VkXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTnVtYmVyYCB0aGF0IHJlcHJlc2VudHMgdGhlIGBkZWx0YWAgdmFsdWUgdXNlZCBpbiB0aGUgbGFzdCBlbmdpbmUgdXBkYXRlLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSB0aW1pbmcubGFzdERlbHRhXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBgTWF0dGVyLkRldGVjdG9yYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkZXRlY3RvclxuICAgICAqIEB0eXBlIGRldGVjdG9yXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuRGV0ZWN0b3IgaW5zdGFuY2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYE1hdHRlci5HcmlkYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IGBlbmdpbmUuZGV0ZWN0b3JgXG4gICAgICogQHByb3BlcnR5IGdyaWRcbiAgICAgKiBAdHlwZSBncmlkXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuR3JpZCBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZWQgYnkgYW5kIG5vdyBhbGlhcyBmb3IgYGVuZ2luZS5ncmlkYC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IGBlbmdpbmUuZGV0ZWN0b3JgXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSBncmlkXG4gICAgICogQGRlZmF1bHQgYSBNYXR0ZXIuR3JpZCBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJvb3QgYE1hdHRlci5Db21wb3NpdGVgIGluc3RhbmNlIHRoYXQgd2lsbCBjb250YWluIGFsbCBib2RpZXMsIGNvbnN0cmFpbnRzIGFuZCBvdGhlciBjb21wb3NpdGVzIHRvIGJlIHNpbXVsYXRlZCBieSB0aGlzIGVuZ2luZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIGNvbXBvc2l0ZVxuICAgICAqIEBkZWZhdWx0IGEgTWF0dGVyLkNvbXBvc2l0ZSBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlc2VydmVkIGZvciBzdG9yaW5nIHBsdWdpbi1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHBsdWdpblxuICAgICAqIEB0eXBlIHt9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBbiBvcHRpb25hbCBncmF2aXRhdGlvbmFsIGFjY2VsZXJhdGlvbiBhcHBsaWVkIHRvIGFsbCBib2RpZXMgaW4gYGVuZ2luZS53b3JsZGAgb24gZXZlcnkgdXBkYXRlLlxuICAgICAqIFxuICAgICAqIFRoaXMgbW9kZWxzIGEgW3VuaWZvcm0gZ3Jhdml0YXRpb25hbCBmaWVsZF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3Jhdml0eV9vZl9FYXJ0aCksIHNpbWlsYXIgdG8gbmVhciB0aGUgc3VyZmFjZSBvZiBhIHBsYW5ldC4gRm9yIGdyYXZpdHkgaW4gb3RoZXIgY29udGV4dHMsIGRpc2FibGUgdGhpcyBhbmQgYXBwbHkgZm9yY2VzIGFzIG5lZWRlZC5cbiAgICAgKiBcbiAgICAgKiBUbyBkaXNhYmxlIHNldCB0aGUgYHNjYWxlYCBjb21wb25lbnQgdG8gYDBgLlxuICAgICAqIFxuICAgICAqIFRoaXMgaXMgc3BsaXQgaW50byB0aHJlZSBjb21wb25lbnRzIGZvciBlYXNlIG9mIHVzZTogIFxuICAgICAqIGEgbm9ybWFsaXNlZCBkaXJlY3Rpb24gKGB4YCBhbmQgYHlgKSBhbmQgbWFnbml0dWRlIChgc2NhbGVgKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3Jhdml0YXRpb25hbCBkaXJlY3Rpb24gbm9ybWFsIGB4YCBjb21wb25lbnQsIHRvIGJlIG11bHRpcGxpZWQgYnkgYGdyYXZpdHkuc2NhbGVgLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnhcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ3Jhdml0YXRpb25hbCBkaXJlY3Rpb24gbm9ybWFsIGB5YCBjb21wb25lbnQsIHRvIGJlIG11bHRpcGxpZWQgYnkgYGdyYXZpdHkuc2NhbGVgLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHkueVxuICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBtYWduaXR1ZGUgb2YgdGhlIGdyYXZpdGF0aW9uYWwgYWNjZWxlcmF0aW9uLlxuICAgICAqIFxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5LnNjYWxlXG4gICAgICogQHR5cGUgb2JqZWN0XG4gICAgICogQGRlZmF1bHQgMC4wMDFcbiAgICAgKi9cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5SZXNvbHZlcmAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIHJlc29sdmluZyBjb2xsaXNpb24gcGFpcnMuXG4qXG4qIEBjbGFzcyBSZXNvbHZlclxuKi9cblxudmFyIFJlc29sdmVyID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzb2x2ZXI7XG5cbnZhciBWZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBCb3VuZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICBSZXNvbHZlci5fcmVzdGluZ1RocmVzaCA9IDI7XG4gICAgUmVzb2x2ZXIuX3Jlc3RpbmdUaHJlc2hUYW5nZW50ID0gTWF0aC5zcXJ0KDYpO1xuICAgIFJlc29sdmVyLl9wb3NpdGlvbkRhbXBlbiA9IDAuOTtcbiAgICBSZXNvbHZlci5fcG9zaXRpb25XYXJtaW5nID0gMC44O1xuICAgIFJlc29sdmVyLl9mcmljdGlvbk5vcm1hbE11bHRpcGxpZXIgPSA1O1xuICAgIFJlc29sdmVyLl9mcmljdGlvbk1heFN0YXRpYyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHBhaXJzIGZvciBwb3NpdGlvbiBzb2x2aW5nLlxuICAgICAqIEBtZXRob2QgcHJlU29sdmVQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqL1xuICAgIFJlc29sdmVyLnByZVNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihwYWlycykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBhY3RpdmVDb3VudCxcbiAgICAgICAgICAgIHBhaXJzTGVuZ3RoID0gcGFpcnMubGVuZ3RoO1xuXG4gICAgICAgIC8vIGZpbmQgdG90YWwgY29udGFjdHMgb24gZWFjaCBib2R5XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlyc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYWN0aXZlQ291bnQgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aDtcbiAgICAgICAgICAgIHBhaXIuY29sbGlzaW9uLnBhcmVudEEudG90YWxDb250YWN0cyArPSBhY3RpdmVDb3VudDtcbiAgICAgICAgICAgIHBhaXIuY29sbGlzaW9uLnBhcmVudEIudG90YWxDb250YWN0cyArPSBhY3RpdmVDb3VudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgc29sdXRpb24gZm9yIHBhaXIgcG9zaXRpb25zLlxuICAgICAqIEBtZXRob2Qgc29sdmVQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGFtcGluZz0xXVxuICAgICAqL1xuICAgIFJlc29sdmVyLnNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihwYWlycywgZGVsdGEsIGRhbXBpbmcpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwYWlyLFxuICAgICAgICAgICAgY29sbGlzaW9uLFxuICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgIGNvbnRhY3RTaGFyZSxcbiAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uRGFtcGVuID0gUmVzb2x2ZXIuX3Bvc2l0aW9uRGFtcGVuICogKGRhbXBpbmcgfHwgMSksXG4gICAgICAgICAgICBzbG9wRGFtcGVuID0gQ29tbW9uLmNsYW1wKGRlbHRhIC8gQ29tbW9uLl9iYXNlRGVsdGEsIDAsIDEpLFxuICAgICAgICAgICAgcGFpcnNMZW5ndGggPSBwYWlycy5sZW5ndGg7XG5cbiAgICAgICAgLy8gZmluZCBpbXB1bHNlcyByZXF1aXJlZCB0byByZXNvbHZlIHBlbmV0cmF0aW9uXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlyc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSB8fCBwYWlyLmlzU2Vuc29yKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbjtcbiAgICAgICAgICAgIGJvZHlBID0gY29sbGlzaW9uLnBhcmVudEE7XG4gICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5wYXJlbnRCO1xuICAgICAgICAgICAgbm9ybWFsID0gY29sbGlzaW9uLm5vcm1hbDtcblxuICAgICAgICAgICAgLy8gZ2V0IGN1cnJlbnQgc2VwYXJhdGlvbiBiZXR3ZWVuIGJvZHkgZWRnZXMgaW52b2x2ZWQgaW4gY29sbGlzaW9uXG4gICAgICAgICAgICBwYWlyLnNlcGFyYXRpb24gPSBcbiAgICAgICAgICAgICAgICBub3JtYWwueCAqIChib2R5Qi5wb3NpdGlvbkltcHVsc2UueCArIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi54IC0gYm9keUEucG9zaXRpb25JbXB1bHNlLngpXG4gICAgICAgICAgICAgICAgKyBub3JtYWwueSAqIChib2R5Qi5wb3NpdGlvbkltcHVsc2UueSArIGNvbGxpc2lvbi5wZW5ldHJhdGlvbi55IC0gYm9keUEucG9zaXRpb25JbXB1bHNlLnkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpciA9IHBhaXJzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBO1xuICAgICAgICAgICAgYm9keUIgPSBjb2xsaXNpb24ucGFyZW50QjtcbiAgICAgICAgICAgIG5vcm1hbCA9IGNvbGxpc2lvbi5ub3JtYWw7XG4gICAgICAgICAgICBwb3NpdGlvbkltcHVsc2UgPSBwYWlyLnNlcGFyYXRpb24gLSBwYWlyLnNsb3AgKiBzbG9wRGFtcGVuO1xuXG4gICAgICAgICAgICBpZiAoYm9keUEuaXNTdGF0aWMgfHwgYm9keUIuaXNTdGF0aWMpXG4gICAgICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlICo9IDI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghKGJvZHlBLmlzU3RhdGljIHx8IGJvZHlBLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdFNoYXJlID0gcG9zaXRpb25EYW1wZW4gLyBib2R5QS50b3RhbENvbnRhY3RzO1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uSW1wdWxzZS54ICs9IG5vcm1hbC54ICogcG9zaXRpb25JbXB1bHNlICogY29udGFjdFNoYXJlO1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uSW1wdWxzZS55ICs9IG5vcm1hbC55ICogcG9zaXRpb25JbXB1bHNlICogY29udGFjdFNoYXJlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShib2R5Qi5pc1N0YXRpYyB8fCBib2R5Qi5pc1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgICAgIGNvbnRhY3RTaGFyZSA9IHBvc2l0aW9uRGFtcGVuIC8gYm9keUIudG90YWxDb250YWN0cztcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueCAtPSBub3JtYWwueCAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcbiAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvbkltcHVsc2UueSAtPSBub3JtYWwueSAqIHBvc2l0aW9uSW1wdWxzZSAqIGNvbnRhY3RTaGFyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBwb3NpdGlvbiByZXNvbHV0aW9uLlxuICAgICAqIEBtZXRob2QgcG9zdFNvbHZlUG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICovXG4gICAgUmVzb2x2ZXIucG9zdFNvbHZlUG9zaXRpb24gPSBmdW5jdGlvbihib2RpZXMpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uV2FybWluZyA9IFJlc29sdmVyLl9wb3NpdGlvbldhcm1pbmcsXG4gICAgICAgICAgICBib2RpZXNMZW5ndGggPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICAgICAgdmVydGljZXNUcmFuc2xhdGUgPSBWZXJ0aWNlcy50cmFuc2xhdGUsXG4gICAgICAgICAgICBib3VuZHNVcGRhdGUgPSBCb3VuZHMudXBkYXRlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZSA9IGJvZHkucG9zaXRpb25JbXB1bHNlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZVggPSBwb3NpdGlvbkltcHVsc2UueCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkltcHVsc2VZID0gcG9zaXRpb25JbXB1bHNlLnksXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgPSBib2R5LnZlbG9jaXR5O1xuXG4gICAgICAgICAgICAvLyByZXNldCBjb250YWN0IGNvdW50XG4gICAgICAgICAgICBib2R5LnRvdGFsQ29udGFjdHMgPSAwO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb25JbXB1bHNlWCAhPT0gMCB8fCBwb3NpdGlvbkltcHVsc2VZICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGJvZHkgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1RyYW5zbGF0ZShwYXJ0LnZlcnRpY2VzLCBwb3NpdGlvbkltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICBib3VuZHNVcGRhdGUocGFydC5ib3VuZHMsIHBhcnQudmVydGljZXMsIHZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgcGFydC5wb3NpdGlvbi54ICs9IHBvc2l0aW9uSW1wdWxzZVg7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQucG9zaXRpb24ueSArPSBwb3NpdGlvbkltcHVsc2VZO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGJvZHkgd2l0aG91dCBjaGFuZ2luZyB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIGJvZHkucG9zaXRpb25QcmV2LnggKz0gcG9zaXRpb25JbXB1bHNlWDtcbiAgICAgICAgICAgICAgICBib2R5LnBvc2l0aW9uUHJldi55ICs9IHBvc2l0aW9uSW1wdWxzZVk7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25JbXB1bHNlWCAqIHZlbG9jaXR5LnggKyBwb3NpdGlvbkltcHVsc2VZICogdmVsb2NpdHkueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgY2FjaGVkIGltcHVsc2UgaWYgdGhlIGJvZHkgaGFzIHZlbG9jaXR5IGFsb25nIGl0XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZS54ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlLnkgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcm0gdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uSW1wdWxzZS54ICo9IHBvc2l0aW9uV2FybWluZztcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25JbXB1bHNlLnkgKj0gcG9zaXRpb25XYXJtaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHBhaXJzIGZvciB2ZWxvY2l0eSBzb2x2aW5nLlxuICAgICAqIEBtZXRob2QgcHJlU29sdmVWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqL1xuICAgIFJlc29sdmVyLnByZVNvbHZlVmVsb2NpdHkgPSBmdW5jdGlvbihwYWlycykge1xuICAgICAgICB2YXIgcGFpcnNMZW5ndGggPSBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgajtcbiAgICAgICAgXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlyc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXBhaXIuaXNBY3RpdmUgfHwgcGFpci5pc1NlbnNvcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvbnRhY3RzID0gcGFpci5hY3RpdmVDb250YWN0cyxcbiAgICAgICAgICAgICAgICBjb250YWN0c0xlbmd0aCA9IGNvbnRhY3RzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24gPSBwYWlyLmNvbGxpc2lvbixcbiAgICAgICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5wYXJlbnRBLFxuICAgICAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLnBhcmVudEIsXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gY29sbGlzaW9uLm5vcm1hbCxcbiAgICAgICAgICAgICAgICB0YW5nZW50ID0gY29sbGlzaW9uLnRhbmdlbnQ7XG4gICAgXG4gICAgICAgICAgICAvLyByZXNvbHZlIGVhY2ggY29udGFjdFxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbnRhY3RzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGNvbnRhY3RzW2pdLFxuICAgICAgICAgICAgICAgICAgICBjb250YWN0VmVydGV4ID0gY29udGFjdC52ZXJ0ZXgsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbEltcHVsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsSW1wdWxzZSAhPT0gMCB8fCB0YW5nZW50SW1wdWxzZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b3RhbCBpbXB1bHNlIGZyb20gY29udGFjdFxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZVggPSBub3JtYWwueCAqIG5vcm1hbEltcHVsc2UgKyB0YW5nZW50LnggKiB0YW5nZW50SW1wdWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2VZID0gbm9ybWFsLnkgKiBub3JtYWxJbXB1bHNlICsgdGFuZ2VudC55ICogdGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBpbXB1bHNlIGZyb20gY29udGFjdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIShib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEucG9zaXRpb25QcmV2LnggKz0gaW1wdWxzZVggKiBib2R5QS5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uUHJldi55ICs9IGltcHVsc2VZICogYm9keUEuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hbmdsZVByZXYgKz0gYm9keUEuaW52ZXJzZUluZXJ0aWEgKiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRhY3RWZXJ0ZXgueCAtIGJvZHlBLnBvc2l0aW9uLngpICogaW1wdWxzZVlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIChjb250YWN0VmVydGV4LnkgLSBib2R5QS5wb3NpdGlvbi55KSAqIGltcHVsc2VYXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5wb3NpdGlvblByZXYueCAtPSBpbXB1bHNlWCAqIGJvZHlCLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb25QcmV2LnkgLT0gaW1wdWxzZVkgKiBib2R5Qi5pbnZlcnNlTWFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLmFuZ2xlUHJldiAtPSBib2R5Qi5pbnZlcnNlSW5lcnRpYSAqIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29udGFjdFZlcnRleC54IC0gYm9keUIucG9zaXRpb24ueCkgKiBpbXB1bHNlWSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIChjb250YWN0VmVydGV4LnkgLSBib2R5Qi5wb3NpdGlvbi55KSAqIGltcHVsc2VYXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBzb2x1dGlvbiBmb3IgcGFpciB2ZWxvY2l0aWVzLlxuICAgICAqIEBtZXRob2Qgc29sdmVWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVxuICAgICAqL1xuICAgIFJlc29sdmVyLnNvbHZlVmVsb2NpdHkgPSBmdW5jdGlvbihwYWlycywgZGVsdGEpIHtcbiAgICAgICAgdmFyIHRpbWVTY2FsZSA9IGRlbHRhIC8gQ29tbW9uLl9iYXNlRGVsdGEsXG4gICAgICAgICAgICB0aW1lU2NhbGVTcXVhcmVkID0gdGltZVNjYWxlICogdGltZVNjYWxlLFxuICAgICAgICAgICAgdGltZVNjYWxlQ3ViZWQgPSB0aW1lU2NhbGVTcXVhcmVkICogdGltZVNjYWxlLFxuICAgICAgICAgICAgcmVzdGluZ1RocmVzaCA9IC1SZXNvbHZlci5fcmVzdGluZ1RocmVzaCAqIHRpbWVTY2FsZSxcbiAgICAgICAgICAgIHJlc3RpbmdUaHJlc2hUYW5nZW50ID0gUmVzb2x2ZXIuX3Jlc3RpbmdUaHJlc2hUYW5nZW50LFxuICAgICAgICAgICAgZnJpY3Rpb25Ob3JtYWxNdWx0aXBsaWVyID0gUmVzb2x2ZXIuX2ZyaWN0aW9uTm9ybWFsTXVsdGlwbGllciAqIHRpbWVTY2FsZSxcbiAgICAgICAgICAgIGZyaWN0aW9uTWF4U3RhdGljID0gUmVzb2x2ZXIuX2ZyaWN0aW9uTWF4U3RhdGljLFxuICAgICAgICAgICAgcGFpcnNMZW5ndGggPSBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgICB0YW5nZW50SW1wdWxzZSxcbiAgICAgICAgICAgIG1heEZyaWN0aW9uLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSB8fCBwYWlyLmlzU2Vuc29yKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb24sXG4gICAgICAgICAgICAgICAgYm9keUEgPSBjb2xsaXNpb24ucGFyZW50QSxcbiAgICAgICAgICAgICAgICBib2R5QiA9IGNvbGxpc2lvbi5wYXJlbnRCLFxuICAgICAgICAgICAgICAgIGJvZHlBVmVsb2NpdHkgPSBib2R5QS52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICBib2R5QlZlbG9jaXR5ID0gYm9keUIudmVsb2NpdHksXG4gICAgICAgICAgICAgICAgbm9ybWFsWCA9IGNvbGxpc2lvbi5ub3JtYWwueCxcbiAgICAgICAgICAgICAgICBub3JtYWxZID0gY29sbGlzaW9uLm5vcm1hbC55LFxuICAgICAgICAgICAgICAgIHRhbmdlbnRYID0gY29sbGlzaW9uLnRhbmdlbnQueCxcbiAgICAgICAgICAgICAgICB0YW5nZW50WSA9IGNvbGxpc2lvbi50YW5nZW50LnksXG4gICAgICAgICAgICAgICAgY29udGFjdHMgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzLFxuICAgICAgICAgICAgICAgIGNvbnRhY3RzTGVuZ3RoID0gY29udGFjdHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNvbnRhY3RTaGFyZSA9IDEgLyBjb250YWN0c0xlbmd0aCxcbiAgICAgICAgICAgICAgICBpbnZlcnNlTWFzc1RvdGFsID0gYm9keUEuaW52ZXJzZU1hc3MgKyBib2R5Qi5pbnZlcnNlTWFzcyxcbiAgICAgICAgICAgICAgICBmcmljdGlvbiA9IHBhaXIuZnJpY3Rpb24gKiBwYWlyLmZyaWN0aW9uU3RhdGljICogZnJpY3Rpb25Ob3JtYWxNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgYm9keSB2ZWxvY2l0aWVzXG4gICAgICAgICAgICBib2R5QVZlbG9jaXR5LnggPSBib2R5QS5wb3NpdGlvbi54IC0gYm9keUEucG9zaXRpb25QcmV2Lng7XG4gICAgICAgICAgICBib2R5QVZlbG9jaXR5LnkgPSBib2R5QS5wb3NpdGlvbi55IC0gYm9keUEucG9zaXRpb25QcmV2Lnk7XG4gICAgICAgICAgICBib2R5QlZlbG9jaXR5LnggPSBib2R5Qi5wb3NpdGlvbi54IC0gYm9keUIucG9zaXRpb25QcmV2Lng7XG4gICAgICAgICAgICBib2R5QlZlbG9jaXR5LnkgPSBib2R5Qi5wb3NpdGlvbi55IC0gYm9keUIucG9zaXRpb25QcmV2Lnk7XG4gICAgICAgICAgICBib2R5QS5hbmd1bGFyVmVsb2NpdHkgPSBib2R5QS5hbmdsZSAtIGJvZHlBLmFuZ2xlUHJldjtcbiAgICAgICAgICAgIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSA9IGJvZHlCLmFuZ2xlIC0gYm9keUIuYW5nbGVQcmV2O1xuXG4gICAgICAgICAgICAvLyByZXNvbHZlIGVhY2ggY29udGFjdFxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbnRhY3RzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdCA9IGNvbnRhY3RzW2pdLFxuICAgICAgICAgICAgICAgICAgICBjb250YWN0VmVydGV4ID0gY29udGFjdC52ZXJ0ZXg7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0QVggPSBjb250YWN0VmVydGV4LnggLSBib2R5QS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRBWSA9IGNvbnRhY3RWZXJ0ZXgueSAtIGJvZHlBLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJYID0gY29udGFjdFZlcnRleC54IC0gYm9keUIucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QlkgPSBjb250YWN0VmVydGV4LnkgLSBib2R5Qi5wb3NpdGlvbi55O1xuIFxuICAgICAgICAgICAgICAgIHZhciB2ZWxvY2l0eVBvaW50QVggPSBib2R5QVZlbG9jaXR5LnggLSBvZmZzZXRBWSAqIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHlQb2ludEFZID0gYm9keUFWZWxvY2l0eS55ICsgb2Zmc2V0QVggKiBib2R5QS5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5UG9pbnRCWCA9IGJvZHlCVmVsb2NpdHkueCAtIG9mZnNldEJZICogYm9keUIuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eVBvaW50QlkgPSBib2R5QlZlbG9jaXR5LnkgKyBvZmZzZXRCWCAqIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eTtcblxuICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZVZlbG9jaXR5WCA9IHZlbG9jaXR5UG9pbnRBWCAtIHZlbG9jaXR5UG9pbnRCWCxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVWZWxvY2l0eVkgPSB2ZWxvY2l0eVBvaW50QVkgLSB2ZWxvY2l0eVBvaW50Qlk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsVmVsb2NpdHkgPSBub3JtYWxYICogcmVsYXRpdmVWZWxvY2l0eVggKyBub3JtYWxZICogcmVsYXRpdmVWZWxvY2l0eVksXG4gICAgICAgICAgICAgICAgICAgIHRhbmdlbnRWZWxvY2l0eSA9IHRhbmdlbnRYICogcmVsYXRpdmVWZWxvY2l0eVggKyB0YW5nZW50WSAqIHJlbGF0aXZlVmVsb2NpdHlZO1xuXG4gICAgICAgICAgICAgICAgLy8gY291bG9tYiBmcmljdGlvblxuICAgICAgICAgICAgICAgIHZhciBub3JtYWxPdmVybGFwID0gcGFpci5zZXBhcmF0aW9uICsgbm9ybWFsVmVsb2NpdHk7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEZvcmNlID0gTWF0aC5taW4obm9ybWFsT3ZlcmxhcCwgMSk7XG4gICAgICAgICAgICAgICAgbm9ybWFsRm9yY2UgPSBub3JtYWxPdmVybGFwIDwgMCA/IDAgOiBub3JtYWxGb3JjZTtcblxuICAgICAgICAgICAgICAgIHZhciBmcmljdGlvbkxpbWl0ID0gbm9ybWFsRm9yY2UgKiBmcmljdGlvbjtcblxuICAgICAgICAgICAgICAgIGlmICh0YW5nZW50VmVsb2NpdHkgPCAtZnJpY3Rpb25MaW1pdCB8fCB0YW5nZW50VmVsb2NpdHkgPiBmcmljdGlvbkxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEZyaWN0aW9uID0gKHRhbmdlbnRWZWxvY2l0eSA+IDAgPyB0YW5nZW50VmVsb2NpdHkgOiAtdGFuZ2VudFZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgdGFuZ2VudEltcHVsc2UgPSBwYWlyLmZyaWN0aW9uICogKHRhbmdlbnRWZWxvY2l0eSA+IDAgPyAxIDogLTEpICogdGltZVNjYWxlQ3ViZWQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodGFuZ2VudEltcHVsc2UgPCAtbWF4RnJpY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gLW1heEZyaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhbmdlbnRJbXB1bHNlID4gbWF4RnJpY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gbWF4RnJpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSA9IHRhbmdlbnRWZWxvY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgbWF4RnJpY3Rpb24gPSBmcmljdGlvbk1heFN0YXRpYztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhY2NvdW50IGZvciBtYXNzLCBpbmVydGlhIGFuZCBjb250YWN0IG9mZnNldFxuICAgICAgICAgICAgICAgIHZhciBvQWNOID0gb2Zmc2V0QVggKiBub3JtYWxZIC0gb2Zmc2V0QVkgKiBub3JtYWxYLFxuICAgICAgICAgICAgICAgICAgICBvQmNOID0gb2Zmc2V0QlggKiBub3JtYWxZIC0gb2Zmc2V0QlkgKiBub3JtYWxYLFxuICAgICAgICAgICAgICAgICAgICBzaGFyZSA9IGNvbnRhY3RTaGFyZSAvIChpbnZlcnNlTWFzc1RvdGFsICsgYm9keUEuaW52ZXJzZUluZXJ0aWEgKiBvQWNOICogb0FjTiArIGJvZHlCLmludmVyc2VJbmVydGlhICogb0JjTiAqIG9CY04pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmF3IGltcHVsc2VzXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbEltcHVsc2UgPSAoMSArIHBhaXIucmVzdGl0dXRpb24pICogbm9ybWFsVmVsb2NpdHkgKiBzaGFyZTtcbiAgICAgICAgICAgICAgICB0YW5nZW50SW1wdWxzZSAqPSBzaGFyZTtcblxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBoaWdoIHZlbG9jaXR5IGFuZCByZXN0aW5nIGNvbGxpc2lvbnMgc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxWZWxvY2l0eSA8IHJlc3RpbmdUaHJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlnaCBub3JtYWwgdmVsb2NpdHkgc28gY2xlYXIgY2FjaGVkIGNvbnRhY3Qgbm9ybWFsIGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzb2x2ZSByZXN0aW5nIGNvbGxpc2lvbiBjb25zdHJhaW50cyB1c2luZyBFcmluIENhdHRvJ3MgbWV0aG9kIChHREMwOClcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1wdWxzZSBjb25zdHJhaW50IHRlbmRzIHRvIDBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3ROb3JtYWxJbXB1bHNlID0gY29udGFjdC5ub3JtYWxJbXB1bHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm5vcm1hbEltcHVsc2UgKz0gbm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3Qubm9ybWFsSW1wdWxzZSA+IDApIGNvbnRhY3Qubm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbEltcHVsc2UgLSBjb250YWN0Tm9ybWFsSW1wdWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgaGlnaCB2ZWxvY2l0eSBhbmQgcmVzdGluZyBjb2xsaXNpb25zIHNlcGFyYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAodGFuZ2VudFZlbG9jaXR5IDwgLXJlc3RpbmdUaHJlc2hUYW5nZW50IHx8IHRhbmdlbnRWZWxvY2l0eSA+IHJlc3RpbmdUaHJlc2hUYW5nZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZ2ggdGFuZ2VudCB2ZWxvY2l0eSBzbyBjbGVhciBjYWNoZWQgY29udGFjdCB0YW5nZW50IGltcHVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdC50YW5nZW50SW1wdWxzZSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc29sdmUgcmVzdGluZyBjb2xsaXNpb24gY29uc3RyYWludHMgdXNpbmcgRXJpbiBDYXR0bydzIG1ldGhvZCAoR0RDMDgpXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhbmdlbnQgaW1wdWxzZSB0ZW5kcyB0byAtdGFuZ2VudFNwZWVkIG9yICt0YW5nZW50U3BlZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhY3RUYW5nZW50SW1wdWxzZSA9IGNvbnRhY3QudGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QudGFuZ2VudEltcHVsc2UgKz0gdGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0LnRhbmdlbnRJbXB1bHNlIDwgLW1heEZyaWN0aW9uKSBjb250YWN0LnRhbmdlbnRJbXB1bHNlID0gLW1heEZyaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC50YW5nZW50SW1wdWxzZSA+IG1heEZyaWN0aW9uKSBjb250YWN0LnRhbmdlbnRJbXB1bHNlID0gbWF4RnJpY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50SW1wdWxzZSAtIGNvbnRhY3RUYW5nZW50SW1wdWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0b3RhbCBpbXB1bHNlIGZyb20gY29udGFjdFxuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlWCA9IG5vcm1hbFggKiBub3JtYWxJbXB1bHNlICsgdGFuZ2VudFggKiB0YW5nZW50SW1wdWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW1wdWxzZVkgPSBub3JtYWxZICogbm9ybWFsSW1wdWxzZSArIHRhbmdlbnRZICogdGFuZ2VudEltcHVsc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgaW1wdWxzZSBmcm9tIGNvbnRhY3RcbiAgICAgICAgICAgICAgICBpZiAoIShib2R5QS5pc1N0YXRpYyB8fCBib2R5QS5pc1NsZWVwaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvblByZXYueCArPSBpbXB1bHNlWCAqIGJvZHlBLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICBib2R5QS5wb3NpdGlvblByZXYueSArPSBpbXB1bHNlWSAqIGJvZHlBLmludmVyc2VNYXNzO1xuICAgICAgICAgICAgICAgICAgICBib2R5QS5hbmdsZVByZXYgKz0gKG9mZnNldEFYICogaW1wdWxzZVkgLSBvZmZzZXRBWSAqIGltcHVsc2VYKSAqIGJvZHlBLmludmVyc2VJbmVydGlhO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKGJvZHlCLmlzU3RhdGljIHx8IGJvZHlCLmlzU2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi54IC09IGltcHVsc2VYICogYm9keUIuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uUHJldi55IC09IGltcHVsc2VZICogYm9keUIuaW52ZXJzZU1hc3M7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmFuZ2xlUHJldiAtPSAob2Zmc2V0QlggKiBpbXB1bHNlWSAtIG9mZnNldEJZICogaW1wdWxzZVgpICogYm9keUIuaW52ZXJzZUluZXJ0aWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5QYWlyc2AgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgY29sbGlzaW9uIHBhaXIgc2V0cy5cbipcbiogQGNsYXNzIFBhaXJzXG4qL1xuXG52YXIgUGFpcnMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWlycztcblxudmFyIFBhaXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcGFpcnMgc3RydWN0dXJlLlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtwYWlyc30gQSBuZXcgcGFpcnMgc3RydWN0dXJlXG4gICAgICovXG4gICAgUGFpcnMuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZCh7IFxuICAgICAgICAgICAgdGFibGU6IHt9LFxuICAgICAgICAgICAgbGlzdDogW10sXG4gICAgICAgICAgICBjb2xsaXNpb25TdGFydDogW10sXG4gICAgICAgICAgICBjb2xsaXNpb25BY3RpdmU6IFtdLFxuICAgICAgICAgICAgY29sbGlzaW9uRW5kOiBbXVxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBwYWlycyBnaXZlbiBhIGxpc3Qgb2YgY29sbGlzaW9ucy5cbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYWlyc1xuICAgICAqIEBwYXJhbSB7Y29sbGlzaW9uW119IGNvbGxpc2lvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAgICovXG4gICAgUGFpcnMudXBkYXRlID0gZnVuY3Rpb24ocGFpcnMsIGNvbGxpc2lvbnMsIHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgcGFpcnNMaXN0ID0gcGFpcnMubGlzdCxcbiAgICAgICAgICAgIHBhaXJzTGlzdExlbmd0aCA9IHBhaXJzTGlzdC5sZW5ndGgsXG4gICAgICAgICAgICBwYWlyc1RhYmxlID0gcGFpcnMudGFibGUsXG4gICAgICAgICAgICBjb2xsaXNpb25zTGVuZ3RoID0gY29sbGlzaW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBjb2xsaXNpb25TdGFydCA9IHBhaXJzLmNvbGxpc2lvblN0YXJ0LFxuICAgICAgICAgICAgY29sbGlzaW9uRW5kID0gcGFpcnMuY29sbGlzaW9uRW5kLFxuICAgICAgICAgICAgY29sbGlzaW9uQWN0aXZlID0gcGFpcnMuY29sbGlzaW9uQWN0aXZlLFxuICAgICAgICAgICAgY29sbGlzaW9uLFxuICAgICAgICAgICAgcGFpckluZGV4LFxuICAgICAgICAgICAgcGFpcixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gY2xlYXIgY29sbGlzaW9uIHN0YXRlIGFycmF5cywgYnV0IG1haW50YWluIG9sZCByZWZlcmVuY2VcbiAgICAgICAgY29sbGlzaW9uU3RhcnQubGVuZ3RoID0gMDtcbiAgICAgICAgY29sbGlzaW9uRW5kLmxlbmd0aCA9IDA7XG4gICAgICAgIGNvbGxpc2lvbkFjdGl2ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWlyc0xpc3RMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpcnNMaXN0W2ldLmNvbmZpcm1lZEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbGxpc2lvbnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29sbGlzaW9uID0gY29sbGlzaW9uc1tpXTtcbiAgICAgICAgICAgIHBhaXIgPSBjb2xsaXNpb24ucGFpcjtcblxuICAgICAgICAgICAgaWYgKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAvLyBwYWlyIGFscmVhZHkgZXhpc3RzIChidXQgbWF5IG9yIG1heSBub3QgYmUgYWN0aXZlKVxuICAgICAgICAgICAgICAgIGlmIChwYWlyLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhaXIgZXhpc3RzIGFuZCBpcyBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uQWN0aXZlLnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFpciBleGlzdHMgYnV0IHdhcyBpbmFjdGl2ZSwgc28gYSBjb2xsaXNpb24gaGFzIGp1c3Qgc3RhcnRlZCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICBjb2xsaXNpb25TdGFydC5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcGFpclxuICAgICAgICAgICAgICAgIFBhaXIudXBkYXRlKHBhaXIsIGNvbGxpc2lvbiwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICBwYWlyLmNvbmZpcm1lZEFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHBhaXIgZGlkIG5vdCBleGlzdCwgY3JlYXRlIGEgbmV3IHBhaXJcbiAgICAgICAgICAgICAgICBwYWlyID0gUGFpci5jcmVhdGUoY29sbGlzaW9uLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIHBhaXJzVGFibGVbcGFpci5pZF0gPSBwYWlyO1xuXG4gICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgbmV3IHBhaXJcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25TdGFydC5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgIHBhaXJzTGlzdC5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBwYWlycyB0aGF0IGFyZSBubyBsb25nZXIgYWN0aXZlXG4gICAgICAgIHZhciByZW1vdmVQYWlySW5kZXggPSBbXTtcbiAgICAgICAgcGFpcnNMaXN0TGVuZ3RoID0gcGFpcnNMaXN0Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFpcnNMaXN0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcGFpci5jb25maXJtZWRBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBQYWlyLnNldEFjdGl2ZShwYWlyLCBmYWxzZSwgdGltZXN0YW1wKTtcbiAgICAgICAgICAgICAgICBjb2xsaXNpb25FbmQucHVzaChwYWlyKTtcblxuICAgICAgICAgICAgICAgIGlmICghcGFpci5jb2xsaXNpb24uYm9keUEuaXNTbGVlcGluZyAmJiAhcGFpci5jb2xsaXNpb24uYm9keUIuaXNTbGVlcGluZykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVQYWlySW5kZXgucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgaW5hY3RpdmUgcGFpcnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbW92ZVBhaXJJbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFpckluZGV4ID0gcmVtb3ZlUGFpckluZGV4W2ldIC0gaTtcbiAgICAgICAgICAgIHBhaXIgPSBwYWlyc0xpc3RbcGFpckluZGV4XTtcbiAgICAgICAgICAgIHBhaXJzTGlzdC5zcGxpY2UocGFpckluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwYWlyc1RhYmxlW3BhaXIuaWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ2l2ZW4gcGFpcnMgc3RydWN0dXJlLlxuICAgICAqIEBtZXRob2QgY2xlYXJcbiAgICAgKiBAcGFyYW0ge3BhaXJzfSBwYWlyc1xuICAgICAqIEByZXR1cm4ge3BhaXJzfSBwYWlyc1xuICAgICAqL1xuICAgIFBhaXJzLmNsZWFyID0gZnVuY3Rpb24ocGFpcnMpIHtcbiAgICAgICAgcGFpcnMudGFibGUgPSB7fTtcbiAgICAgICAgcGFpcnMubGlzdC5sZW5ndGggPSAwO1xuICAgICAgICBwYWlycy5jb2xsaXNpb25TdGFydC5sZW5ndGggPSAwO1xuICAgICAgICBwYWlycy5jb2xsaXNpb25BY3RpdmUubGVuZ3RoID0gMDtcbiAgICAgICAgcGFpcnMuY29sbGlzaW9uRW5kLmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybiBwYWlycztcbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE1hdHRlciA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcblxyXG5NYXR0ZXIuQXhlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5NYXR0ZXIuQm9kaWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbk1hdHRlci5Cb2R5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuTWF0dGVyLkJvdW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbk1hdHRlci5Db2xsaXNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5NYXR0ZXIuQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuTWF0dGVyLkNvbXBvc2l0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbk1hdHRlci5Db21wb3NpdGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbk1hdHRlci5Db25zdHJhaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbk1hdHRlci5Db250YWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcbk1hdHRlci5EZXRlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5NYXR0ZXIuRW5naW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbk1hdHRlci5FdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5NYXR0ZXIuR3JpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG5NYXR0ZXIuTW91c2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuTWF0dGVyLk1vdXNlQ29uc3RyYWludCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5NYXR0ZXIuUGFpciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbk1hdHRlci5QYWlycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5NYXR0ZXIuUGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbk1hdHRlci5RdWVyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xyXG5NYXR0ZXIuUmVuZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcbk1hdHRlci5SZXNvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG5NYXR0ZXIuUnVubmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcbk1hdHRlci5TQVQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxuTWF0dGVyLlNsZWVwaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuTWF0dGVyLlN2ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xyXG5NYXR0ZXIuVmVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuTWF0dGVyLlZlcnRpY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuTWF0dGVyLldvcmxkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcblxyXG4vLyB0ZW1wb3JhcnkgYmFjayBjb21wYXRpYmlsaXR5XHJcbk1hdHRlci5FbmdpbmUucnVuID0gTWF0dGVyLlJ1bm5lci5ydW47XHJcbk1hdHRlci5Db21tb24uZGVwcmVjYXRlZChNYXR0ZXIuRW5naW5lLCAncnVuJywgJ0VuZ2luZS5ydW4g4p6kIHVzZSBNYXR0ZXIuUnVubmVyLnJ1bihlbmdpbmUpIGluc3RlYWQnKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXHJcbiogVGhlIGBNYXR0ZXJgIG1vZHVsZSBpcyB0aGUgdG9wIGxldmVsIG5hbWVzcGFjZS4gSXQgYWxzbyBpbmNsdWRlcyBhIGZ1bmN0aW9uIGZvciBpbnN0YWxsaW5nIHBsdWdpbnMgb24gdG9wIG9mIHRoZSBsaWJyYXJ5LlxyXG4qXHJcbiogQGNsYXNzIE1hdHRlclxyXG4qL1xyXG5cclxudmFyIE1hdHRlciA9IHt9O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNYXR0ZXI7XHJcblxyXG52YXIgUGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpYnJhcnkgbmFtZS5cclxuICAgICAqIEBwcm9wZXJ0eSBuYW1lXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIE1hdHRlci5uYW1lID0gJ21hdHRlci1qcyc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGlicmFyeSB2ZXJzaW9uLlxyXG4gICAgICogQHByb3BlcnR5IHZlcnNpb25cclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgTWF0dGVyLnZlcnNpb24gPSAgdHJ1ZSA/IFwiMC4xOS4wXCIgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGxpc3Qgb2YgcGx1Z2luIGRlcGVuZGVuY2llcyB0byBiZSBpbnN0YWxsZWQuIFRoZXNlIGFyZSBub3JtYWxseSBzZXQgYW5kIGluc3RhbGxlZCB0aHJvdWdoIGBNYXR0ZXIudXNlYC5cclxuICAgICAqIEFsdGVybmF0aXZlbHkgeW91IG1heSBzZXQgYE1hdHRlci51c2VzYCBtYW51YWxseSBhbmQgaW5zdGFsbCB0aGVtIGJ5IGNhbGxpbmcgYFBsdWdpbi51c2UoTWF0dGVyKWAuXHJcbiAgICAgKiBAcHJvcGVydHkgdXNlc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIudXNlcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBsdWdpbnMgdGhhdCBoYXZlIGJlZW4gaW5zdGFsbGVkIHRocm91Z2ggYE1hdHRlci5QbHVnaW4uaW5zdGFsbGAuIFJlYWQgb25seS5cclxuICAgICAqIEBwcm9wZXJ0eSB1c2VkXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgTWF0dGVyLnVzZWQgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluc3RhbGxzIHRoZSBnaXZlbiBwbHVnaW5zIG9uIHRoZSBgTWF0dGVyYCBuYW1lc3BhY2UuXHJcbiAgICAgKiBUaGlzIGlzIGEgc2hvcnQtaGFuZCBmb3IgYFBsdWdpbi51c2VgLCBzZWUgaXQgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBDYWxsIHRoaXMgZnVuY3Rpb24gb25jZSBhdCB0aGUgc3RhcnQgb2YgeW91ciBjb2RlLCB3aXRoIGFsbCBvZiB0aGUgcGx1Z2lucyB5b3Ugd2lzaCB0byBpbnN0YWxsIGFzIGFyZ3VtZW50cy5cclxuICAgICAqIEF2b2lkIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyB1bmxlc3MgeW91IGludGVuZCB0byBtYW51YWxseSBjb250cm9sIGluc3RhbGxhdGlvbiBvcmRlci5cclxuICAgICAqIEBtZXRob2QgdXNlXHJcbiAgICAgKiBAcGFyYW0gLi4ucGx1Z2luIHtGdW5jdGlvbn0gVGhlIHBsdWdpbihzKSB0byBpbnN0YWxsIG9uIGBiYXNlYCAobXVsdGktYXJndW1lbnQpLlxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIudXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgUGx1Z2luLnVzZShNYXR0ZXIsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYWlucyBhIGZ1bmN0aW9uIHRvIGV4Y3V0ZSBiZWZvcmUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYE1hdHRlcmAuXHJcbiAgICAgKiBTZWUgYWxzbyBkb2NzIGZvciBgQ29tbW9uLmNoYWluYC5cclxuICAgICAqIEBtZXRob2QgYmVmb3JlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCByZWxhdGl2ZSB0byBgTWF0dGVyYFxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hhaW4gYmVmb3JlIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBjaGFpbmVkIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZWQgdGhlIG9yaWdpbmFsXHJcbiAgICAgKi9cclxuICAgIE1hdHRlci5iZWZvcmUgPSBmdW5jdGlvbihwYXRoLCBmdW5jKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXk1hdHRlci4vLCAnJyk7XHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5jaGFpblBhdGhCZWZvcmUoTWF0dGVyLCBwYXRoLCBmdW5jKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFpbnMgYSBmdW5jdGlvbiB0byBleGN1dGUgYWZ0ZXIgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9uIHRoZSBnaXZlbiBgcGF0aGAgcmVsYXRpdmUgdG8gYE1hdHRlcmAuXHJcbiAgICAgKiBTZWUgYWxzbyBkb2NzIGZvciBgQ29tbW9uLmNoYWluYC5cclxuICAgICAqIEBtZXRob2QgYWZ0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHJlbGF0aXZlIHRvIGBNYXR0ZXJgXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGFpbiBhZnRlciB0aGUgb3JpZ2luYWxcclxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgY2hhaW5lZCBmdW5jdGlvbiB0aGF0IHJlcGxhY2VkIHRoZSBvcmlnaW5hbFxyXG4gICAgICovXHJcbiAgICBNYXR0ZXIuYWZ0ZXIgPSBmdW5jdGlvbihwYXRoLCBmdW5jKSB7XHJcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXk1hdHRlci4vLCAnJyk7XHJcbiAgICAgICAgcmV0dXJuIENvbW1vbi5jaGFpblBhdGhBZnRlcihNYXR0ZXIsIHBhdGgsIGZ1bmMpO1xyXG4gICAgfTtcclxuXHJcbn0pKCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5Db21wb3NpdGVzYCBtb2R1bGUgY29udGFpbnMgZmFjdG9yeSBtZXRob2RzIGZvciBjcmVhdGluZyBjb21wb3NpdGUgYm9kaWVzXG4qIHdpdGggY29tbW9ubHkgdXNlZCBjb25maWd1cmF0aW9ucyAoc3VjaCBhcyBzdGFja3MgYW5kIGNoYWlucykuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBDb21wb3NpdGVzXG4qL1xuXG52YXIgQ29tcG9zaXRlcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0ZXM7XG5cbnZhciBDb21wb3NpdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIENvbnN0cmFpbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIEJvZHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIEJvZGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIGRlcHJlY2F0ZWQgPSBDb21tb24uZGVwcmVjYXRlZDtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIGJvZGllcyBjcmVhdGVkIGluIHRoZSBjYWxsYmFjayBpbiBhIGdyaWQgYXJyYW5nZW1lbnQuXG4gICAgICogVGhpcyBmdW5jdGlvbiB1c2VzIHRoZSBib2R5J3MgYm91bmRzIHRvIHByZXZlbnQgb3ZlcmxhcHMuXG4gICAgICogQG1ldGhvZCBzdGFja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uR2FwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0dhcFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgY29udGFpbmluZyBvYmplY3RzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgQ29tcG9zaXRlcy5zdGFjayA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdGFjayA9IENvbXBvc2l0ZS5jcmVhdGUoeyBsYWJlbDogJ1N0YWNrJyB9KSxcbiAgICAgICAgICAgIHggPSB4eCxcbiAgICAgICAgICAgIHkgPSB5eSxcbiAgICAgICAgICAgIGxhc3RCb2R5LFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcm93czsgcm93KyspIHtcbiAgICAgICAgICAgIHZhciBtYXhIZWlnaHQgPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gPSAwOyBjb2x1bW4gPCBjb2x1bW5zOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gY2FsbGJhY2soeCwgeSwgY29sdW1uLCByb3csIGxhc3RCb2R5LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlIZWlnaHQgPSBib2R5LmJvdW5kcy5tYXgueSAtIGJvZHkuYm91bmRzLm1pbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keVdpZHRoID0gYm9keS5ib3VuZHMubWF4LnggLSBib2R5LmJvdW5kcy5taW4ueDsgXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlIZWlnaHQgPiBtYXhIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBib2R5SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgQm9keS50cmFuc2xhdGUoYm9keSwgeyB4OiBib2R5V2lkdGggKiAwLjUsIHk6IGJvZHlIZWlnaHQgKiAwLjUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgeCA9IGJvZHkuYm91bmRzLm1heC54ICsgY29sdW1uR2FwO1xuXG4gICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KHN0YWNrLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxhc3RCb2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gY29sdW1uR2FwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgeSArPSBtYXhIZWlnaHQgKyByb3dHYXA7XG4gICAgICAgICAgICB4ID0geHg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDaGFpbnMgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gY29tcG9zaXRlIHRvZ2V0aGVyIHVzaW5nIGNvbnN0cmFpbnRzLlxuICAgICAqIEBtZXRob2QgY2hhaW5cbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhPZmZzZXRBXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXRBXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhPZmZzZXRCXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlPZmZzZXRCXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBjb250YWluaW5nIG9iamVjdHMgY2hhaW5lZCB0b2dldGhlciB3aXRoIGNvbnN0cmFpbnRzXG4gICAgICovXG4gICAgQ29tcG9zaXRlcy5jaGFpbiA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgeE9mZnNldEEsIHlPZmZzZXRBLCB4T2Zmc2V0QiwgeU9mZnNldEIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGJvZGllcyA9IGNvbXBvc2l0ZS5ib2RpZXM7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHlBID0gYm9kaWVzW2kgLSAxXSxcbiAgICAgICAgICAgICAgICBib2R5QiA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBib2R5QUhlaWdodCA9IGJvZHlBLmJvdW5kcy5tYXgueSAtIGJvZHlBLmJvdW5kcy5taW4ueSxcbiAgICAgICAgICAgICAgICBib2R5QVdpZHRoID0gYm9keUEuYm91bmRzLm1heC54IC0gYm9keUEuYm91bmRzLm1pbi54LCBcbiAgICAgICAgICAgICAgICBib2R5QkhlaWdodCA9IGJvZHlCLmJvdW5kcy5tYXgueSAtIGJvZHlCLmJvdW5kcy5taW4ueSxcbiAgICAgICAgICAgICAgICBib2R5QldpZHRoID0gYm9keUIuYm91bmRzLm1heC54IC0gYm9keUIuYm91bmRzLm1pbi54O1xuICAgICAgICBcbiAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICBib2R5QTogYm9keUEsXG4gICAgICAgICAgICAgICAgcG9pbnRBOiB7IHg6IGJvZHlBV2lkdGggKiB4T2Zmc2V0QSwgeTogYm9keUFIZWlnaHQgKiB5T2Zmc2V0QSB9LFxuICAgICAgICAgICAgICAgIGJvZHlCOiBib2R5QixcbiAgICAgICAgICAgICAgICBwb2ludEI6IHsgeDogYm9keUJXaWR0aCAqIHhPZmZzZXRCLCB5OiBib2R5QkhlaWdodCAqIHlPZmZzZXRCIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIFxuICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShjb25zdHJhaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb3NpdGUubGFiZWwgKz0gJyBDaGFpbic7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBib2RpZXMgaW4gdGhlIGNvbXBvc2l0ZSB3aXRoIGNvbnN0cmFpbnRzIGluIGEgZ3JpZCBwYXR0ZXJuLCB3aXRoIG9wdGlvbmFsIGNyb3NzIGJyYWNlcy5cbiAgICAgKiBAbWV0aG9kIG1lc2hcbiAgICAgKiBAcGFyYW0ge2NvbXBvc2l0ZX0gY29tcG9zaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3Jvc3NCcmFjZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBUaGUgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBtZXNoZWQgdG9nZXRoZXIgd2l0aCBjb25zdHJhaW50c1xuICAgICAqL1xuICAgIENvbXBvc2l0ZXMubWVzaCA9IGZ1bmN0aW9uKGNvbXBvc2l0ZSwgY29sdW1ucywgcm93cywgY3Jvc3NCcmFjZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYm9kaWVzID0gY29tcG9zaXRlLmJvZGllcyxcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgIGJvZHlBLFxuICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICBib2R5QztcbiAgICAgICAgXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93czsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAoY29sID0gMTsgY29sIDwgY29sdW1uczsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBib2R5QSA9IGJvZGllc1soY29sIC0gMSkgKyAocm93ICogY29sdW1ucyldO1xuICAgICAgICAgICAgICAgIGJvZHlCID0gYm9kaWVzW2NvbCArIChyb3cgKiBjb2x1bW5zKV07XG4gICAgICAgICAgICAgICAgQ29tcG9zaXRlLmFkZENvbnN0cmFpbnQoY29tcG9zaXRlLCBDb25zdHJhaW50LmNyZWF0ZShDb21tb24uZXh0ZW5kKHsgYm9keUE6IGJvZHlBLCBib2R5QjogYm9keUIgfSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJvdyA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IGNvbHVtbnM7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlBID0gYm9kaWVzW2NvbCArICgocm93IC0gMSkgKiBjb2x1bW5zKV07XG4gICAgICAgICAgICAgICAgICAgIGJvZHlCID0gYm9kaWVzW2NvbCArIChyb3cgKiBjb2x1bW5zKV07XG4gICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QSwgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyb3NzQnJhY2UgJiYgY29sID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUMgPSBib2RpZXNbKGNvbCAtIDEpICsgKChyb3cgLSAxKSAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QywgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3Jvc3NCcmFjZSAmJiBjb2wgPCBjb2x1bW5zIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUMgPSBib2RpZXNbKGNvbCArIDEpICsgKChyb3cgLSAxKSAqIGNvbHVtbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNvbXBvc2l0ZSwgQ29uc3RyYWludC5jcmVhdGUoQ29tbW9uLmV4dGVuZCh7IGJvZHlBOiBib2R5QywgYm9keUI6IGJvZHlCIH0sIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb3NpdGUubGFiZWwgKz0gJyBNZXNoJztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb21wb3NpdGU7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgYm9kaWVzIGNyZWF0ZWQgaW4gdGhlIGNhbGxiYWNrIGluIGEgcHlyYW1pZCBhcnJhbmdlbWVudC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGJvZHkncyBib3VuZHMgdG8gcHJldmVudCBvdmVybGFwcy5cbiAgICAgKiBAbWV0aG9kIHB5cmFtaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkdhcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dHYXBcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge2NvbXBvc2l0ZX0gQSBuZXcgY29tcG9zaXRlIGNvbnRhaW5pbmcgb2JqZWN0cyBjcmVhdGVkIGluIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIENvbXBvc2l0ZXMucHlyYW1pZCA9IGZ1bmN0aW9uKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBDb21wb3NpdGVzLnN0YWNrKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGZ1bmN0aW9uKHgsIHksIGNvbHVtbiwgcm93LCBsYXN0Qm9keSwgaSkge1xuICAgICAgICAgICAgdmFyIGFjdHVhbFJvd3MgPSBNYXRoLm1pbihyb3dzLCBNYXRoLmNlaWwoY29sdW1ucyAvIDIpKSxcbiAgICAgICAgICAgICAgICBsYXN0Qm9keVdpZHRoID0gbGFzdEJvZHkgPyBsYXN0Qm9keS5ib3VuZHMubWF4LnggLSBsYXN0Qm9keS5ib3VuZHMubWluLnggOiAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocm93ID4gYWN0dWFsUm93cylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHJldmVyc2Ugcm93IG9yZGVyXG4gICAgICAgICAgICByb3cgPSBhY3R1YWxSb3dzIC0gcm93O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSByb3csXG4gICAgICAgICAgICAgICAgZW5kID0gY29sdW1ucyAtIDEgLSByb3c7XG5cbiAgICAgICAgICAgIGlmIChjb2x1bW4gPCBzdGFydCB8fCBjb2x1bW4gPiBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyByZXRyb2FjdGl2ZWx5IGZpeCB0aGUgZmlyc3QgYm9keSdzIHBvc2l0aW9uLCBzaW5jZSB3aWR0aCB3YXMgdW5rbm93blxuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBCb2R5LnRyYW5zbGF0ZShsYXN0Qm9keSwgeyB4OiAoY29sdW1uICsgKGNvbHVtbnMgJSAyID09PSAxID8gMSA6IC0xKSkgKiBsYXN0Qm9keVdpZHRoLCB5OiAwIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeE9mZnNldCA9IGxhc3RCb2R5ID8gY29sdW1uICogbGFzdEJvZHlXaWR0aCA6IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh4eCArIHhPZmZzZXQgKyBjb2x1bW4gKiBjb2x1bW5HYXAsIHksIGNvbHVtbiwgcm93LCBsYXN0Qm9keSwgaSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhhcyBub3cgbW92ZWQgdG8gdGhlIFtuZXd0b25zQ3JhZGxlIGV4YW1wbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL25ld3RvbnNDcmFkbGUuanMpLCBmb2xsb3cgdGhhdCBpbnN0ZWFkIGFzIHRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCBoZXJlLlxuICAgICAqIEBkZXByZWNhdGVkIG1vdmVkIHRvIG5ld3RvbnNDcmFkbGUgZXhhbXBsZVxuICAgICAqIEBtZXRob2QgbmV3dG9uc0NyYWRsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiBAcmV0dXJuIHtjb21wb3NpdGV9IEEgbmV3IGNvbXBvc2l0ZSBuZXd0b25zQ3JhZGxlIGJvZHlcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLm5ld3RvbnNDcmFkbGUgPSBmdW5jdGlvbih4eCwgeXksIG51bWJlciwgc2l6ZSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXd0b25zQ3JhZGxlID0gQ29tcG9zaXRlLmNyZWF0ZSh7IGxhYmVsOiAnTmV3dG9ucyBDcmFkbGUnIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0aW9uID0gMS45LFxuICAgICAgICAgICAgICAgIGNpcmNsZSA9IEJvZGllcy5jaXJjbGUoeHggKyBpICogKHNpemUgKiBzZXBhcmF0aW9uKSwgeXkgKyBsZW5ndGgsIHNpemUsIFxuICAgICAgICAgICAgICAgICAgICB7IGluZXJ0aWE6IEluZmluaXR5LCByZXN0aXR1dGlvbjogMSwgZnJpY3Rpb246IDAsIGZyaWN0aW9uQWlyOiAwLjAwMDEsIHNsb3A6IDEgfSksXG4gICAgICAgICAgICAgICAgY29uc3RyYWludCA9IENvbnN0cmFpbnQuY3JlYXRlKHsgcG9pbnRBOiB7IHg6IHh4ICsgaSAqIChzaXplICogc2VwYXJhdGlvbiksIHk6IHl5IH0sIGJvZHlCOiBjaXJjbGUgfSk7XG5cbiAgICAgICAgICAgIENvbXBvc2l0ZS5hZGRCb2R5KG5ld3RvbnNDcmFkbGUsIGNpcmNsZSk7XG4gICAgICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChuZXd0b25zQ3JhZGxlLCBjb25zdHJhaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXd0b25zQ3JhZGxlO1xuICAgIH07XG5cbiAgICBkZXByZWNhdGVkKENvbXBvc2l0ZXMsICduZXd0b25zQ3JhZGxlJywgJ0NvbXBvc2l0ZXMubmV3dG9uc0NyYWRsZSDinqQgbW92ZWQgdG8gbmV3dG9uc0NyYWRsZSBleGFtcGxlJyk7XG4gICAgXG4gICAgLyoqXG4gICAgICogVGhpcyBoYXMgbm93IG1vdmVkIHRvIHRoZSBbY2FyIGV4YW1wbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2Nhci5qcyksIGZvbGxvdyB0aGF0IGluc3RlYWQgYXMgdGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIGhlcmUuXG4gICAgICogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gY2FyIGV4YW1wbGVcbiAgICAgKiBAbWV0aG9kIGNhclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2hlZWxTaXplXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgY2FyIGJvZHlcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLmNhciA9IGZ1bmN0aW9uKHh4LCB5eSwgd2lkdGgsIGhlaWdodCwgd2hlZWxTaXplKSB7XG4gICAgICAgIHZhciBncm91cCA9IEJvZHkubmV4dEdyb3VwKHRydWUpLFxuICAgICAgICAgICAgd2hlZWxCYXNlID0gMjAsXG4gICAgICAgICAgICB3aGVlbEFPZmZzZXQgPSAtd2lkdGggKiAwLjUgKyB3aGVlbEJhc2UsXG4gICAgICAgICAgICB3aGVlbEJPZmZzZXQgPSB3aWR0aCAqIDAuNSAtIHdoZWVsQmFzZSxcbiAgICAgICAgICAgIHdoZWVsWU9mZnNldCA9IDA7XG4gICAgXG4gICAgICAgIHZhciBjYXIgPSBDb21wb3NpdGUuY3JlYXRlKHsgbGFiZWw6ICdDYXInIH0pLFxuICAgICAgICAgICAgYm9keSA9IEJvZGllcy5yZWN0YW5nbGUoeHgsIHl5LCB3aWR0aCwgaGVpZ2h0LCB7IFxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogZ3JvdXBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoYW1mZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBoZWlnaHQgKiAwLjVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbnNpdHk6IDAuMDAwMlxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIHZhciB3aGVlbEEgPSBCb2RpZXMuY2lyY2xlKHh4ICsgd2hlZWxBT2Zmc2V0LCB5eSArIHdoZWVsWU9mZnNldCwgd2hlZWxTaXplLCB7IFxuICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJpY3Rpb246IDAuOFxuICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciB3aGVlbEIgPSBCb2RpZXMuY2lyY2xlKHh4ICsgd2hlZWxCT2Zmc2V0LCB5eSArIHdoZWVsWU9mZnNldCwgd2hlZWxTaXplLCB7IFxuICAgICAgICAgICAgY29sbGlzaW9uRmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJpY3Rpb246IDAuOFxuICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBheGVsQSA9IENvbnN0cmFpbnQuY3JlYXRlKHtcbiAgICAgICAgICAgIGJvZHlCOiBib2R5LFxuICAgICAgICAgICAgcG9pbnRCOiB7IHg6IHdoZWVsQU9mZnNldCwgeTogd2hlZWxZT2Zmc2V0IH0sXG4gICAgICAgICAgICBib2R5QTogd2hlZWxBLFxuICAgICAgICAgICAgc3RpZmZuZXNzOiAxLFxuICAgICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBheGVsQiA9IENvbnN0cmFpbnQuY3JlYXRlKHtcbiAgICAgICAgICAgIGJvZHlCOiBib2R5LFxuICAgICAgICAgICAgcG9pbnRCOiB7IHg6IHdoZWVsQk9mZnNldCwgeTogd2hlZWxZT2Zmc2V0IH0sXG4gICAgICAgICAgICBib2R5QTogd2hlZWxCLFxuICAgICAgICAgICAgc3RpZmZuZXNzOiAxLFxuICAgICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCBib2R5KTtcbiAgICAgICAgQ29tcG9zaXRlLmFkZEJvZHkoY2FyLCB3aGVlbEEpO1xuICAgICAgICBDb21wb3NpdGUuYWRkQm9keShjYXIsIHdoZWVsQik7XG4gICAgICAgIENvbXBvc2l0ZS5hZGRDb25zdHJhaW50KGNhciwgYXhlbEEpO1xuICAgICAgICBDb21wb3NpdGUuYWRkQ29uc3RyYWludChjYXIsIGF4ZWxCKTtcblxuICAgICAgICByZXR1cm4gY2FyO1xuICAgIH07XG5cbiAgICBkZXByZWNhdGVkKENvbXBvc2l0ZXMsICdjYXInLCAnQ29tcG9zaXRlcy5jYXIg4p6kIG1vdmVkIHRvIGNhciBleGFtcGxlJyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhhcyBub3cgbW92ZWQgdG8gdGhlIFtzb2Z0Qm9keSBleGFtcGxlXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy9ibG9iL21hc3Rlci9leGFtcGxlcy9zb2Z0Qm9keS5qcylcbiAgICAgKiBhbmQgdGhlIFtjbG90aCBleGFtcGxlXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy9ibG9iL21hc3Rlci9leGFtcGxlcy9jbG90aC5qcyksIGZvbGxvdyB0aG9zZSBpbnN0ZWFkIGFzIHRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCBoZXJlLlxuICAgICAqIEBkZXByZWNhdGVkIG1vdmVkIHRvIHNvZnRCb2R5IGFuZCBjbG90aCBleGFtcGxlc1xuICAgICAqIEBtZXRob2Qgc29mdEJvZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkdhcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dHYXBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyb3NzQnJhY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFydGljbGVSYWRpdXNcbiAgICAgKiBAcGFyYW0ge30gcGFydGljbGVPcHRpb25zXG4gICAgICogQHBhcmFtIHt9IGNvbnN0cmFpbnRPcHRpb25zXG4gICAgICogQHJldHVybiB7Y29tcG9zaXRlfSBBIG5ldyBjb21wb3NpdGUgc29mdEJvZHlcbiAgICAgKi9cbiAgICBDb21wb3NpdGVzLnNvZnRCb2R5ID0gZnVuY3Rpb24oeHgsIHl5LCBjb2x1bW5zLCByb3dzLCBjb2x1bW5HYXAsIHJvd0dhcCwgY3Jvc3NCcmFjZSwgcGFydGljbGVSYWRpdXMsIHBhcnRpY2xlT3B0aW9ucywgY29uc3RyYWludE9wdGlvbnMpIHtcbiAgICAgICAgcGFydGljbGVPcHRpb25zID0gQ29tbW9uLmV4dGVuZCh7IGluZXJ0aWE6IEluZmluaXR5IH0sIHBhcnRpY2xlT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0cmFpbnRPcHRpb25zID0gQ29tbW9uLmV4dGVuZCh7IHN0aWZmbmVzczogMC4yLCByZW5kZXI6IHsgdHlwZTogJ2xpbmUnLCBhbmNob3JzOiBmYWxzZSB9IH0sIGNvbnN0cmFpbnRPcHRpb25zKTtcblxuICAgICAgICB2YXIgc29mdEJvZHkgPSBDb21wb3NpdGVzLnN0YWNrKHh4LCB5eSwgY29sdW1ucywgcm93cywgY29sdW1uR2FwLCByb3dHYXAsIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBCb2RpZXMuY2lyY2xlKHgsIHksIHBhcnRpY2xlUmFkaXVzLCBwYXJ0aWNsZU9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBDb21wb3NpdGVzLm1lc2goc29mdEJvZHksIGNvbHVtbnMsIHJvd3MsIGNyb3NzQnJhY2UsIGNvbnN0cmFpbnRPcHRpb25zKTtcblxuICAgICAgICBzb2Z0Qm9keS5sYWJlbCA9ICdTb2Z0IEJvZHknO1xuXG4gICAgICAgIHJldHVybiBzb2Z0Qm9keTtcbiAgICB9O1xuXG4gICAgZGVwcmVjYXRlZChDb21wb3NpdGVzLCAnc29mdEJvZHknLCAnQ29tcG9zaXRlcy5zb2Z0Qm9keSDinqQgbW92ZWQgdG8gc29mdEJvZHkgYW5kIGNsb3RoIGV4YW1wbGVzJyk7XG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoaXMgbW9kdWxlIGhhcyBub3cgYmVlbiByZXBsYWNlZCBieSBgTWF0dGVyLkRldGVjdG9yYC5cbipcbiogQWxsIHVzYWdlIHNob3VsZCBiZSBtaWdyYXRlZCB0byBgTWF0dGVyLkRldGVjdG9yYCBvciBhbm90aGVyIGFsdGVybmF0aXZlLlxuKiBGb3IgYmFjay1jb21wYXRpYmlsaXR5IHB1cnBvc2VzIHRoaXMgbW9kdWxlIHdpbGwgcmVtYWluIGZvciBhIHNob3J0IHRlcm0gYW5kIHRoZW4gbGF0ZXIgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuKlxuKiBUaGUgYE1hdHRlci5HcmlkYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBjb2xsaXNpb24gYnJvYWRwaGFzZSBncmlkIHN0cnVjdHVyZXMuXG4qXG4qIEBjbGFzcyBHcmlkXG4qIEBkZXByZWNhdGVkXG4qL1xuXG52YXIgR3JpZCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWQ7XG5cbnZhciBQYWlyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGRlcHJlY2F0ZWQgPSBDb21tb24uZGVwcmVjYXRlZDtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBncmlkLlxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IE1hdHRlci5EZXRlY3RvclxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHt9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtncmlkfSBBIG5ldyBncmlkXG4gICAgICovXG4gICAgR3JpZC5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGJ1Y2tldHM6IHt9LFxuICAgICAgICAgICAgcGFpcnM6IHt9LFxuICAgICAgICAgICAgcGFpcnNMaXN0OiBbXSxcbiAgICAgICAgICAgIGJ1Y2tldFdpZHRoOiA0OCxcbiAgICAgICAgICAgIGJ1Y2tldEhlaWdodDogNDhcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBhIHNpbmdsZSBncmlkIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBidWNrZXRXaWR0aFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDQ4XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIGEgc2luZ2xlIGdyaWQgYnVja2V0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGJ1Y2tldEhlaWdodFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDQ4XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBncmlkLlxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IE1hdHRlci5EZXRlY3RvclxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlVXBkYXRlXG4gICAgICovXG4gICAgR3JpZC51cGRhdGUgPSBmdW5jdGlvbihncmlkLCBib2RpZXMsIGVuZ2luZSwgZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgdmFyIGksIGNvbCwgcm93LFxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICBidWNrZXRzID0gZ3JpZC5idWNrZXRzLFxuICAgICAgICAgICAgYnVja2V0LFxuICAgICAgICAgICAgYnVja2V0SWQsXG4gICAgICAgICAgICBncmlkQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoYm9keS5pc1NsZWVwaW5nICYmICFmb3JjZVVwZGF0ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IGJhY2sgY29tcGF0aWJpbGl0eSBib3VuZHMgY2hlY2tcbiAgICAgICAgICAgIGlmICh3b3JsZC5ib3VuZHMgJiYgKGJvZHkuYm91bmRzLm1heC54IDwgd29ybGQuYm91bmRzLm1pbi54IHx8IGJvZHkuYm91bmRzLm1pbi54ID4gd29ybGQuYm91bmRzLm1heC54XG4gICAgICAgICAgICAgICAgfHwgYm9keS5ib3VuZHMubWF4LnkgPCB3b3JsZC5ib3VuZHMubWluLnkgfHwgYm9keS5ib3VuZHMubWluLnkgPiB3b3JsZC5ib3VuZHMubWF4LnkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgbmV3UmVnaW9uID0gR3JpZC5fZ2V0UmVnaW9uKGdyaWQsIGJvZHkpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgYm9keSBoYXMgY2hhbmdlZCBncmlkIHJlZ2lvblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlZ2lvbiB8fCBuZXdSZWdpb24uaWQgIT09IGJvZHkucmVnaW9uLmlkIHx8IGZvcmNlVXBkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJvZHkucmVnaW9uIHx8IGZvcmNlVXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBib2R5LnJlZ2lvbiA9IG5ld1JlZ2lvbjtcblxuICAgICAgICAgICAgICAgIHZhciB1bmlvbiA9IEdyaWQuX3JlZ2lvblVuaW9uKG5ld1JlZ2lvbiwgYm9keS5yZWdpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGdyaWQgYnVja2V0cyBhZmZlY3RlZCBieSByZWdpb24gY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSB1bmlvbiBvZiBib3RoIHJlZ2lvbnNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbCA9IHVuaW9uLnN0YXJ0Q29sOyBjb2wgPD0gdW5pb24uZW5kQ29sOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHJvdyA9IHVuaW9uLnN0YXJ0Um93OyByb3cgPD0gdW5pb24uZW5kUm93OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0SWQgPSBHcmlkLl9nZXRCdWNrZXRJZChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSBidWNrZXRzW2J1Y2tldElkXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzSW5zaWRlTmV3UmVnaW9uID0gKGNvbCA+PSBuZXdSZWdpb24uc3RhcnRDb2wgJiYgY29sIDw9IG5ld1JlZ2lvbi5lbmRDb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJvdyA+PSBuZXdSZWdpb24uc3RhcnRSb3cgJiYgcm93IDw9IG5ld1JlZ2lvbi5lbmRSb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJbnNpZGVPbGRSZWdpb24gPSAoY29sID49IGJvZHkucmVnaW9uLnN0YXJ0Q29sICYmIGNvbCA8PSBib2R5LnJlZ2lvbi5lbmRDb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJvdyA+PSBib2R5LnJlZ2lvbi5zdGFydFJvdyAmJiByb3cgPD0gYm9keS5yZWdpb24uZW5kUm93KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gb2xkIHJlZ2lvbiBidWNrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW5zaWRlTmV3UmVnaW9uICYmIGlzSW5zaWRlT2xkUmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5zaWRlT2xkUmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWNrZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmlkLl9idWNrZXRSZW1vdmVCb2R5KGdyaWQsIGJ1Y2tldCwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gbmV3IHJlZ2lvbiBidWNrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5yZWdpb24gPT09IG5ld1JlZ2lvbiB8fCAoaXNJbnNpZGVOZXdSZWdpb24gJiYgIWlzSW5zaWRlT2xkUmVnaW9uKSB8fCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnVja2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSBHcmlkLl9jcmVhdGVCdWNrZXQoYnVja2V0cywgYnVja2V0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdyaWQuX2J1Y2tldEFkZEJvZHkoZ3JpZCwgYnVja2V0LCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbmV3IHJlZ2lvblxuICAgICAgICAgICAgICAgIGJvZHkucmVnaW9uID0gbmV3UmVnaW9uO1xuXG4gICAgICAgICAgICAgICAgLy8gZmxhZyBjaGFuZ2VzIHNvIHdlIGNhbiB1cGRhdGUgcGFpcnNcbiAgICAgICAgICAgICAgICBncmlkQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgcGFpcnMgbGlzdCBvbmx5IGlmIHBhaXJzIGNoYW5nZWQgKGkuZS4gYSBib2R5IGNoYW5nZWQgcmVnaW9uKVxuICAgICAgICBpZiAoZ3JpZENoYW5nZWQpXG4gICAgICAgICAgICBncmlkLnBhaXJzTGlzdCA9IEdyaWQuX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdChncmlkKTtcbiAgICB9O1xuXG4gICAgZGVwcmVjYXRlZChHcmlkLCAndXBkYXRlJywgJ0dyaWQudXBkYXRlIOKepCByZXBsYWNlZCBieSBNYXR0ZXIuRGV0ZWN0b3InKTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JpZC5cbiAgICAgKiBAZGVwcmVjYXRlZCByZXBsYWNlZCBieSBNYXR0ZXIuRGV0ZWN0b3JcbiAgICAgKiBAbWV0aG9kIGNsZWFyXG4gICAgICogQHBhcmFtIHtncmlkfSBncmlkXG4gICAgICovXG4gICAgR3JpZC5jbGVhciA9IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgZ3JpZC5idWNrZXRzID0ge307XG4gICAgICAgIGdyaWQucGFpcnMgPSB7fTtcbiAgICAgICAgZ3JpZC5wYWlyc0xpc3QgPSBbXTtcbiAgICB9O1xuXG4gICAgZGVwcmVjYXRlZChHcmlkLCAnY2xlYXInLCAnR3JpZC5jbGVhciDinqQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yJyk7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgdW5pb24gb2YgdHdvIHJlZ2lvbnMuXG4gICAgICogQG1ldGhvZCBfcmVnaW9uVW5pb25cbiAgICAgKiBAZGVwcmVjYXRlZCByZXBsYWNlZCBieSBNYXR0ZXIuRGV0ZWN0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSByZWdpb25BXG4gICAgICogQHBhcmFtIHt9IHJlZ2lvbkJcbiAgICAgKiBAcmV0dXJuIHt9IHJlZ2lvblxuICAgICAqL1xuICAgIEdyaWQuX3JlZ2lvblVuaW9uID0gZnVuY3Rpb24ocmVnaW9uQSwgcmVnaW9uQikge1xuICAgICAgICB2YXIgc3RhcnRDb2wgPSBNYXRoLm1pbihyZWdpb25BLnN0YXJ0Q29sLCByZWdpb25CLnN0YXJ0Q29sKSxcbiAgICAgICAgICAgIGVuZENvbCA9IE1hdGgubWF4KHJlZ2lvbkEuZW5kQ29sLCByZWdpb25CLmVuZENvbCksXG4gICAgICAgICAgICBzdGFydFJvdyA9IE1hdGgubWluKHJlZ2lvbkEuc3RhcnRSb3csIHJlZ2lvbkIuc3RhcnRSb3cpLFxuICAgICAgICAgICAgZW5kUm93ID0gTWF0aC5tYXgocmVnaW9uQS5lbmRSb3csIHJlZ2lvbkIuZW5kUm93KTtcblxuICAgICAgICByZXR1cm4gR3JpZC5fY3JlYXRlUmVnaW9uKHN0YXJ0Q29sLCBlbmRDb2wsIHN0YXJ0Um93LCBlbmRSb3cpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZWdpb24gYSBnaXZlbiBib2R5IGZhbGxzIGluIGZvciBhIGdpdmVuIGdyaWQuXG4gICAgICogQG1ldGhvZCBfZ2V0UmVnaW9uXG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBib2R5XG4gICAgICogQHJldHVybiB7fSByZWdpb25cbiAgICAgKi9cbiAgICBHcmlkLl9nZXRSZWdpb24gPSBmdW5jdGlvbihncmlkLCBib2R5KSB7XG4gICAgICAgIHZhciBib3VuZHMgPSBib2R5LmJvdW5kcyxcbiAgICAgICAgICAgIHN0YXJ0Q29sID0gTWF0aC5mbG9vcihib3VuZHMubWluLnggLyBncmlkLmJ1Y2tldFdpZHRoKSxcbiAgICAgICAgICAgIGVuZENvbCA9IE1hdGguZmxvb3IoYm91bmRzLm1heC54IC8gZ3JpZC5idWNrZXRXaWR0aCksXG4gICAgICAgICAgICBzdGFydFJvdyA9IE1hdGguZmxvb3IoYm91bmRzLm1pbi55IC8gZ3JpZC5idWNrZXRIZWlnaHQpLFxuICAgICAgICAgICAgZW5kUm93ID0gTWF0aC5mbG9vcihib3VuZHMubWF4LnkgLyBncmlkLmJ1Y2tldEhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIEdyaWQuX2NyZWF0ZVJlZ2lvbihzdGFydENvbCwgZW5kQ29sLCBzdGFydFJvdywgZW5kUm93KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlZ2lvbi5cbiAgICAgKiBAbWV0aG9kIF9jcmVhdGVSZWdpb25cbiAgICAgKiBAZGVwcmVjYXRlZCByZXBsYWNlZCBieSBNYXR0ZXIuRGV0ZWN0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7fSBzdGFydENvbFxuICAgICAqIEBwYXJhbSB7fSBlbmRDb2xcbiAgICAgKiBAcGFyYW0ge30gc3RhcnRSb3dcbiAgICAgKiBAcGFyYW0ge30gZW5kUm93XG4gICAgICogQHJldHVybiB7fSByZWdpb25cbiAgICAgKi9cbiAgICBHcmlkLl9jcmVhdGVSZWdpb24gPSBmdW5jdGlvbihzdGFydENvbCwgZW5kQ29sLCBzdGFydFJvdywgZW5kUm93KSB7XG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgaWQ6IHN0YXJ0Q29sICsgJywnICsgZW5kQ29sICsgJywnICsgc3RhcnRSb3cgKyAnLCcgKyBlbmRSb3csXG4gICAgICAgICAgICBzdGFydENvbDogc3RhcnRDb2wsIFxuICAgICAgICAgICAgZW5kQ29sOiBlbmRDb2wsIFxuICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93LCBcbiAgICAgICAgICAgIGVuZFJvdzogZW5kUm93IFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBidWNrZXQgaWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqIEBtZXRob2QgX2dldEJ1Y2tldElkXG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gY29sdW1uXG4gICAgICogQHBhcmFtIHt9IHJvd1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gYnVja2V0IGlkXG4gICAgICovXG4gICAgR3JpZC5fZ2V0QnVja2V0SWQgPSBmdW5jdGlvbihjb2x1bW4sIHJvdykge1xuICAgICAgICByZXR1cm4gJ0MnICsgY29sdW1uICsgJ1InICsgcm93O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYnVja2V0LlxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUJ1Y2tldFxuICAgICAqIEBkZXByZWNhdGVkIHJlcGxhY2VkIGJ5IE1hdHRlci5EZXRlY3RvclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IGJ1Y2tldHNcbiAgICAgKiBAcGFyYW0ge30gYnVja2V0SWRcbiAgICAgKiBAcmV0dXJuIHt9IGJ1Y2tldFxuICAgICAqL1xuICAgIEdyaWQuX2NyZWF0ZUJ1Y2tldCA9IGZ1bmN0aW9uKGJ1Y2tldHMsIGJ1Y2tldElkKSB7XG4gICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2J1Y2tldElkXSA9IFtdO1xuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYm9keSB0byBhIGJ1Y2tldC5cbiAgICAgKiBAbWV0aG9kIF9idWNrZXRBZGRCb2R5XG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRcbiAgICAgKiBAcGFyYW0ge30gYm9keVxuICAgICAqL1xuICAgIEdyaWQuX2J1Y2tldEFkZEJvZHkgPSBmdW5jdGlvbihncmlkLCBidWNrZXQsIGJvZHkpIHtcbiAgICAgICAgdmFyIGdyaWRQYWlycyA9IGdyaWQucGFpcnMsXG4gICAgICAgICAgICBwYWlySWQgPSBQYWlyLmlkLFxuICAgICAgICAgICAgYnVja2V0TGVuZ3RoID0gYnVja2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBwYWlyc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYnVja2V0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5QiA9IGJ1Y2tldFtpXTtcblxuICAgICAgICAgICAgaWYgKGJvZHkuaWQgPT09IGJvZHlCLmlkIHx8IChib2R5LmlzU3RhdGljICYmIGJvZHlCLmlzU3RhdGljKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGJ1Y2tldHMgdGhlIHBhaXIgZXhpc3RzIGluXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIEdyaWQudXBkYXRlIHRvIHdvcmtcbiAgICAgICAgICAgIHZhciBpZCA9IHBhaXJJZChib2R5LCBib2R5QiksXG4gICAgICAgICAgICAgICAgcGFpciA9IGdyaWRQYWlyc1tpZF07XG5cbiAgICAgICAgICAgIGlmIChwYWlyKSB7XG4gICAgICAgICAgICAgICAgcGFpclsyXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlkUGFpcnNbaWRdID0gW2JvZHksIGJvZHlCLCAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byBib2RpZXMgKGFmdGVyIHBhaXJzLCBvdGhlcndpc2UgcGFpcnMgd2l0aCBzZWxmKVxuICAgICAgICBidWNrZXQucHVzaChib2R5KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGJvZHkgZnJvbSBhIGJ1Y2tldC5cbiAgICAgKiBAbWV0aG9kIF9idWNrZXRSZW1vdmVCb2R5XG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEBwYXJhbSB7fSBidWNrZXRcbiAgICAgKiBAcGFyYW0ge30gYm9keVxuICAgICAqL1xuICAgIEdyaWQuX2J1Y2tldFJlbW92ZUJvZHkgPSBmdW5jdGlvbihncmlkLCBidWNrZXQsIGJvZHkpIHtcbiAgICAgICAgdmFyIGdyaWRQYWlycyA9IGdyaWQucGFpcnMsXG4gICAgICAgICAgICBwYWlySWQgPSBQYWlyLmlkLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyByZW1vdmUgZnJvbSBidWNrZXRcbiAgICAgICAgYnVja2V0LnNwbGljZShDb21tb24uaW5kZXhPZihidWNrZXQsIGJvZHkpLCAxKTtcblxuICAgICAgICB2YXIgYnVja2V0TGVuZ3RoID0gYnVja2V0Lmxlbmd0aDtcblxuICAgICAgICAvLyB1cGRhdGUgcGFpciBjb3VudHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJ1Y2tldExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgYnVja2V0cyB0aGUgcGFpciBleGlzdHMgaW5cbiAgICAgICAgICAgIC8vIGltcG9ydGFudCBmb3IgX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCB0byB3b3JrXG4gICAgICAgICAgICB2YXIgcGFpciA9IGdyaWRQYWlyc1twYWlySWQoYm9keSwgYnVja2V0W2ldKV07XG5cbiAgICAgICAgICAgIGlmIChwYWlyKVxuICAgICAgICAgICAgICAgIHBhaXJbMl0gLT0gMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBsaXN0IG9mIHRoZSBhY3RpdmUgcGFpcnMgaW4gdGhlIGdyaWQuXG4gICAgICogQG1ldGhvZCBfY3JlYXRlQWN0aXZlUGFpcnNMaXN0XG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgTWF0dGVyLkRldGVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge30gZ3JpZFxuICAgICAqIEByZXR1cm4gW10gcGFpcnNcbiAgICAgKi9cbiAgICBHcmlkLl9jcmVhdGVBY3RpdmVQYWlyc0xpc3QgPSBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBwYWlyLFxuICAgICAgICAgICAgZ3JpZFBhaXJzID0gZ3JpZC5wYWlycyxcbiAgICAgICAgICAgIHBhaXJLZXlzID0gQ29tbW9uLmtleXMoZ3JpZFBhaXJzKSxcbiAgICAgICAgICAgIHBhaXJLZXlzTGVuZ3RoID0gcGFpcktleXMubGVuZ3RoLFxuICAgICAgICAgICAgcGFpcnMgPSBbXSxcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGdyaWQucGFpcnNcbiAgICAgICAgZm9yIChrID0gMDsgayA8IHBhaXJLZXlzTGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHBhaXIgPSBncmlkUGFpcnNbcGFpcktleXNba11dO1xuXG4gICAgICAgICAgICAvLyBpZiBwYWlyIGV4aXN0cyBpbiBhdCBsZWFzdCBvbmUgYnVja2V0XG4gICAgICAgICAgICAvLyBpdCBpcyBhIHBhaXIgdGhhdCBuZWVkcyBmdXJ0aGVyIGNvbGxpc2lvbiB0ZXN0aW5nIHNvIHB1c2ggaXRcbiAgICAgICAgICAgIGlmIChwYWlyWzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2gocGFpcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBncmlkUGFpcnNbcGFpcktleXNba11dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH07XG4gICAgXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLk1vdXNlQ29uc3RyYWludGAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIGNyZWF0aW5nIG1vdXNlIGNvbnN0cmFpbnRzLlxuKiBNb3VzZSBjb25zdHJhaW50cyBhcmUgdXNlZCBmb3IgYWxsb3dpbmcgdXNlciBpbnRlcmFjdGlvbiwgcHJvdmlkaW5nIHRoZSBhYmlsaXR5IHRvIG1vdmUgYm9kaWVzIHZpYSB0aGUgbW91c2Ugb3IgdG91Y2guXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBNb3VzZUNvbnN0cmFpbnRcbiovXG5cbnZhciBNb3VzZUNvbnN0cmFpbnQgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZUNvbnN0cmFpbnQ7XG5cbnZhciBWZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgU2xlZXBpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIE1vdXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG52YXIgRXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBEZXRlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIENvbnN0cmFpbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBDb21wb3NpdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBtb3VzZSBjb25zdHJhaW50LlxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGhhdmUgZGVmYXVsdCB2YWx1ZXMsIGFuZCBtYW55IGFyZSBwcmUtY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIG90aGVyIHByb3BlcnRpZXMuXG4gICAgICogU2VlIHRoZSBwcm9wZXJ0aWVzIHNlY3Rpb24gYmVsb3cgZm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgeW91IGNhbiBwYXNzIHZpYSB0aGUgYG9wdGlvbnNgIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge30gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge01vdXNlQ29uc3RyYWludH0gQSBuZXcgTW91c2VDb25zdHJhaW50XG4gICAgICovXG4gICAgTW91c2VDb25zdHJhaW50LmNyZWF0ZSA9IGZ1bmN0aW9uKGVuZ2luZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbW91c2UgPSAoZW5naW5lID8gZW5naW5lLm1vdXNlIDogbnVsbCkgfHwgKG9wdGlvbnMgPyBvcHRpb25zLm1vdXNlIDogbnVsbCk7XG5cbiAgICAgICAgaWYgKCFtb3VzZSkge1xuICAgICAgICAgICAgaWYgKGVuZ2luZSAmJiBlbmdpbmUucmVuZGVyICYmIGVuZ2luZS5yZW5kZXIuY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgbW91c2UgPSBNb3VzZS5jcmVhdGUoZW5naW5lLnJlbmRlci5jYW52YXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKG9wdGlvbnMuZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdXNlID0gTW91c2UuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLndhcm4oJ01vdXNlQ29uc3RyYWludC5jcmVhdGU6IG9wdGlvbnMubW91c2Ugd2FzIHVuZGVmaW5lZCwgb3B0aW9ucy5lbGVtZW50IHdhcyB1bmRlZmluZWQsIG1heSBub3QgZnVuY3Rpb24gYXMgZXhwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25zdHJhaW50ID0gQ29uc3RyYWludC5jcmVhdGUoeyBcbiAgICAgICAgICAgIGxhYmVsOiAnTW91c2UgQ29uc3RyYWludCcsXG4gICAgICAgICAgICBwb2ludEE6IG1vdXNlLnBvc2l0aW9uLFxuICAgICAgICAgICAgcG9pbnRCOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogMC4wMSwgXG4gICAgICAgICAgICBzdGlmZm5lc3M6IDAuMSxcbiAgICAgICAgICAgIGFuZ3VsYXJTdGlmZm5lc3M6IDEsXG4gICAgICAgICAgICByZW5kZXI6IHtcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogJyM5MEVFOTAnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogM1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnbW91c2VDb25zdHJhaW50JyxcbiAgICAgICAgICAgIG1vdXNlOiBtb3VzZSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBib2R5OiBudWxsLFxuICAgICAgICAgICAgY29uc3RyYWludDogY29uc3RyYWludCxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZpbHRlcjoge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAweDAwMDEsXG4gICAgICAgICAgICAgICAgbWFzazogMHhGRkZGRkZGRixcbiAgICAgICAgICAgICAgICBncm91cDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBtb3VzZUNvbnN0cmFpbnQgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBFdmVudHMub24oZW5naW5lLCAnYmVmb3JlVXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYWxsQm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyhlbmdpbmUud29ybGQpO1xuICAgICAgICAgICAgTW91c2VDb25zdHJhaW50LnVwZGF0ZShtb3VzZUNvbnN0cmFpbnQsIGFsbEJvZGllcyk7XG4gICAgICAgICAgICBNb3VzZUNvbnN0cmFpbnQuX3RyaWdnZXJFdmVudHMobW91c2VDb25zdHJhaW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1vdXNlQ29uc3RyYWludDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gbW91c2UgY29uc3RyYWludC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtNb3VzZUNvbnN0cmFpbnR9IG1vdXNlQ29uc3RyYWludFxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKi9cbiAgICBNb3VzZUNvbnN0cmFpbnQudXBkYXRlID0gZnVuY3Rpb24obW91c2VDb25zdHJhaW50LCBib2RpZXMpIHtcbiAgICAgICAgdmFyIG1vdXNlID0gbW91c2VDb25zdHJhaW50Lm1vdXNlLFxuICAgICAgICAgICAgY29uc3RyYWludCA9IG1vdXNlQ29uc3RyYWludC5jb25zdHJhaW50LFxuICAgICAgICAgICAgYm9keSA9IG1vdXNlQ29uc3RyYWludC5ib2R5O1xuXG4gICAgICAgIGlmIChtb3VzZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIGlmICghY29uc3RyYWludC5ib2R5Qikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMoYm9keS5ib3VuZHMsIG1vdXNlLnBvc2l0aW9uKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBEZXRlY3Rvci5jYW5Db2xsaWRlKGJvZHkuY29sbGlzaW9uRmlsdGVyLCBtb3VzZUNvbnN0cmFpbnQuY29sbGlzaW9uRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGJvZHkucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gYm9keS5wYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmVydGljZXMuY29udGFpbnMocGFydC52ZXJ0aWNlcywgbW91c2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRBID0gbW91c2UucG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYm9keUIgPSBtb3VzZUNvbnN0cmFpbnQuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucG9pbnRCID0geyB4OiBtb3VzZS5wb3NpdGlvbi54IC0gYm9keS5wb3NpdGlvbi54LCB5OiBtb3VzZS5wb3NpdGlvbi55IC0gYm9keS5wb3NpdGlvbi55IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYW5nbGVCID0gYm9keS5hbmdsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTbGVlcGluZy5zZXQoYm9keSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdzdGFydGRyYWcnLCB7IG1vdXNlOiBtb3VzZSwgYm9keTogYm9keSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNsZWVwaW5nLnNldChjb25zdHJhaW50LmJvZHlCLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludC5wb2ludEEgPSBtb3VzZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQuYm9keUIgPSBtb3VzZUNvbnN0cmFpbnQuYm9keSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdHJhaW50LnBvaW50QiA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ2VuZGRyYWcnLCB7IG1vdXNlOiBtb3VzZSwgYm9keTogYm9keSB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBtb3VzZSBjb25zdHJhaW50IGV2ZW50cy5cbiAgICAgKiBAbWV0aG9kIF90cmlnZ2VyRXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZUNvbnN0cmFpbnRcbiAgICAgKi9cbiAgICBNb3VzZUNvbnN0cmFpbnQuX3RyaWdnZXJFdmVudHMgPSBmdW5jdGlvbihtb3VzZUNvbnN0cmFpbnQpIHtcbiAgICAgICAgdmFyIG1vdXNlID0gbW91c2VDb25zdHJhaW50Lm1vdXNlLFxuICAgICAgICAgICAgbW91c2VFdmVudHMgPSBtb3VzZS5zb3VyY2VFdmVudHM7XG5cbiAgICAgICAgaWYgKG1vdXNlRXZlbnRzLm1vdXNlbW92ZSlcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ21vdXNlbW92ZScsIHsgbW91c2U6IG1vdXNlIH0pO1xuXG4gICAgICAgIGlmIChtb3VzZUV2ZW50cy5tb3VzZWRvd24pXG4gICAgICAgICAgICBFdmVudHMudHJpZ2dlcihtb3VzZUNvbnN0cmFpbnQsICdtb3VzZWRvd24nLCB7IG1vdXNlOiBtb3VzZSB9KTtcblxuICAgICAgICBpZiAobW91c2VFdmVudHMubW91c2V1cClcbiAgICAgICAgICAgIEV2ZW50cy50cmlnZ2VyKG1vdXNlQ29uc3RyYWludCwgJ21vdXNldXAnLCB7IG1vdXNlOiBtb3VzZSB9KTtcblxuICAgICAgICAvLyByZXNldCB0aGUgbW91c2Ugc3RhdGUgcmVhZHkgZm9yIHRoZSBuZXh0IHN0ZXBcbiAgICAgICAgTW91c2UuY2xlYXJTb3VyY2VFdmVudHMobW91c2UpO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBoYXMgbW92ZWQgKG9yIGEgdG91Y2ggbW92ZXMpIGR1cmluZyB0aGUgbGFzdCBzdGVwXG4gICAgKlxuICAgICogQGV2ZW50IG1vdXNlbW92ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHttb3VzZX0gZXZlbnQubW91c2UgVGhlIGVuZ2luZSdzIG1vdXNlIGluc3RhbmNlXG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgd2hlbiB0aGUgbW91c2UgaXMgZG93biAob3IgYSB0b3VjaCBoYXMgc3RhcnRlZCkgZHVyaW5nIHRoZSBsYXN0IHN0ZXBcbiAgICAqXG4gICAgKiBAZXZlbnQgbW91c2Vkb3duXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge21vdXNlfSBldmVudC5tb3VzZSBUaGUgZW5naW5lJ3MgbW91c2UgaW5zdGFuY2VcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBtb3VzZSBpcyB1cCAob3IgYSB0b3VjaCBoYXMgZW5kZWQpIGR1cmluZyB0aGUgbGFzdCBzdGVwXG4gICAgKlxuICAgICogQGV2ZW50IG1vdXNldXBcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIGEgYm9keVxuICAgICpcbiAgICAqIEBldmVudCBzdGFydGRyYWdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHtib2R5fSBldmVudC5ib2R5IFRoZSBib2R5IGJlaW5nIGRyYWdnZWRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGVuZHMgZHJhZ2dpbmcgYSBib2R5XG4gICAgKlxuICAgICogQGV2ZW50IGVuZGRyYWdcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bW91c2V9IGV2ZW50Lm1vdXNlIFRoZSBlbmdpbmUncyBtb3VzZSBpbnN0YW5jZVxuICAgICogQHBhcmFtIHtib2R5fSBldmVudC5ib2R5IFRoZSBib2R5IHRoYXQgaGFzIHN0b3BwZWQgYmVpbmcgZHJhZ2dlZFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKlxuICAgICpcbiAgICAqICBQcm9wZXJ0aWVzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYFN0cmluZ2AgZGVub3RpbmcgdGhlIHR5cGUgb2Ygb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKiBAZGVmYXVsdCBcImNvbnN0cmFpbnRcIlxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBNb3VzZWAgaW5zdGFuY2UgaW4gdXNlLiBJZiBub3Qgc3VwcGxpZWQgaW4gYE1vdXNlQ29uc3RyYWludC5jcmVhdGVgLCBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG1vdXNlXG4gICAgICogQHR5cGUgbW91c2VcbiAgICAgKiBAZGVmYXVsdCBtb3VzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBCb2R5YCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBtb3ZlZCBieSB0aGUgdXNlciwgb3IgYG51bGxgIGlmIG5vIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm9keVxuICAgICAqIEB0eXBlIGJvZHlcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYENvbnN0cmFpbnRgIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gbW92ZSB0aGUgYm9keSBkdXJpbmcgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludFxuICAgICAqIEB0eXBlIGNvbnN0cmFpbnRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFuIGBPYmplY3RgIHRoYXQgc3BlY2lmaWVzIHRoZSBjb2xsaXNpb24gZmlsdGVyIHByb3BlcnRpZXMuXG4gICAgICogVGhlIGNvbGxpc2lvbiBmaWx0ZXIgYWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSB3aGljaCB0eXBlcyBvZiBib2R5IHRoaXMgbW91c2UgY29uc3RyYWludCBjYW4gaW50ZXJhY3Qgd2l0aC5cbiAgICAgKiBTZWUgYGJvZHkuY29sbGlzaW9uRmlsdGVyYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25GaWx0ZXJcbiAgICAgKiBAdHlwZSBvYmplY3RcbiAgICAgKi9cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuKiBUaGUgYE1hdHRlci5RdWVyeWAgbW9kdWxlIGNvbnRhaW5zIG1ldGhvZHMgZm9yIHBlcmZvcm1pbmcgY29sbGlzaW9uIHF1ZXJpZXMuXG4qXG4qIFNlZSB0aGUgaW5jbHVkZWQgdXNhZ2UgW2V4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbGlhYnJ1L21hdHRlci1qcy90cmVlL21hc3Rlci9leGFtcGxlcykuXG4qXG4qIEBjbGFzcyBRdWVyeVxuKi9cblxudmFyIFF1ZXJ5ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5cbnZhciBWZWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIENvbGxpc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgQm91bmRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBCb2RpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBWZXJ0aWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbGxpc2lvbnMgYmV0d2VlbiBgYm9keWAgYW5kIGBib2RpZXNgLlxuICAgICAqIEBtZXRob2QgY29sbGlkZXNcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHJldHVybiB7Y29sbGlzaW9uW119IENvbGxpc2lvbnNcbiAgICAgKi9cbiAgICBRdWVyeS5jb2xsaWRlcyA9IGZ1bmN0aW9uKGJvZHksIGJvZGllcykge1xuICAgICAgICB2YXIgY29sbGlzaW9ucyA9IFtdLFxuICAgICAgICAgICAgYm9kaWVzTGVuZ3RoID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGJvdW5kcyA9IGJvZHkuYm91bmRzLFxuICAgICAgICAgICAgY29sbGlkZXMgPSBDb2xsaXNpb24uY29sbGlkZXMsXG4gICAgICAgICAgICBvdmVybGFwcyA9IEJvdW5kcy5vdmVybGFwcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keUEgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgcGFydHNBTGVuZ3RoID0gYm9keUEucGFydHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBhcnRzQVN0YXJ0ID0gcGFydHNBTGVuZ3RoID09PSAxID8gMCA6IDE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvdmVybGFwcyhib2R5QS5ib3VuZHMsIGJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gcGFydHNBU3RhcnQ7IGogPCBwYXJ0c0FMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGJvZHlBLnBhcnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGFwcyhwYXJ0LmJvdW5kcywgYm91bmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IGNvbGxpZGVzKHBhcnQsIGJvZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9ucy5wdXNoKGNvbGxpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGlzaW9ucztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYSByYXkgc2VnbWVudCBhZ2FpbnN0IGEgc2V0IG9mIGJvZGllcyBhbmQgcmV0dXJucyBhbGwgY29sbGlzaW9ucywgcmF5IHdpZHRoIGlzIG9wdGlvbmFsLiBJbnRlcnNlY3Rpb24gcG9pbnRzIGFyZSBub3QgcHJvdmlkZWQuXG4gICAgICogQG1ldGhvZCByYXlcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHN0YXJ0UG9pbnRcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gZW5kUG9pbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JheVdpZHRoXVxuICAgICAqIEByZXR1cm4ge2NvbGxpc2lvbltdfSBDb2xsaXNpb25zXG4gICAgICovXG4gICAgUXVlcnkucmF5ID0gZnVuY3Rpb24oYm9kaWVzLCBzdGFydFBvaW50LCBlbmRQb2ludCwgcmF5V2lkdGgpIHtcbiAgICAgICAgcmF5V2lkdGggPSByYXlXaWR0aCB8fCAxZS0xMDA7XG5cbiAgICAgICAgdmFyIHJheUFuZ2xlID0gVmVjdG9yLmFuZ2xlKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSxcbiAgICAgICAgICAgIHJheUxlbmd0aCA9IFZlY3Rvci5tYWduaXR1ZGUoVmVjdG9yLnN1YihzdGFydFBvaW50LCBlbmRQb2ludCkpLFxuICAgICAgICAgICAgcmF5WCA9IChlbmRQb2ludC54ICsgc3RhcnRQb2ludC54KSAqIDAuNSxcbiAgICAgICAgICAgIHJheVkgPSAoZW5kUG9pbnQueSArIHN0YXJ0UG9pbnQueSkgKiAwLjUsXG4gICAgICAgICAgICByYXkgPSBCb2RpZXMucmVjdGFuZ2xlKHJheVgsIHJheVksIHJheUxlbmd0aCwgcmF5V2lkdGgsIHsgYW5nbGU6IHJheUFuZ2xlIH0pLFxuICAgICAgICAgICAgY29sbGlzaW9ucyA9IFF1ZXJ5LmNvbGxpZGVzKHJheSwgYm9kaWVzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxpc2lvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjb2xsaXNpb24gPSBjb2xsaXNpb25zW2ldO1xuICAgICAgICAgICAgY29sbGlzaW9uLmJvZHkgPSBjb2xsaXNpb24uYm9keUIgPSBjb2xsaXNpb24uYm9keUE7ICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGlzaW9ucztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIHdob3NlIGJvdW5kcyBhcmUgaW5zaWRlIChvciBvdXRzaWRlIGlmIHNldCkgdGhlIGdpdmVuIHNldCBvZiBib3VuZHMsIGZyb20gdGhlIGdpdmVuIHNldCBvZiBib2RpZXMuXG4gICAgICogQG1ldGhvZCByZWdpb25cbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtib3VuZHN9IGJvdW5kc1xuICAgICAqIEBwYXJhbSB7Ym9vbH0gW291dHNpZGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Ym9keVtdfSBUaGUgYm9kaWVzIG1hdGNoaW5nIHRoZSBxdWVyeVxuICAgICAqL1xuICAgIFF1ZXJ5LnJlZ2lvbiA9IGZ1bmN0aW9uKGJvZGllcywgYm91bmRzLCBvdXRzaWRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgb3ZlcmxhcHMgPSBCb3VuZHMub3ZlcmxhcHMoYm9keS5ib3VuZHMsIGJvdW5kcyk7XG4gICAgICAgICAgICBpZiAoKG92ZXJsYXBzICYmICFvdXRzaWRlKSB8fCAoIW92ZXJsYXBzICYmIG91dHNpZGUpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYm9kaWVzIHdob3NlIHZlcnRpY2VzIGNvbnRhaW4gdGhlIGdpdmVuIHBvaW50LCBmcm9tIHRoZSBnaXZlbiBzZXQgb2YgYm9kaWVzLlxuICAgICAqIEBtZXRob2QgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHt2ZWN0b3J9IHBvaW50XG4gICAgICogQHJldHVybiB7Ym9keVtdfSBUaGUgYm9kaWVzIG1hdGNoaW5nIHRoZSBxdWVyeVxuICAgICAqL1xuICAgIFF1ZXJ5LnBvaW50ID0gZnVuY3Rpb24oYm9kaWVzLCBwb2ludCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoQm91bmRzLmNvbnRhaW5zKGJvZHkuYm91bmRzLCBwb2ludCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gYm9keS5wYXJ0cy5sZW5ndGggPT09IDEgPyAwIDogMTsgaiA8IGJvZHkucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBib2R5LnBhcnRzW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMocGFydC5ib3VuZHMsIHBvaW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgVmVydGljZXMuY29udGFpbnMocGFydC52ZXJ0aWNlcywgcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoZSBgTWF0dGVyLlJlbmRlcmAgbW9kdWxlIGlzIGEgc2ltcGxlIGNhbnZhcyBiYXNlZCByZW5kZXJlciBmb3IgdmlzdWFsaXNpbmcgaW5zdGFuY2VzIG9mIGBNYXR0ZXIuRW5naW5lYC5cbiogSXQgaXMgaW50ZW5kZWQgZm9yIGRldmVsb3BtZW50IGFuZCBkZWJ1Z2dpbmcgcHVycG9zZXMsIGJ1dCBtYXkgYWxzbyBiZSBzdWl0YWJsZSBmb3Igc2ltcGxlIGdhbWVzLlxuKiBJdCBpbmNsdWRlcyBhIG51bWJlciBvZiBkcmF3aW5nIG9wdGlvbnMgaW5jbHVkaW5nIHdpcmVmcmFtZSwgdmVjdG9yIHdpdGggc3VwcG9ydCBmb3Igc3ByaXRlcyBhbmQgdmlld3BvcnRzLlxuKlxuKiBAY2xhc3MgUmVuZGVyXG4qL1xuXG52YXIgUmVuZGVyID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyO1xuXG52YXIgQm9keSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBDb21wb3NpdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIEJvdW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgRXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBWZWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIE1vdXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbihmdW5jdGlvbigpIHtcblxuICAgIHZhciBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbihjYWxsYmFjayl7IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhDb21tb24ubm93KCkpOyB9LCAxMDAwIC8gNjApOyB9O1xuXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgIH1cblxuICAgIFJlbmRlci5fZ29vZEZwcyA9IDMwO1xuICAgIFJlbmRlci5fZ29vZERlbHRhID0gMTAwMCAvIDYwO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZW5kZXJlci4gVGhlIG9wdGlvbnMgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBhbnkgcHJvcGVydGllcyB5b3Ugd2lzaCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gICAgICogQWxsIHByb3BlcnRpZXMgaGF2ZSBkZWZhdWx0IHZhbHVlcywgYW5kIG1hbnkgYXJlIHByZS1jYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKiBTZWUgdGhlIHByb3BlcnRpZXMgc2VjdGlvbiBiZWxvdyBmb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCB5b3UgY2FuIHBhc3MgdmlhIHRoZSBgb3B0aW9uc2Agb2JqZWN0LlxuICAgICAqIEBtZXRob2QgY3JlYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm4ge3JlbmRlcn0gQSBuZXcgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBSZW5kZXIuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBlbmdpbmU6IG51bGwsXG4gICAgICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgY2FudmFzOiBudWxsLFxuICAgICAgICAgICAgbW91c2U6IG51bGwsXG4gICAgICAgICAgICBmcmFtZVJlcXVlc3RJZDogbnVsbCxcbiAgICAgICAgICAgIHRpbWluZzoge1xuICAgICAgICAgICAgICAgIGhpc3RvcnlTaXplOiA2MCxcbiAgICAgICAgICAgICAgICBkZWx0YTogMCxcbiAgICAgICAgICAgICAgICBkZWx0YUhpc3Rvcnk6IFtdLFxuICAgICAgICAgICAgICAgIGxhc3RUaW1lOiAwLFxuICAgICAgICAgICAgICAgIGxhc3RUaW1lc3RhbXA6IDAsXG4gICAgICAgICAgICAgICAgbGFzdEVsYXBzZWQ6IDAsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wRWxhcHNlZDogMCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBFbGFwc2VkSGlzdG9yeTogW10sXG4gICAgICAgICAgICAgICAgZW5naW5lRGVsdGFIaXN0b3J5OiBbXSxcbiAgICAgICAgICAgICAgICBlbmdpbmVFbGFwc2VkSGlzdG9yeTogW10sXG4gICAgICAgICAgICAgICAgZWxhcHNlZEhpc3Rvcnk6IFtdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogMSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzE0MTUxZicsXG4gICAgICAgICAgICAgICAgd2lyZWZyYW1lQmFja2dyb3VuZDogJyMxNDE1MWYnLFxuICAgICAgICAgICAgICAgIGhhc0JvdW5kczogISFvcHRpb25zLmJvdW5kcyxcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hvd1NsZWVwaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNob3dEZWJ1ZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1N0YXRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93UGVyZm9ybWFuY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dCb3VuZHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dWZWxvY2l0eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0NvbGxpc2lvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dTZXBhcmF0aW9uczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0F4ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dQb3NpdGlvbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dBbmdsZUluZGljYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0lkczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1ZlcnRleE51bWJlcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dDb252ZXhIdWxsczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0ludGVybmFsRWRnZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dNb3VzZVBvc2l0aW9uOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZW5kZXIgPSBDb21tb24uZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAocmVuZGVyLmNhbnZhcykge1xuICAgICAgICAgICAgcmVuZGVyLmNhbnZhcy53aWR0aCA9IHJlbmRlci5vcHRpb25zLndpZHRoIHx8IHJlbmRlci5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICByZW5kZXIuY2FudmFzLmhlaWdodCA9IHJlbmRlci5vcHRpb25zLmhlaWdodCB8fCByZW5kZXIuY2FudmFzLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlci5tb3VzZSA9IG9wdGlvbnMubW91c2U7XG4gICAgICAgIHJlbmRlci5lbmdpbmUgPSBvcHRpb25zLmVuZ2luZTtcbiAgICAgICAgcmVuZGVyLmNhbnZhcyA9IHJlbmRlci5jYW52YXMgfHwgX2NyZWF0ZUNhbnZhcyhyZW5kZXIub3B0aW9ucy53aWR0aCwgcmVuZGVyLm9wdGlvbnMuaGVpZ2h0KTtcbiAgICAgICAgcmVuZGVyLmNvbnRleHQgPSByZW5kZXIuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHJlbmRlci50ZXh0dXJlcyA9IHt9O1xuXG4gICAgICAgIHJlbmRlci5ib3VuZHMgPSByZW5kZXIuYm91bmRzIHx8IHtcbiAgICAgICAgICAgIG1pbjoge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heDoge1xuICAgICAgICAgICAgICAgIHg6IHJlbmRlci5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgICAgeTogcmVuZGVyLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmb3IgdGVtcG9yYXJ5IGJhY2sgY29tcGF0aWJpbGl0eSBvbmx5XG4gICAgICAgIHJlbmRlci5jb250cm9sbGVyID0gUmVuZGVyO1xuICAgICAgICByZW5kZXIub3B0aW9ucy5zaG93QnJvYWRwaGFzZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChyZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICBSZW5kZXIuc2V0UGl4ZWxSYXRpbyhyZW5kZXIsIHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbW1vbi5pc0VsZW1lbnQocmVuZGVyLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZW5kZXIuZWxlbWVudC5hcHBlbmRDaGlsZChyZW5kZXIuY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRpbnVvdXNseSB1cGRhdGVzIHRoZSByZW5kZXIgY2FudmFzIG9uIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBldmVudC5cbiAgICAgKiBAbWV0aG9kIHJ1blxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKi9cbiAgICBSZW5kZXIucnVuID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIChmdW5jdGlvbiBsb29wKHRpbWUpe1xuICAgICAgICAgICAgcmVuZGVyLmZyYW1lUmVxdWVzdElkID0gX3JlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgX3VwZGF0ZVRpbWluZyhyZW5kZXIsIHRpbWUpO1xuXG4gICAgICAgICAgICBSZW5kZXIud29ybGQocmVuZGVyLCB0aW1lKTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlci5vcHRpb25zLnNob3dTdGF0cyB8fCByZW5kZXIub3B0aW9ucy5zaG93RGVidWcpIHtcbiAgICAgICAgICAgICAgICBSZW5kZXIuc3RhdHMocmVuZGVyLCByZW5kZXIuY29udGV4dCwgdGltZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXIub3B0aW9ucy5zaG93UGVyZm9ybWFuY2UgfHwgcmVuZGVyLm9wdGlvbnMuc2hvd0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgUmVuZGVyLnBlcmZvcm1hbmNlKHJlbmRlciwgcmVuZGVyLmNvbnRleHQsIHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUmVuZGVyLnJ1bmAgb24gdGhlIGdpdmVuIGByZW5kZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXG4gICAgICogQG1ldGhvZCBzdG9wXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqL1xuICAgIFJlbmRlci5zdG9wID0gZnVuY3Rpb24ocmVuZGVyKSB7XG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZShyZW5kZXIuZnJhbWVSZXF1ZXN0SWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgcmVuZGVyZXIgYW5kIHVwZGF0ZXMgdGhlIGNhbnZhcy5cbiAgICAgKiBUbyBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgY29ycmVjdCByYXRpbywgcGFzcyB0aGUgc3RyaW5nIGAnYXV0bydgIGZvciBgcGl4ZWxSYXRpb2AuXG4gICAgICogQG1ldGhvZCBzZXRQaXhlbFJhdGlvXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvXG4gICAgICovXG4gICAgUmVuZGVyLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbihyZW5kZXIsIHBpeGVsUmF0aW8pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbnZhcyA9IHJlbmRlci5jYW52YXM7XG5cbiAgICAgICAgaWYgKHBpeGVsUmF0aW8gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IF9nZXRQaXhlbFJhdGlvKGNhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLXBpeGVsLXJhdGlvJywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGggKiBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICsgJ3B4JztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb25zIGFuZCBzaXplcyB0aGUgdmlld3BvcnQgYXJvdW5kIHRoZSBnaXZlbiBvYmplY3QgYm91bmRzLlxuICAgICAqIE9iamVjdHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogLSBgb2JqZWN0LmJvdW5kc2BcbiAgICAgKiAtIGBvYmplY3QucG9zaXRpb25gXG4gICAgICogLSBgb2JqZWN0Lm1pbmAgYW5kIGBvYmplY3QubWF4YFxuICAgICAqIC0gYG9iamVjdC54YCBhbmQgYG9iamVjdC55YFxuICAgICAqIEBtZXRob2QgbG9va0F0XG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge3ZlY3Rvcn0gW3BhZGRpbmddXG4gICAgICogQHBhcmFtIHtib29sfSBbY2VudGVyPXRydWVdXG4gICAgICovXG4gICAgUmVuZGVyLmxvb2tBdCA9IGZ1bmN0aW9uKHJlbmRlciwgb2JqZWN0cywgcGFkZGluZywgY2VudGVyKSB7XG4gICAgICAgIGNlbnRlciA9IHR5cGVvZiBjZW50ZXIgIT09ICd1bmRlZmluZWQnID8gY2VudGVyIDogdHJ1ZTtcbiAgICAgICAgb2JqZWN0cyA9IENvbW1vbi5pc0FycmF5KG9iamVjdHMpID8gb2JqZWN0cyA6IFtvYmplY3RzXTtcbiAgICAgICAgcGFkZGluZyA9IHBhZGRpbmcgfHwge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBmaW5kIGJvdW5kcyBvZiBhbGwgb2JqZWN0c1xuICAgICAgICB2YXIgYm91bmRzID0ge1xuICAgICAgICAgICAgbWluOiB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSB9LFxuICAgICAgICAgICAgbWF4OiB7IHg6IC1JbmZpbml0eSwgeTogLUluZmluaXR5IH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBvYmplY3RzW2ldLFxuICAgICAgICAgICAgICAgIG1pbiA9IG9iamVjdC5ib3VuZHMgPyBvYmplY3QuYm91bmRzLm1pbiA6IChvYmplY3QubWluIHx8IG9iamVjdC5wb3NpdGlvbiB8fCBvYmplY3QpLFxuICAgICAgICAgICAgICAgIG1heCA9IG9iamVjdC5ib3VuZHMgPyBvYmplY3QuYm91bmRzLm1heCA6IChvYmplY3QubWF4IHx8IG9iamVjdC5wb3NpdGlvbiB8fCBvYmplY3QpO1xuXG4gICAgICAgICAgICBpZiAobWluICYmIG1heCkge1xuICAgICAgICAgICAgICAgIGlmIChtaW4ueCA8IGJvdW5kcy5taW4ueClcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1pbi54ID0gbWluLng7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4LnggPiBib3VuZHMubWF4LngpXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5tYXgueCA9IG1heC54O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1pbi55IDwgYm91bmRzLm1pbi55KVxuICAgICAgICAgICAgICAgICAgICBib3VuZHMubWluLnkgPSBtaW4ueTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXgueSA+IGJvdW5kcy5tYXgueSlcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLm1heC55ID0gbWF4Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHJhdGlvc1xuICAgICAgICB2YXIgd2lkdGggPSAoYm91bmRzLm1heC54IC0gYm91bmRzLm1pbi54KSArIDIgKiBwYWRkaW5nLngsXG4gICAgICAgICAgICBoZWlnaHQgPSAoYm91bmRzLm1heC55IC0gYm91bmRzLm1pbi55KSArIDIgKiBwYWRkaW5nLnksXG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gcmVuZGVyLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICB2aWV3V2lkdGggPSByZW5kZXIuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgb3V0ZXJSYXRpbyA9IHZpZXdXaWR0aCAvIHZpZXdIZWlnaHQsXG4gICAgICAgICAgICBpbm5lclJhdGlvID0gd2lkdGggLyBoZWlnaHQsXG4gICAgICAgICAgICBzY2FsZVggPSAxLFxuICAgICAgICAgICAgc2NhbGVZID0gMTtcblxuICAgICAgICAvLyBmaW5kIHNjYWxlIGZhY3RvclxuICAgICAgICBpZiAoaW5uZXJSYXRpbyA+IG91dGVyUmF0aW8pIHtcbiAgICAgICAgICAgIHNjYWxlWSA9IGlubmVyUmF0aW8gLyBvdXRlclJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NhbGVYID0gb3V0ZXJSYXRpbyAvIGlubmVyUmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmFibGUgYm91bmRzXG4gICAgICAgIHJlbmRlci5vcHRpb25zLmhhc0JvdW5kcyA9IHRydWU7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gYW5kIHNpemVcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueCA9IGJvdW5kcy5taW4ueDtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5tYXgueCA9IGJvdW5kcy5taW4ueCArIHdpZHRoICogc2NhbGVYO1xuICAgICAgICByZW5kZXIuYm91bmRzLm1pbi55ID0gYm91bmRzLm1pbi55O1xuICAgICAgICByZW5kZXIuYm91bmRzLm1heC55ID0gYm91bmRzLm1pbi55ICsgaGVpZ2h0ICogc2NhbGVZO1xuXG4gICAgICAgIC8vIGNlbnRlclxuICAgICAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgICAgICByZW5kZXIuYm91bmRzLm1pbi54ICs9IHdpZHRoICogMC41IC0gKHdpZHRoICogc2NhbGVYKSAqIDAuNTtcbiAgICAgICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnggKz0gd2lkdGggKiAwLjUgLSAod2lkdGggKiBzY2FsZVgpICogMC41O1xuICAgICAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueSArPSBoZWlnaHQgKiAwLjUgLSAoaGVpZ2h0ICogc2NhbGVZKSAqIDAuNTtcbiAgICAgICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnkgKz0gaGVpZ2h0ICogMC41IC0gKGhlaWdodCAqIHNjYWxlWSkgKiAwLjU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgIHJlbmRlci5ib3VuZHMubWluLnggLT0gcGFkZGluZy54O1xuICAgICAgICByZW5kZXIuYm91bmRzLm1heC54IC09IHBhZGRpbmcueDtcbiAgICAgICAgcmVuZGVyLmJvdW5kcy5taW4ueSAtPSBwYWRkaW5nLnk7XG4gICAgICAgIHJlbmRlci5ib3VuZHMubWF4LnkgLT0gcGFkZGluZy55O1xuXG4gICAgICAgIC8vIHVwZGF0ZSBtb3VzZVxuICAgICAgICBpZiAocmVuZGVyLm1vdXNlKSB7XG4gICAgICAgICAgICBNb3VzZS5zZXRTY2FsZShyZW5kZXIubW91c2UsIHtcbiAgICAgICAgICAgICAgICB4OiAocmVuZGVyLmJvdW5kcy5tYXgueCAtIHJlbmRlci5ib3VuZHMubWluLngpIC8gcmVuZGVyLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICB5OiAocmVuZGVyLmJvdW5kcy5tYXgueSAtIHJlbmRlci5ib3VuZHMubWluLnkpIC8gcmVuZGVyLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBNb3VzZS5zZXRPZmZzZXQocmVuZGVyLm1vdXNlLCByZW5kZXIuYm91bmRzLm1pbik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB2aWV3cG9ydCB0cmFuc2Zvcm1zIGJhc2VkIG9uIGByZW5kZXIuYm91bmRzYCB0byBhIHJlbmRlciBjb250ZXh0LlxuICAgICAqIEBtZXRob2Qgc3RhcnRWaWV3VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqL1xuICAgIFJlbmRlci5zdGFydFZpZXdUcmFuc2Zvcm0gPSBmdW5jdGlvbihyZW5kZXIpIHtcbiAgICAgICAgdmFyIGJvdW5kc1dpZHRoID0gcmVuZGVyLmJvdW5kcy5tYXgueCAtIHJlbmRlci5ib3VuZHMubWluLngsXG4gICAgICAgICAgICBib3VuZHNIZWlnaHQgPSByZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSxcbiAgICAgICAgICAgIGJvdW5kc1NjYWxlWCA9IGJvdW5kc1dpZHRoIC8gcmVuZGVyLm9wdGlvbnMud2lkdGgsXG4gICAgICAgICAgICBib3VuZHNTY2FsZVkgPSBib3VuZHNIZWlnaHQgLyByZW5kZXIub3B0aW9ucy5oZWlnaHQ7XG5cbiAgICAgICAgcmVuZGVyLmNvbnRleHQuc2V0VHJhbnNmb3JtKFxuICAgICAgICAgICAgcmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbyAvIGJvdW5kc1NjYWxlWCwgMCwgMCwgXG4gICAgICAgICAgICByZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvIC8gYm91bmRzU2NhbGVZLCAwLCAwXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICByZW5kZXIuY29udGV4dC50cmFuc2xhdGUoLXJlbmRlci5ib3VuZHMubWluLngsIC1yZW5kZXIuYm91bmRzLm1pbi55KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCB0cmFuc2Zvcm1zIG9uIHRoZSByZW5kZXIgY29udGV4dC5cbiAgICAgKiBAbWV0aG9kIGVuZFZpZXdUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICovXG4gICAgUmVuZGVyLmVuZFZpZXdUcmFuc2Zvcm0gPSBmdW5jdGlvbihyZW5kZXIpIHtcbiAgICAgICAgcmVuZGVyLmNvbnRleHQuc2V0VHJhbnNmb3JtKHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8sIDAsIDAsIHJlbmRlci5vcHRpb25zLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBgZW5naW5lYCdzIGBNYXR0ZXIuV29ybGRgIG9iamVjdC5cbiAgICAgKiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYWxsIHJlbmRlcmluZyBhbmQgc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBzY2VuZSBjaGFuZ2VzLlxuICAgICAqIEBtZXRob2Qgd29ybGRcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICovXG4gICAgUmVuZGVyLndvcmxkID0gZnVuY3Rpb24ocmVuZGVyLCB0aW1lKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBDb21tb24ubm93KCksXG4gICAgICAgICAgICBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgd29ybGQgPSBlbmdpbmUud29ybGQsXG4gICAgICAgICAgICBjYW52YXMgPSByZW5kZXIuY2FudmFzLFxuICAgICAgICAgICAgY29udGV4dCA9IHJlbmRlci5jb250ZXh0LFxuICAgICAgICAgICAgb3B0aW9ucyA9IHJlbmRlci5vcHRpb25zLFxuICAgICAgICAgICAgdGltaW5nID0gcmVuZGVyLnRpbWluZztcblxuICAgICAgICB2YXIgYWxsQm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCksXG4gICAgICAgICAgICBhbGxDb25zdHJhaW50cyA9IENvbXBvc2l0ZS5hbGxDb25zdHJhaW50cyh3b3JsZCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kID0gb3B0aW9ucy53aXJlZnJhbWVzID8gb3B0aW9ucy53aXJlZnJhbWVCYWNrZ3JvdW5kIDogb3B0aW9ucy5iYWNrZ3JvdW5kLFxuICAgICAgICAgICAgYm9kaWVzID0gW10sXG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IFtdLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IGVuZ2luZS50aW1pbmcudGltZXN0YW1wXG4gICAgICAgIH07XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocmVuZGVyLCAnYmVmb3JlUmVuZGVyJywgZXZlbnQpO1xuXG4gICAgICAgIC8vIGFwcGx5IGJhY2tncm91bmQgaWYgaXQgaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKHJlbmRlci5jdXJyZW50QmFja2dyb3VuZCAhPT0gYmFja2dyb3VuZClcbiAgICAgICAgICAgIF9hcHBseUJhY2tncm91bmQocmVuZGVyLCBiYWNrZ3JvdW5kKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgY2FudmFzIHdpdGggYSB0cmFuc3BhcmVudCBmaWxsLCB0byBhbGxvdyB0aGUgY2FudmFzIGJhY2tncm91bmQgdG8gc2hvd1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2UtaW4nO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG5cbiAgICAgICAgLy8gaGFuZGxlIGJvdW5kc1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNCb3VuZHMpIHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgYm9kaWVzIHRoYXQgYXJlIG5vdCBpbiB2aWV3XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsQm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBhbGxCb2RpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKEJvdW5kcy5vdmVybGFwcyhib2R5LmJvdW5kcywgcmVuZGVyLmJvdW5kcykpXG4gICAgICAgICAgICAgICAgICAgIGJvZGllcy5wdXNoKGJvZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGNvbnN0cmFpbnRzIHRoYXQgYXJlIG5vdCBpbiB2aWV3XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWxsQ29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGFsbENvbnN0cmFpbnRzW2ldLFxuICAgICAgICAgICAgICAgICAgICBib2R5QSA9IGNvbnN0cmFpbnQuYm9keUEsXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCID0gY29uc3RyYWludC5ib2R5QixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRBV29ybGQgPSBjb25zdHJhaW50LnBvaW50QSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCV29ybGQgPSBjb25zdHJhaW50LnBvaW50QjtcblxuICAgICAgICAgICAgICAgIGlmIChib2R5QSkgcG9pbnRBV29ybGQgPSBWZWN0b3IuYWRkKGJvZHlBLnBvc2l0aW9uLCBjb25zdHJhaW50LnBvaW50QSk7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCKSBwb2ludEJXb3JsZCA9IFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRCKTtcblxuICAgICAgICAgICAgICAgIGlmICghcG9pbnRBV29ybGQgfHwgIXBvaW50QldvcmxkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmIChCb3VuZHMuY29udGFpbnMocmVuZGVyLmJvdW5kcywgcG9pbnRBV29ybGQpIHx8IEJvdW5kcy5jb250YWlucyhyZW5kZXIuYm91bmRzLCBwb2ludEJXb3JsZCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgdmlld1xuICAgICAgICAgICAgUmVuZGVyLnN0YXJ0Vmlld1RyYW5zZm9ybShyZW5kZXIpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgbW91c2VcbiAgICAgICAgICAgIGlmIChyZW5kZXIubW91c2UpIHtcbiAgICAgICAgICAgICAgICBNb3VzZS5zZXRTY2FsZShyZW5kZXIubW91c2UsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogKHJlbmRlci5ib3VuZHMubWF4LnggLSByZW5kZXIuYm91bmRzLm1pbi54KSAvIHJlbmRlci5vcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB5OiAocmVuZGVyLmJvdW5kcy5tYXgueSAtIHJlbmRlci5ib3VuZHMubWluLnkpIC8gcmVuZGVyLm9wdGlvbnMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBNb3VzZS5zZXRPZmZzZXQocmVuZGVyLm1vdXNlLCByZW5kZXIuYm91bmRzLm1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cyA9IGFsbENvbnN0cmFpbnRzO1xuICAgICAgICAgICAgYm9kaWVzID0gYWxsQm9kaWVzO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyLm9wdGlvbnMucGl4ZWxSYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJlbmRlci5jb250ZXh0LnNldFRyYW5zZm9ybShyZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvLCAwLCAwLCByZW5kZXIub3B0aW9ucy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy53aXJlZnJhbWVzIHx8IChlbmdpbmUuZW5hYmxlU2xlZXBpbmcgJiYgb3B0aW9ucy5zaG93U2xlZXBpbmcpKSB7XG4gICAgICAgICAgICAvLyBmdWxseSBmZWF0dXJlZCByZW5kZXJpbmcgb2YgYm9kaWVzXG4gICAgICAgICAgICBSZW5kZXIuYm9kaWVzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dDb252ZXhIdWxscylcbiAgICAgICAgICAgICAgICBSZW5kZXIuYm9keUNvbnZleEh1bGxzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgLy8gb3B0aW1pc2VkIG1ldGhvZCBmb3Igd2lyZWZyYW1lcyBvbmx5XG4gICAgICAgICAgICBSZW5kZXIuYm9keVdpcmVmcmFtZXMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd0JvdW5kcylcbiAgICAgICAgICAgIFJlbmRlci5ib2R5Qm91bmRzKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93QXhlcyB8fCBvcHRpb25zLnNob3dBbmdsZUluZGljYXRvcilcbiAgICAgICAgICAgIFJlbmRlci5ib2R5QXhlcyhyZW5kZXIsIGJvZGllcywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Bvc2l0aW9ucylcbiAgICAgICAgICAgIFJlbmRlci5ib2R5UG9zaXRpb25zKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93VmVsb2NpdHkpXG4gICAgICAgICAgICBSZW5kZXIuYm9keVZlbG9jaXR5KHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93SWRzKVxuICAgICAgICAgICAgUmVuZGVyLmJvZHlJZHMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dTZXBhcmF0aW9ucylcbiAgICAgICAgICAgIFJlbmRlci5zZXBhcmF0aW9ucyhyZW5kZXIsIGVuZ2luZS5wYWlycy5saXN0LCBjb250ZXh0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zaG93Q29sbGlzaW9ucylcbiAgICAgICAgICAgIFJlbmRlci5jb2xsaXNpb25zKHJlbmRlciwgZW5naW5lLnBhaXJzLmxpc3QsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dWZXJ0ZXhOdW1iZXJzKVxuICAgICAgICAgICAgUmVuZGVyLnZlcnRleE51bWJlcnMocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNob3dNb3VzZVBvc2l0aW9uKVxuICAgICAgICAgICAgUmVuZGVyLm1vdXNlUG9zaXRpb24ocmVuZGVyLCByZW5kZXIubW91c2UsIGNvbnRleHQpO1xuXG4gICAgICAgIFJlbmRlci5jb25zdHJhaW50cyhjb25zdHJhaW50cywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKSB7XG4gICAgICAgICAgICAvLyByZXZlcnQgdmlldyB0cmFuc2Zvcm1zXG4gICAgICAgICAgICBSZW5kZXIuZW5kVmlld1RyYW5zZm9ybShyZW5kZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocmVuZGVyLCAnYWZ0ZXJSZW5kZXInLCBldmVudCk7XG5cbiAgICAgICAgLy8gbG9nIHRoZSB0aW1lIGVsYXBzZWQgY29tcHV0aW5nIHRoaXMgdXBkYXRlXG4gICAgICAgIHRpbWluZy5sYXN0RWxhcHNlZCA9IENvbW1vbi5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBzdGF0aXN0aWNzIGFib3V0IHRoZSBlbmdpbmUgYW5kIHdvcmxkIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBzdGF0c1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICAgICAqL1xuICAgIFJlbmRlci5zdGF0cyA9IGZ1bmN0aW9uKHJlbmRlciwgY29udGV4dCwgdGltZSkge1xuICAgICAgICB2YXIgZW5naW5lID0gcmVuZGVyLmVuZ2luZSxcbiAgICAgICAgICAgIHdvcmxkID0gZW5naW5lLndvcmxkLFxuICAgICAgICAgICAgYm9kaWVzID0gQ29tcG9zaXRlLmFsbEJvZGllcyh3b3JsZCksXG4gICAgICAgICAgICBwYXJ0cyA9IDAsXG4gICAgICAgICAgICB3aWR0aCA9IDU1LFxuICAgICAgICAgICAgaGVpZ2h0ID0gNDQsXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICBcbiAgICAgICAgLy8gY291bnQgcGFydHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHBhcnRzICs9IGJvZGllc1tpXS5wYXJ0cy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWN0aW9uc1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSB7XG4gICAgICAgICAgICAnUGFydCc6IHBhcnRzLFxuICAgICAgICAgICAgJ0JvZHknOiBib2RpZXMubGVuZ3RoLFxuICAgICAgICAgICAgJ0NvbnMnOiBDb21wb3NpdGUuYWxsQ29uc3RyYWludHMod29ybGQpLmxlbmd0aCxcbiAgICAgICAgICAgICdDb21wJzogQ29tcG9zaXRlLmFsbENvbXBvc2l0ZXMod29ybGQpLmxlbmd0aCxcbiAgICAgICAgICAgICdQYWlyJzogZW5naW5lLnBhaXJzLmxpc3QubGVuZ3RoXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYmFja2dyb3VuZFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMGUwZjE5JztcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCB3aWR0aCAqIDUuNSwgaGVpZ2h0KTtcblxuICAgICAgICBjb250ZXh0LmZvbnQgPSAnMTJweCBBcmlhbCc7XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcblxuICAgICAgICAvLyBzZWN0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gc2VjdGlvbnNba2V5XTtcbiAgICAgICAgICAgIC8vIGxhYmVsXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjYWFhJztcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoa2V5LCB4ICsgd2lkdGgsIHkgKyA4KTtcblxuICAgICAgICAgICAgLy8gdmFsdWVcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNlZWUnO1xuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChzZWN0aW9uLCB4ICsgd2lkdGgsIHkgKyAyNik7XG5cbiAgICAgICAgICAgIHggKz0gd2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBlbmdpbmUgYW5kIHJlbmRlciBwZXJmb3JtYW5jZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgcGVyZm9ybWFuY2VcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLnBlcmZvcm1hbmNlID0gZnVuY3Rpb24ocmVuZGVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgdGltaW5nID0gcmVuZGVyLnRpbWluZyxcbiAgICAgICAgICAgIGRlbHRhSGlzdG9yeSA9IHRpbWluZy5kZWx0YUhpc3RvcnksXG4gICAgICAgICAgICBlbGFwc2VkSGlzdG9yeSA9IHRpbWluZy5lbGFwc2VkSGlzdG9yeSxcbiAgICAgICAgICAgIHRpbWVzdGFtcEVsYXBzZWRIaXN0b3J5ID0gdGltaW5nLnRpbWVzdGFtcEVsYXBzZWRIaXN0b3J5LFxuICAgICAgICAgICAgZW5naW5lRGVsdGFIaXN0b3J5ID0gdGltaW5nLmVuZ2luZURlbHRhSGlzdG9yeSxcbiAgICAgICAgICAgIGVuZ2luZUVsYXBzZWRIaXN0b3J5ID0gdGltaW5nLmVuZ2luZUVsYXBzZWRIaXN0b3J5LFxuICAgICAgICAgICAgbGFzdEVuZ2luZURlbHRhID0gZW5naW5lLnRpbWluZy5sYXN0RGVsdGE7XG4gICAgICAgIFxuICAgICAgICB2YXIgZGVsdGFNZWFuID0gX21lYW4oZGVsdGFIaXN0b3J5KSxcbiAgICAgICAgICAgIGVsYXBzZWRNZWFuID0gX21lYW4oZWxhcHNlZEhpc3RvcnkpLFxuICAgICAgICAgICAgZW5naW5lRGVsdGFNZWFuID0gX21lYW4oZW5naW5lRGVsdGFIaXN0b3J5KSxcbiAgICAgICAgICAgIGVuZ2luZUVsYXBzZWRNZWFuID0gX21lYW4oZW5naW5lRWxhcHNlZEhpc3RvcnkpLFxuICAgICAgICAgICAgdGltZXN0YW1wRWxhcHNlZE1lYW4gPSBfbWVhbih0aW1lc3RhbXBFbGFwc2VkSGlzdG9yeSksXG4gICAgICAgICAgICByYXRlTWVhbiA9ICh0aW1lc3RhbXBFbGFwc2VkTWVhbiAvIGRlbHRhTWVhbikgfHwgMCxcbiAgICAgICAgICAgIGZwcyA9ICgxMDAwIC8gZGVsdGFNZWFuKSB8fCAwO1xuXG4gICAgICAgIHZhciBncmFwaEhlaWdodCA9IDQsXG4gICAgICAgICAgICBnYXAgPSAxMixcbiAgICAgICAgICAgIHdpZHRoID0gNjAsXG4gICAgICAgICAgICBoZWlnaHQgPSAzNCxcbiAgICAgICAgICAgIHggPSAxMCxcbiAgICAgICAgICAgIHkgPSA2OTtcblxuICAgICAgICAvLyBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwZTBmMTknO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDUwLCBnYXAgKiA0ICsgd2lkdGggKiA1ICsgMjIsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gc2hvdyBGUFNcbiAgICAgICAgUmVuZGVyLnN0YXR1cyhcbiAgICAgICAgICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBncmFwaEhlaWdodCwgZGVsdGFIaXN0b3J5Lmxlbmd0aCwgXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGZwcykgKyAnIGZwcycsIFxuICAgICAgICAgICAgZnBzIC8gUmVuZGVyLl9nb29kRnBzLFxuICAgICAgICAgICAgZnVuY3Rpb24oaSkgeyByZXR1cm4gKGRlbHRhSGlzdG9yeVtpXSAvIGRlbHRhTWVhbikgLSAxOyB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gc2hvdyBlbmdpbmUgZGVsdGFcbiAgICAgICAgUmVuZGVyLnN0YXR1cyhcbiAgICAgICAgICAgIGNvbnRleHQsIHggKyBnYXAgKyB3aWR0aCwgeSwgd2lkdGgsIGdyYXBoSGVpZ2h0LCBlbmdpbmVEZWx0YUhpc3RvcnkubGVuZ3RoLFxuICAgICAgICAgICAgbGFzdEVuZ2luZURlbHRhLnRvRml4ZWQoMikgKyAnIGR0JywgXG4gICAgICAgICAgICBSZW5kZXIuX2dvb2REZWx0YSAvIGxhc3RFbmdpbmVEZWx0YSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIChlbmdpbmVEZWx0YUhpc3RvcnlbaV0gLyBlbmdpbmVEZWx0YU1lYW4pIC0gMTsgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNob3cgZW5naW5lIHVwZGF0ZSB0aW1lXG4gICAgICAgIFJlbmRlci5zdGF0dXMoXG4gICAgICAgICAgICBjb250ZXh0LCB4ICsgKGdhcCArIHdpZHRoKSAqIDIsIHksIHdpZHRoLCBncmFwaEhlaWdodCwgZW5naW5lRWxhcHNlZEhpc3RvcnkubGVuZ3RoLFxuICAgICAgICAgICAgZW5naW5lRWxhcHNlZE1lYW4udG9GaXhlZCgyKSArICcgdXQnLCBcbiAgICAgICAgICAgIDEgLSAoZW5naW5lRWxhcHNlZE1lYW4gLyBSZW5kZXIuX2dvb2RGcHMpLFxuICAgICAgICAgICAgZnVuY3Rpb24oaSkgeyByZXR1cm4gKGVuZ2luZUVsYXBzZWRIaXN0b3J5W2ldIC8gZW5naW5lRWxhcHNlZE1lYW4pIC0gMTsgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNob3cgcmVuZGVyIHRpbWVcbiAgICAgICAgUmVuZGVyLnN0YXR1cyhcbiAgICAgICAgICAgIGNvbnRleHQsIHggKyAoZ2FwICsgd2lkdGgpICogMywgeSwgd2lkdGgsIGdyYXBoSGVpZ2h0LCBlbGFwc2VkSGlzdG9yeS5sZW5ndGgsXG4gICAgICAgICAgICBlbGFwc2VkTWVhbi50b0ZpeGVkKDIpICsgJyBydCcsIFxuICAgICAgICAgICAgMSAtIChlbGFwc2VkTWVhbiAvIFJlbmRlci5fZ29vZEZwcyksXG4gICAgICAgICAgICBmdW5jdGlvbihpKSB7IHJldHVybiAoZWxhcHNlZEhpc3RvcnlbaV0gLyBlbGFwc2VkTWVhbikgLSAxOyB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gc2hvdyBlZmZlY3RpdmUgc3BlZWRcbiAgICAgICAgUmVuZGVyLnN0YXR1cyhcbiAgICAgICAgICAgIGNvbnRleHQsIHggKyAoZ2FwICsgd2lkdGgpICogNCwgeSwgd2lkdGgsIGdyYXBoSGVpZ2h0LCB0aW1lc3RhbXBFbGFwc2VkSGlzdG9yeS5sZW5ndGgsIFxuICAgICAgICAgICAgcmF0ZU1lYW4udG9GaXhlZCgyKSArICcgeCcsIFxuICAgICAgICAgICAgcmF0ZU1lYW4gKiByYXRlTWVhbiAqIHJhdGVNZWFuLFxuICAgICAgICAgICAgZnVuY3Rpb24oaSkgeyByZXR1cm4gKCgodGltZXN0YW1wRWxhcHNlZEhpc3RvcnlbaV0gLyBkZWx0YUhpc3RvcnlbaV0pIC8gcmF0ZU1lYW4pIHx8IDApIC0gMTsgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgbGFiZWwsIGluZGljYXRvciBhbmQgYSBjaGFydC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2Qgc3RhdHVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5kaWNhdG9yXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcGxvdFlcbiAgICAgKi9cbiAgICBSZW5kZXIuc3RhdHVzID0gZnVuY3Rpb24oY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY291bnQsIGxhYmVsLCBpbmRpY2F0b3IsIHBsb3RZKSB7XG4gICAgICAgIC8vIGJhY2tncm91bmRcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICcjODg4JztcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzQ0NCc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5ICsgNywgd2lkdGgsIDEpO1xuXG4gICAgICAgIC8vIGNoYXJ0XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkgKyA3IC0gaGVpZ2h0ICogQ29tbW9uLmNsYW1wKDAuNCAqIHBsb3RZKDApLCAtMiwgMikpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHggKyBpLCB5ICsgNyAtIChpIDwgY291bnQgPyBoZWlnaHQgKiBDb21tb24uY2xhbXAoMC40ICogcGxvdFkoaSksIC0yLCAyKSA6IDApKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIGluZGljYXRvclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdoc2woJyArIENvbW1vbi5jbGFtcCgyNSArIDk1ICogaW5kaWNhdG9yLCAwLCAxMjApICsgJywxMDAlLDYwJSknO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHkgLSA3LCA0LCA0KTtcblxuICAgICAgICAvLyBsYWJlbFxuICAgICAgICBjb250ZXh0LmZvbnQgPSAnMTJweCBBcmlhbCc7XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2VlZSc7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobGFiZWwsIHggKyB3aWR0aCwgeSAtIDUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBjb25zdHJhaW50c1xuICAgICAqIEBwYXJhbSB7Y29uc3RyYWludFtdfSBjb25zdHJhaW50c1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5jb25zdHJhaW50cyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWNvbnN0cmFpbnQucmVuZGVyLnZpc2libGUgfHwgIWNvbnN0cmFpbnQucG9pbnRBIHx8ICFjb25zdHJhaW50LnBvaW50QilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGJvZHlBID0gY29uc3RyYWludC5ib2R5QSxcbiAgICAgICAgICAgICAgICBib2R5QiA9IGNvbnN0cmFpbnQuYm9keUIsXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kO1xuXG4gICAgICAgICAgICBpZiAoYm9keUEpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IFZlY3Rvci5hZGQoYm9keUEucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRBKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBjb25zdHJhaW50LnBvaW50QTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQucmVuZGVyLnR5cGUgPT09ICdwaW4nKSB7XG4gICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjLmFyYyhzdGFydC54LCBzdGFydC55LCAzLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IFZlY3Rvci5hZGQoYm9keUIucG9zaXRpb24sIGNvbnN0cmFpbnQucG9pbnRCKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBjb25zdHJhaW50LnBvaW50QjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQucmVuZGVyLnR5cGUgPT09ICdzcHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IFZlY3Rvci5zdWIoZW5kLCBzdGFydCksXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBWZWN0b3IucGVycChWZWN0b3Iubm9ybWFsaXNlKGRlbHRhKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2lscyA9IE1hdGguY2VpbChDb21tb24uY2xhbXAoY29uc3RyYWludC5sZW5ndGggLyA1LCAxMiwgMjApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGNvaWxzOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGogJSAyID09PSAwID8gMSA6IC0xO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydC54ICsgZGVsdGEueCAqIChqIC8gY29pbHMpICsgbm9ybWFsLnggKiBvZmZzZXQgKiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnkgKyBkZWx0YS55ICogKGogLyBjb2lscykgKyBub3JtYWwueSAqIG9mZnNldCAqIDRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjLmxpbmVUbyhlbmQueCwgZW5kLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5yZW5kZXIubGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgYy5saW5lV2lkdGggPSBjb25zdHJhaW50LnJlbmRlci5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9IGNvbnN0cmFpbnQucmVuZGVyLnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LnJlbmRlci5hbmNob3JzKSB7XG4gICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSBjb25zdHJhaW50LnJlbmRlci5zdHJva2VTdHlsZTtcbiAgICAgICAgICAgICAgICBjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMuYXJjKHN0YXJ0LngsIHN0YXJ0LnksIDMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjLmFyYyhlbmQueCwgZW5kLnksIDMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGMuZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZGllc1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZGllcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlcyA9IG9wdGlvbnMuc2hvd0ludGVybmFsRWRnZXMgfHwgIW9wdGlvbnMud2lyZWZyYW1lcyxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgY29tcG91bmQgcGFydHNcbiAgICAgICAgICAgIGZvciAoayA9IGJvZHkucGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBrIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dTbGVlcGluZyAmJiBib2R5LmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5nbG9iYWxBbHBoYSA9IDAuNSAqIHBhcnQucmVuZGVyLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnJlbmRlci5vcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSBwYXJ0LnJlbmRlci5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnJlbmRlci5zcHJpdGUgJiYgcGFydC5yZW5kZXIuc3ByaXRlLnRleHR1cmUgJiYgIW9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0IHNwcml0ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gcGFydC5yZW5kZXIuc3ByaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IF9nZXRUZXh0dXJlKHJlbmRlciwgc3ByaXRlLnRleHR1cmUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGMudHJhbnNsYXRlKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICAgICAgYy5yb3RhdGUocGFydC5hbmdsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYy5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS53aWR0aCAqIC1zcHJpdGUueE9mZnNldCAqIHNwcml0ZS54U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmhlaWdodCAqIC1zcHJpdGUueU9mZnNldCAqIHNwcml0ZS55U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLndpZHRoICogc3ByaXRlLnhTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ICogc3ByaXRlLnlTY2FsZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldmVydCB0cmFuc2xhdGlvbiwgaG9wZWZ1bGx5IGZhc3RlciB0aGFuIHNhdmUgLyByZXN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGMucm90YXRlKC1wYXJ0LmFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgYy50cmFuc2xhdGUoLXBhcnQucG9zaXRpb24ueCwgLXBhcnQucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFydCBwb2x5Z29uXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LmNpcmNsZVJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuYXJjKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55LCBwYXJ0LmNpcmNsZVJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbMF0ueCwgcGFydC52ZXJ0aWNlc1swXS55KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBwYXJ0LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0LnZlcnRpY2VzW2ogLSAxXS5pc0ludGVybmFsIHx8IHNob3dJbnRlcm5hbEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzW2pdLngsIHBhcnQudmVydGljZXNbal0ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQudmVydGljZXNbal0uaXNJbnRlcm5hbCAmJiAhc2hvd0ludGVybmFsRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5tb3ZlVG8ocGFydC52ZXJ0aWNlc1soaiArIDEpICUgcGFydC52ZXJ0aWNlcy5sZW5ndGhdLngsIHBhcnQudmVydGljZXNbKGogKyAxKSAlIHBhcnQudmVydGljZXMubGVuZ3RoXS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbMF0ueCwgcGFydC52ZXJ0aWNlc1swXS55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSBwYXJ0LnJlbmRlci5maWxsU3R5bGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnJlbmRlci5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IHBhcnQucmVuZGVyLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gcGFydC5yZW5kZXIuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYy5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJyNiYmInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGMuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXNlZCBtZXRob2QgZm9yIGRyYXdpbmcgYm9keSB3aXJlZnJhbWVzIGluIG9uZSBwYXNzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlXaXJlZnJhbWVzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVdpcmVmcmFtZXMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBzaG93SW50ZXJuYWxFZGdlcyA9IHJlbmRlci5vcHRpb25zLnNob3dJbnRlcm5hbEVkZ2VzLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGs7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgYWxsIGJvZGllc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBjb21wb3VuZCBwYXJ0c1xuICAgICAgICAgICAgZm9yIChrID0gYm9keS5wYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBib2R5LnBhcnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IGJvZHkucGFydHNba107XG5cbiAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWzBdLngsIHBhcnQudmVydGljZXNbMF0ueSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgcGFydC52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQudmVydGljZXNbaiAtIDFdLmlzSW50ZXJuYWwgfHwgc2hvd0ludGVybmFsRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQudmVydGljZXNbal0ueCwgcGFydC52ZXJ0aWNlc1tqXS55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnZlcnRpY2VzW2pdLmlzSW50ZXJuYWwgJiYgIXNob3dJbnRlcm5hbEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnZlcnRpY2VzWyhqICsgMSkgJSBwYXJ0LnZlcnRpY2VzLmxlbmd0aF0ueCwgcGFydC52ZXJ0aWNlc1soaiArIDEpICUgcGFydC52ZXJ0aWNlcy5sZW5ndGhdLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYy5saW5lVG8ocGFydC52ZXJ0aWNlc1swXS54LCBwYXJ0LnZlcnRpY2VzWzBdLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZVN0eWxlID0gJyNiYmInO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPcHRpbWlzZWQgbWV0aG9kIGZvciBkcmF3aW5nIGJvZHkgY29udmV4IGh1bGwgd2lyZWZyYW1lcyBpbiBvbmUgcGFzc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5Q29udmV4SHVsbHNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5Q29udmV4SHVsbHMgPSBmdW5jdGlvbihyZW5kZXIsIGJvZGllcywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaztcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBjb252ZXggaHVsbHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlIHx8IGJvZHkucGFydHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5LnZlcnRpY2VzWzBdLngsIGJvZHkudmVydGljZXNbMF0ueSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBib2R5LnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYy5saW5lVG8oYm9keS52ZXJ0aWNlc1tqXS54LCBib2R5LnZlcnRpY2VzW2pdLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5LnZlcnRpY2VzWzBdLngsIGJvZHkudmVydGljZXNbMF0ueSk7XG4gICAgICAgIH1cblxuICAgICAgICBjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjIpJztcbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBib2R5IHZlcnRleCBudW1iZXJzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCB2ZXJ0ZXhOdW1iZXJzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIudmVydGV4TnVtYmVycyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgaztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBib2RpZXNbaV0ucGFydHM7XG4gICAgICAgICAgICBmb3IgKGsgPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGsgPCBwYXJ0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNba107XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhcnQudmVydGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjIpJztcbiAgICAgICAgICAgICAgICAgICAgYy5maWxsVGV4dChpICsgJ18nICsgaiwgcGFydC5wb3NpdGlvbi54ICsgKHBhcnQudmVydGljZXNbal0ueCAtIHBhcnQucG9zaXRpb24ueCkgKiAwLjgsIHBhcnQucG9zaXRpb24ueSArIChwYXJ0LnZlcnRpY2VzW2pdLnkgLSBwYXJ0LnBvc2l0aW9uLnkpICogMC44KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBtb3VzZSBwb3NpdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgbW91c2VQb3NpdGlvblxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge21vdXNlfSBtb3VzZVxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5tb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24ocmVuZGVyLCBtb3VzZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQ7XG4gICAgICAgIGMuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC44KSc7XG4gICAgICAgIGMuZmlsbFRleHQobW91c2UucG9zaXRpb24ueCArICcgICcgKyBtb3VzZS5wb3NpdGlvbi55LCBtb3VzZS5wb3NpdGlvbi54ICsgNSwgbW91c2UucG9zaXRpb24ueSAtIDUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5Qm91bmRzXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keUJvdW5kcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnM7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChib2R5LnJlbmRlci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gYm9kaWVzW2ldLnBhcnRzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBwYXJ0cy5sZW5ndGggPiAxID8gMSA6IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjLnJlY3QocGFydC5ib3VuZHMubWluLngsIHBhcnQuYm91bmRzLm1pbi55LCBwYXJ0LmJvdW5kcy5tYXgueCAtIHBhcnQuYm91bmRzLm1pbi54LCBwYXJ0LmJvdW5kcy5tYXgueSAtIHBhcnQuYm91bmRzLm1pbi55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsMC4wOCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IGFuZ2xlIGluZGljYXRvcnMgYW5kIGF4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYm9keUF4ZXNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5QXhlcyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgcGFydHMgPSBib2R5LnBhcnRzO1xuXG4gICAgICAgICAgICBpZiAoIWJvZHkucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dBeGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGFsbCBheGVzXG4gICAgICAgICAgICAgICAgZm9yIChqID0gcGFydHMubGVuZ3RoID4gMSA/IDEgOiAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcGFydC5heGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHBhcnQuYXhlc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMubGluZVRvKHBhcnQucG9zaXRpb24ueCArIGF4aXMueCAqIDIwLCBwYXJ0LnBvc2l0aW9uLnkgKyBheGlzLnkgKiAyMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHBhcnQuYXhlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGEgc2luZ2xlIGF4aXMgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhwYXJ0LnBvc2l0aW9uLngsIHBhcnQucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmxpbmVUbygocGFydC52ZXJ0aWNlc1swXS54ICsgcGFydC52ZXJ0aWNlc1twYXJ0LnZlcnRpY2VzLmxlbmd0aC0xXS54KSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnQudmVydGljZXNbMF0ueSArIHBhcnQudmVydGljZXNbcGFydC52ZXJ0aWNlcy5sZW5ndGgtMV0ueSkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAnaW5kaWFucmVkJztcbiAgICAgICAgICAgIGMubGluZVdpZHRoID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjQpJztcbiAgICAgICAgICAgIGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ292ZXJsYXknO1xuICAgICAgICAgICAgYy5saW5lV2lkdGggPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICAgICAgYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBib2R5UG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7Ym9keVtdfSBib2RpZXNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuYm9keVBvc2l0aW9ucyA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIGVuZ2luZSA9IHJlbmRlci5lbmdpbmUsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBrO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGN1cnJlbnQgcG9zaXRpb25zXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgICAgIGlmICghYm9keS5yZW5kZXIudmlzaWJsZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gaGFuZGxlIGNvbXBvdW5kIHBhcnRzXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgYm9keS5wYXJ0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBib2R5LnBhcnRzW2tdO1xuICAgICAgICAgICAgICAgIGMuYXJjKHBhcnQucG9zaXRpb24ueCwgcGFydC5wb3NpdGlvbi55LCAzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdpbmRpYW5yZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwLjUpJztcbiAgICAgICAgfVxuICAgICAgICBjLmZpbGwoKTtcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlbmRlciBwcmV2aW91cyBwb3NpdGlvbnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIGlmIChib2R5LnJlbmRlci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgYy5hcmMoYm9keS5wb3NpdGlvblByZXYueCwgYm9keS5wb3NpdGlvblByZXYueSwgMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC44KSc7XG4gICAgICAgIGMuZmlsbCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib2R5IHZlbG9jaXR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlWZWxvY2l0eVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge2JvZHlbXX0gYm9kaWVzXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0fSBjb250ZXh0XG4gICAgICovXG4gICAgUmVuZGVyLmJvZHlWZWxvY2l0eSA9IGZ1bmN0aW9uKHJlbmRlciwgYm9kaWVzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dDtcblxuICAgICAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgaWYgKCFib2R5LnJlbmRlci52aXNpYmxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSBCb2R5LmdldFZlbG9jaXR5KGJvZHkpO1xuXG4gICAgICAgICAgICBjLm1vdmVUbyhib2R5LnBvc2l0aW9uLngsIGJvZHkucG9zaXRpb24ueSk7XG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5LnBvc2l0aW9uLnggKyB2ZWxvY2l0eS54LCBib2R5LnBvc2l0aW9uLnkgKyB2ZWxvY2l0eS55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMubGluZVdpZHRoID0gMztcbiAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdjb3JuZmxvd2VyYmx1ZSc7XG4gICAgICAgIGMuc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvZHkgaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJvZHlJZHNcbiAgICAgKiBAcGFyYW0ge3JlbmRlcn0gcmVuZGVyXG4gICAgICogQHBhcmFtIHtib2R5W119IGJvZGllc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5ib2R5SWRzID0gZnVuY3Rpb24ocmVuZGVyLCBib2RpZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGMgPSBjb250ZXh0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFib2RpZXNbaV0ucmVuZGVyLnZpc2libGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGJvZGllc1tpXS5wYXJ0cztcbiAgICAgICAgICAgIGZvciAoaiA9IHBhcnRzLmxlbmd0aCA+IDEgPyAxIDogMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICBjLmZvbnQgPSBcIjEycHggQXJpYWxcIjtcbiAgICAgICAgICAgICAgICBjLmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknO1xuICAgICAgICAgICAgICAgIGMuZmlsbFRleHQocGFydC5pZCwgcGFydC5wb3NpdGlvbi54ICsgMTAsIHBhcnQucG9zaXRpb24ueSAtIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBjb2xsaXNpb25zXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7cGFpcltdfSBwYWlyc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5jb2xsaXNpb25zID0gZnVuY3Rpb24ocmVuZGVyLCBwYWlycywgY29udGV4dCkge1xuICAgICAgICB2YXIgYyA9IGNvbnRleHQsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBwYWlyLFxuICAgICAgICAgICAgY29sbGlzaW9uLFxuICAgICAgICAgICAgY29ycmVjdGVkLFxuICAgICAgICAgICAgYm9keUEsXG4gICAgICAgICAgICBib2R5QixcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBqO1xuXG4gICAgICAgIGMuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGNvbGxpc2lvbiBwb3NpdGlvbnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XG5cbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGFpci5hY3RpdmVDb250YWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gcGFpci5hY3RpdmVDb250YWN0c1tqXSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gY29udGFjdC52ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgYy5yZWN0KHZlcnRleC54IC0gMS41LCB2ZXJ0ZXgueSAtIDEuNSwgMy41LCAzLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2lyZWZyYW1lcykge1xuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwwLjcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMuZmlsbFN0eWxlID0gJ29yYW5nZSc7XG4gICAgICAgIH1cbiAgICAgICAgYy5maWxsKCk7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgY29sbGlzaW9uIG5vcm1hbHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XG5cbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG5cbiAgICAgICAgICAgIGlmIChwYWlyLmFjdGl2ZUNvbnRhY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsUG9zWCA9IHBhaXIuYWN0aXZlQ29udGFjdHNbMF0udmVydGV4LngsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFBvc1kgPSBwYWlyLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC55O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhaXIuYWN0aXZlQ29udGFjdHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFBvc1ggPSAocGFpci5hY3RpdmVDb250YWN0c1swXS52ZXJ0ZXgueCArIHBhaXIuYWN0aXZlQ29udGFjdHNbMV0udmVydGV4LngpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsUG9zWSA9IChwYWlyLmFjdGl2ZUNvbnRhY3RzWzBdLnZlcnRleC55ICsgcGFpci5hY3RpdmVDb250YWN0c1sxXS52ZXJ0ZXgueSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb24uYm9keUIgPT09IGNvbGxpc2lvbi5zdXBwb3J0c1swXS5ib2R5IHx8IGNvbGxpc2lvbi5ib2R5QS5pc1N0YXRpYyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjLm1vdmVUbyhub3JtYWxQb3NYIC0gY29sbGlzaW9uLm5vcm1hbC54ICogOCwgbm9ybWFsUG9zWSAtIGNvbGxpc2lvbi5ub3JtYWwueSAqIDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMubW92ZVRvKG5vcm1hbFBvc1ggKyBjb2xsaXNpb24ubm9ybWFsLnggKiA4LCBub3JtYWxQb3NZICsgY29sbGlzaW9uLm5vcm1hbC55ICogOCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYy5saW5lVG8obm9ybWFsUG9zWCwgbm9ybWFsUG9zWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy53aXJlZnJhbWVzKSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuNyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYy5zdHJva2VTdHlsZSA9ICdvcmFuZ2UnO1xuICAgICAgICB9XG5cbiAgICAgICAgYy5saW5lV2lkdGggPSAxO1xuICAgICAgICBjLnN0cm9rZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmlwdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBzZXBhcmF0aW9uc1xuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge3BhaXJbXX0gcGFpcnNcbiAgICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBSZW5kZXIuc2VwYXJhdGlvbnMgPSBmdW5jdGlvbihyZW5kZXIsIHBhaXJzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjID0gY29udGV4dCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZW5kZXIub3B0aW9ucyxcbiAgICAgICAgICAgIHBhaXIsXG4gICAgICAgICAgICBjb2xsaXNpb24sXG4gICAgICAgICAgICBjb3JyZWN0ZWQsXG4gICAgICAgICAgICBib2R5QSxcbiAgICAgICAgICAgIGJvZHlCLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGo7XG5cbiAgICAgICAgYy5iZWdpblBhdGgoKTtcblxuICAgICAgICAvLyByZW5kZXIgc2VwYXJhdGlvbnNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWlyID0gcGFpcnNbaV07XG5cbiAgICAgICAgICAgIGlmICghcGFpci5pc0FjdGl2ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY29sbGlzaW9uID0gcGFpci5jb2xsaXNpb247XG4gICAgICAgICAgICBib2R5QSA9IGNvbGxpc2lvbi5ib2R5QTtcbiAgICAgICAgICAgIGJvZHlCID0gY29sbGlzaW9uLmJvZHlCO1xuXG4gICAgICAgICAgICB2YXIgayA9IDE7XG5cbiAgICAgICAgICAgIGlmICghYm9keUIuaXNTdGF0aWMgJiYgIWJvZHlBLmlzU3RhdGljKSBrID0gMC41O1xuICAgICAgICAgICAgaWYgKGJvZHlCLmlzU3RhdGljKSBrID0gMDtcblxuICAgICAgICAgICAgYy5tb3ZlVG8oYm9keUIucG9zaXRpb24ueCwgYm9keUIucG9zaXRpb24ueSk7XG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5Qi5wb3NpdGlvbi54IC0gY29sbGlzaW9uLnBlbmV0cmF0aW9uLnggKiBrLCBib2R5Qi5wb3NpdGlvbi55IC0gY29sbGlzaW9uLnBlbmV0cmF0aW9uLnkgKiBrKTtcblxuICAgICAgICAgICAgayA9IDE7XG5cbiAgICAgICAgICAgIGlmICghYm9keUIuaXNTdGF0aWMgJiYgIWJvZHlBLmlzU3RhdGljKSBrID0gMC41O1xuICAgICAgICAgICAgaWYgKGJvZHlBLmlzU3RhdGljKSBrID0gMDtcblxuICAgICAgICAgICAgYy5tb3ZlVG8oYm9keUEucG9zaXRpb24ueCwgYm9keUEucG9zaXRpb24ueSk7XG4gICAgICAgICAgICBjLmxpbmVUbyhib2R5QS5wb3NpdGlvbi54ICsgY29sbGlzaW9uLnBlbmV0cmF0aW9uLnggKiBrLCBib2R5QS5wb3NpdGlvbi55ICsgY29sbGlzaW9uLnBlbmV0cmF0aW9uLnkgKiBrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLndpcmVmcmFtZXMpIHtcbiAgICAgICAgICAgIGMuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC41KSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjLnN0cm9rZVN0eWxlID0gJ29yYW5nZSc7XG4gICAgICAgIH1cbiAgICAgICAgYy5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgaW5zcGVjdG9yXG4gICAgICogQHBhcmFtIHtpbnNwZWN0b3J9IGluc3BlY3RvclxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dH0gY29udGV4dFxuICAgICAqL1xuICAgIFJlbmRlci5pbnNwZWN0b3IgPSBmdW5jdGlvbihpbnNwZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGVuZ2luZSA9IGluc3BlY3Rvci5lbmdpbmUsXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGluc3BlY3Rvci5zZWxlY3RlZCxcbiAgICAgICAgICAgIHJlbmRlciA9IGluc3BlY3Rvci5yZW5kZXIsXG4gICAgICAgICAgICBvcHRpb25zID0gcmVuZGVyLm9wdGlvbnMsXG4gICAgICAgICAgICBib3VuZHM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgYm91bmRzV2lkdGggPSByZW5kZXIuYm91bmRzLm1heC54IC0gcmVuZGVyLmJvdW5kcy5taW4ueCxcbiAgICAgICAgICAgICAgICBib3VuZHNIZWlnaHQgPSByZW5kZXIuYm91bmRzLm1heC55IC0gcmVuZGVyLmJvdW5kcy5taW4ueSxcbiAgICAgICAgICAgICAgICBib3VuZHNTY2FsZVggPSBib3VuZHNXaWR0aCAvIHJlbmRlci5vcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgIGJvdW5kc1NjYWxlWSA9IGJvdW5kc0hlaWdodCAvIHJlbmRlci5vcHRpb25zLmhlaWdodDtcblxuICAgICAgICAgICAgY29udGV4dC5zY2FsZSgxIC8gYm91bmRzU2NhbGVYLCAxIC8gYm91bmRzU2NhbGVZKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1yZW5kZXIuYm91bmRzLm1pbi54LCAtcmVuZGVyLmJvdW5kcy5taW4ueSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdGVkW2ldLmRhdGE7XG5cbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAuNSwgMC41KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsMTY1LDAsMC45KSc7XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLDJdKTtcblxuICAgICAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcblxuICAgICAgICAgICAgY2FzZSAnYm9keSc6XG5cbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgYm9keSBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgYm91bmRzID0gaXRlbS5ib3VuZHM7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoTWF0aC5mbG9vcihib3VuZHMubWluLnggLSAzKSwgTWF0aC5mbG9vcihib3VuZHMubWluLnkgLSAzKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWF4LnggLSBib3VuZHMubWluLnggKyA2KSwgTWF0aC5mbG9vcihib3VuZHMubWF4LnkgLSBib3VuZHMubWluLnkgKyA2KSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0cmFpbnQnOlxuXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGNvbnN0cmFpbnQgc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGl0ZW0ucG9pbnRBO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmJvZHlBKVxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGl0ZW0ucG9pbnRCO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMocG9pbnQueCwgcG9pbnQueSwgMTAsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC0wLjUsIC0wLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVuZGVyIHNlbGVjdGlvbiByZWdpb25cbiAgICAgICAgaWYgKGluc3BlY3Rvci5zZWxlY3RTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMC41LCAwLjUpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwxNjUsMCwwLjYpJztcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDE2NSwwLDAuMSknO1xuICAgICAgICAgICAgYm91bmRzID0gaW5zcGVjdG9yLnNlbGVjdEJvdW5kcztcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoTWF0aC5mbG9vcihib3VuZHMubWluLngpLCBNYXRoLmZsb29yKGJvdW5kcy5taW4ueSksXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcihib3VuZHMubWF4LnggLSBib3VuZHMubWluLngpLCBNYXRoLmZsb29yKGJvdW5kcy5tYXgueSAtIGJvdW5kcy5taW4ueSkpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC0wLjUsIC0wLjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzQm91bmRzKVxuICAgICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgcmVuZGVyIHRpbWluZy5cbiAgICAgKiBAbWV0aG9kIF91cGRhdGVUaW1pbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICAgICAqL1xuICAgIHZhciBfdXBkYXRlVGltaW5nID0gZnVuY3Rpb24ocmVuZGVyLCB0aW1lKSB7XG4gICAgICAgIHZhciBlbmdpbmUgPSByZW5kZXIuZW5naW5lLFxuICAgICAgICAgICAgdGltaW5nID0gcmVuZGVyLnRpbWluZyxcbiAgICAgICAgICAgIGhpc3RvcnlTaXplID0gdGltaW5nLmhpc3RvcnlTaXplLFxuICAgICAgICAgICAgdGltZXN0YW1wID0gZW5naW5lLnRpbWluZy50aW1lc3RhbXA7XG5cbiAgICAgICAgdGltaW5nLmRlbHRhID0gdGltZSAtIHRpbWluZy5sYXN0VGltZSB8fCBSZW5kZXIuX2dvb2REZWx0YTtcbiAgICAgICAgdGltaW5nLmxhc3RUaW1lID0gdGltZTtcblxuICAgICAgICB0aW1pbmcudGltZXN0YW1wRWxhcHNlZCA9IHRpbWVzdGFtcCAtIHRpbWluZy5sYXN0VGltZXN0YW1wIHx8IDA7XG4gICAgICAgIHRpbWluZy5sYXN0VGltZXN0YW1wID0gdGltZXN0YW1wO1xuXG4gICAgICAgIHRpbWluZy5kZWx0YUhpc3RvcnkudW5zaGlmdCh0aW1pbmcuZGVsdGEpO1xuICAgICAgICB0aW1pbmcuZGVsdGFIaXN0b3J5Lmxlbmd0aCA9IE1hdGgubWluKHRpbWluZy5kZWx0YUhpc3RvcnkubGVuZ3RoLCBoaXN0b3J5U2l6ZSk7XG5cbiAgICAgICAgdGltaW5nLmVuZ2luZURlbHRhSGlzdG9yeS51bnNoaWZ0KGVuZ2luZS50aW1pbmcubGFzdERlbHRhKTtcbiAgICAgICAgdGltaW5nLmVuZ2luZURlbHRhSGlzdG9yeS5sZW5ndGggPSBNYXRoLm1pbih0aW1pbmcuZW5naW5lRGVsdGFIaXN0b3J5Lmxlbmd0aCwgaGlzdG9yeVNpemUpO1xuXG4gICAgICAgIHRpbWluZy50aW1lc3RhbXBFbGFwc2VkSGlzdG9yeS51bnNoaWZ0KHRpbWluZy50aW1lc3RhbXBFbGFwc2VkKTtcbiAgICAgICAgdGltaW5nLnRpbWVzdGFtcEVsYXBzZWRIaXN0b3J5Lmxlbmd0aCA9IE1hdGgubWluKHRpbWluZy50aW1lc3RhbXBFbGFwc2VkSGlzdG9yeS5sZW5ndGgsIGhpc3RvcnlTaXplKTtcblxuICAgICAgICB0aW1pbmcuZW5naW5lRWxhcHNlZEhpc3RvcnkudW5zaGlmdChlbmdpbmUudGltaW5nLmxhc3RFbGFwc2VkKTtcbiAgICAgICAgdGltaW5nLmVuZ2luZUVsYXBzZWRIaXN0b3J5Lmxlbmd0aCA9IE1hdGgubWluKHRpbWluZy5lbmdpbmVFbGFwc2VkSGlzdG9yeS5sZW5ndGgsIGhpc3RvcnlTaXplKTtcblxuICAgICAgICB0aW1pbmcuZWxhcHNlZEhpc3RvcnkudW5zaGlmdCh0aW1pbmcubGFzdEVsYXBzZWQpO1xuICAgICAgICB0aW1pbmcuZWxhcHNlZEhpc3RvcnkubGVuZ3RoID0gTWF0aC5taW4odGltaW5nLmVsYXBzZWRIaXN0b3J5Lmxlbmd0aCwgaGlzdG9yeVNpemUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZWFuIHZhbHVlIG9mIHRoZSBnaXZlbiBudW1iZXJzLlxuICAgICAqIEBtZXRob2QgX21lYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHZhbHVlc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdGhlIG1lYW4gb2YgZ2l2ZW4gdmFsdWVzXG4gICAgICovXG4gICAgdmFyIF9tZWFuID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHJlc3VsdCAvIHZhbHVlcy5sZW5ndGgpIHx8IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgX2NyZWF0ZUNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHt9IHdpZHRoXG4gICAgICogQHBhcmFtIHt9IGhlaWdodFxuICAgICAqIEByZXR1cm4gY2FudmFzXG4gICAgICovXG4gICAgdmFyIF9jcmVhdGVDYW52YXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgY2FudmFzLm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgICAqIEBtZXRob2QgX2dldFBpeGVsUmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNhbnZhc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gcGl4ZWwgcmF0aW9cbiAgICAgKi9cbiAgICB2YXIgX2dldFBpeGVsUmF0aW8gPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyA9IGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVBpeGVsUmF0aW87XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlcXVlc3RlZCB0ZXh0dXJlIChhbiBJbWFnZSkgdmlhIGl0cyBwYXRoXG4gICAgICogQG1ldGhvZCBfZ2V0VGV4dHVyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtyZW5kZXJ9IHJlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVBhdGhcbiAgICAgKiBAcmV0dXJuIHtJbWFnZX0gdGV4dHVyZVxuICAgICAqL1xuICAgIHZhciBfZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHJlbmRlciwgaW1hZ2VQYXRoKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IHJlbmRlci50ZXh0dXJlc1tpbWFnZVBhdGhdO1xuXG4gICAgICAgIGlmIChpbWFnZSlcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcblxuICAgICAgICBpbWFnZSA9IHJlbmRlci50ZXh0dXJlc1tpbWFnZVBhdGhdID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IGltYWdlUGF0aDtcblxuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGJhY2tncm91bmQgdG8gdGhlIGNhbnZhcyB1c2luZyBDU1MuXG4gICAgICogQG1ldGhvZCBhcHBseUJhY2tncm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7cmVuZGVyfSByZW5kZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFja2dyb3VuZFxuICAgICAqL1xuICAgIHZhciBfYXBwbHlCYWNrZ3JvdW5kID0gZnVuY3Rpb24ocmVuZGVyLCBiYWNrZ3JvdW5kKSB7XG4gICAgICAgIHZhciBjc3NCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcblxuICAgICAgICBpZiAoLyhqcGd8Z2lmfHBuZykkLy50ZXN0KGJhY2tncm91bmQpKVxuICAgICAgICAgICAgY3NzQmFja2dyb3VuZCA9ICd1cmwoJyArIGJhY2tncm91bmQgKyAnKSc7XG5cbiAgICAgICAgcmVuZGVyLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gY3NzQmFja2dyb3VuZDtcbiAgICAgICAgcmVuZGVyLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IFwiY29udGFpblwiO1xuICAgICAgICByZW5kZXIuY3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIH07XG5cbiAgICAvKlxuICAgICpcbiAgICAqICBFdmVudHMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBiZWZvcmUgcmVuZGVyaW5nXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZVJlbmRlclxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyUmVuZGVyXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgUHJvcGVydGllcyBEb2N1bWVudGF0aW9uXG4gICAgKlxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGJhY2stcmVmZXJlbmNlIHRvIHRoZSBgTWF0dGVyLlJlbmRlcmAgbW9kdWxlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAcHJvcGVydHkgY29udHJvbGxlclxuICAgICAqIEB0eXBlIHJlbmRlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBNYXR0ZXIuRW5naW5lYCBpbnN0YW5jZSB0byBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVuZ2luZVxuICAgICAqIEB0eXBlIGVuZ2luZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgd2hlcmUgdGhlIGNhbnZhcyBpcyB0byBiZSBpbnNlcnRlZCAoaWYgYHJlbmRlci5jYW52YXNgIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZWxlbWVudFxuICAgICAqIEB0eXBlIEhUTUxFbGVtZW50XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRvIHJlbmRlciB0by4gSWYgbm90IHNwZWNpZmllZCwgb25lIHdpbGwgYmUgY3JlYXRlZCBpZiBgcmVuZGVyLmVsZW1lbnRgIGhhcyBiZWVuIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBjYW52YXNcbiAgICAgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudFxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvdW5kc2Agb2JqZWN0IHRoYXQgc3BlY2lmaWVzIHRoZSBkcmF3aW5nIHZpZXcgcmVnaW9uLlxuICAgICAqIFJlbmRlcmluZyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtZWQgYW5kIHNjYWxlZCB0byBmaXQgd2l0aGluIHRoZSBjYW52YXMgc2l6ZSAoYHJlbmRlci5vcHRpb25zLndpZHRoYCBhbmQgYHJlbmRlci5vcHRpb25zLmhlaWdodGApLlxuICAgICAqIFRoaXMgYWxsb3dzIGZvciBjcmVhdGluZyB2aWV3cyB0aGF0IGNhbiBwYW4gb3Igem9vbSBhcm91bmQgdGhlIHNjZW5lLlxuICAgICAqIFlvdSBtdXN0IGFsc28gc2V0IGByZW5kZXIub3B0aW9ucy5oYXNCb3VuZHNgIHRvIGB0cnVlYCB0byBlbmFibGUgYm91bmRlZCByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYm91bmRzXG4gICAgICogQHR5cGUgYm91bmRzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgMmQgcmVuZGVyaW5nIGNvbnRleHQgZnJvbSB0aGUgYHJlbmRlci5jYW52YXNgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29udGV4dFxuICAgICAqIEB0eXBlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNwcml0ZSB0ZXh0dXJlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHRleHR1cmVzXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3VzZSB0byByZW5kZXIgaWYgYHJlbmRlci5vcHRpb25zLnNob3dNb3VzZVBvc2l0aW9uYCBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG1vdXNlXG4gICAgICogQHR5cGUgbW91c2VcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAgICogQHR5cGUge31cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgd2lkdGggaW4gcGl4ZWxzIG9mIHRoZSBgcmVuZGVyLmNhbnZhc2AgdG8gYmUgY3JlYXRlZC5cbiAgICAgKiBTZWUgYWxzbyB0aGUgYG9wdGlvbnMucGl4ZWxSYXRpb2AgcHJvcGVydHkgdG8gY2hhbmdlIHJlbmRlciBxdWFsaXR5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMud2lkdGhcbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCA4MDBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgYHJlbmRlci5jYW52YXNgIHRvIGJlIGNyZWF0ZWQuXG4gICAgICogU2VlIGFsc28gdGhlIGBvcHRpb25zLnBpeGVsUmF0aW9gIHByb3BlcnR5IHRvIGNoYW5nZSByZW5kZXIgcXVhbGl0eS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLmhlaWdodFxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDYwMFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIFtwaXhlbCByYXRpb10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9kZXZpY2VQaXhlbFJhdGlvKSB0byB1c2Ugd2hlbiByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5waXhlbFJhdGlvXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBDU1MgYmFja2dyb3VuZCBjb2xvciBzdHJpbmcgdG8gdXNlIHdoZW4gYHJlbmRlci5vcHRpb25zLndpcmVmcmFtZXNgIGlzIGRpc2FibGVkLlxuICAgICAqIFRoaXMgbWF5IGJlIGFsc28gc2V0IHRvIGAndHJhbnNwYXJlbnQnYCBvciBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuYmFja2dyb3VuZFxuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICcjMTQxNTFmJ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBDU1MgYmFja2dyb3VuZCBjb2xvciBzdHJpbmcgdG8gdXNlIHdoZW4gYHJlbmRlci5vcHRpb25zLndpcmVmcmFtZXNgIGlzIGVuYWJsZWQuXG4gICAgICogVGhpcyBtYXkgYmUgYWxzbyBzZXQgdG8gYCd0cmFuc3BhcmVudCdgIG9yIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy53aXJlZnJhbWVCYWNrZ3JvdW5kXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICogQGRlZmF1bHQgJyMxNDE1MWYnXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdGhhdCBzcGVjaWZpZXMgaWYgYHJlbmRlci5ib3VuZHNgIHNob3VsZCBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuaGFzQm91bmRzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgYWxsIGRlYnVnIGluZm9ybWF0aW9uIG92ZXJsYXlzIHRvZ2V0aGVyLiAgXG4gICAgICogVGhpcyBpbmNsdWRlcyBhbmQgaGFzIHByaW9yaXR5IG92ZXIgdGhlIHZhbHVlcyBvZjpcbiAgICAgKlxuICAgICAqIC0gYHJlbmRlci5vcHRpb25zLnNob3dTdGF0c2BcbiAgICAgKiAtIGByZW5kZXIub3B0aW9ucy5zaG93UGVyZm9ybWFuY2VgXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93RGVidWdcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZW5naW5lIHN0YXRzIGluZm8gb3ZlcmxheS4gIFxuICAgICAqIEZyb20gbGVmdCB0byByaWdodCwgdGhlIHZhbHVlcyBzaG93biBhcmU6XG4gICAgICpcbiAgICAgKiAtIGJvZHkgcGFydHMgdG90YWxcbiAgICAgKiAtIGJvZHkgdG90YWxcbiAgICAgKiAtIGNvbnN0cmFpbnRzIHRvdGFsXG4gICAgICogLSBjb21wb3NpdGVzIHRvdGFsXG4gICAgICogLSBjb2xsaXNpb24gcGFpcnMgdG90YWxcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dTdGF0c1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHBlcmZvcm1hbmNlIGNoYXJ0cy4gIFxuICAgICAqIEZyb20gbGVmdCB0byByaWdodCwgdGhlIHZhbHVlcyBzaG93biBhcmU6XG4gICAgICpcbiAgICAgKiAtIGF2ZXJhZ2UgcmVuZGVyIGZyZXF1ZW5jeSAoZS5nLiA2MCBmcHMpXG4gICAgICogLSBleGFjdCBlbmdpbmUgZGVsdGEgdGltZSB1c2VkIGZvciBsYXN0IHVwZGF0ZSAoZS5nLiAxNi42Nm1zKVxuICAgICAqIC0gYXZlcmFnZSBlbmdpbmUgZXhlY3V0aW9uIGR1cmF0aW9uIChlLmcuIDUuMDBtcylcbiAgICAgKiAtIGF2ZXJhZ2UgcmVuZGVyIGV4ZWN1dGlvbiBkdXJhdGlvbiAoZS5nLiAwLjQwbXMpXG4gICAgICogLSBhdmVyYWdlIGVmZmVjdGl2ZSBwbGF5IHNwZWVkIChlLmcuICcxLjAweCcgaXMgJ3JlYWwtdGltZScpXG4gICAgICpcbiAgICAgKiBFYWNoIHZhbHVlIGlzIHJlY29yZGVkIG92ZXIgYSBmaXhlZCBzYW1wbGUgb2YgcGFzdCBmcmFtZXMgKDYwIGZyYW1lcykuXG4gICAgICpcbiAgICAgKiBBIGNoYXJ0IHNob3duIGJlbG93IGVhY2ggdmFsdWUgaW5kaWNhdGVzIHRoZSB2YXJpYW5jZSBmcm9tIHRoZSBhdmVyYWdlIG92ZXIgdGhlIHNhbXBsZS5cbiAgICAgKiBUaGUgbW9yZSBzdGFibGUgb3IgZml4ZWQgdGhlIHZhbHVlIGlzIHRoZSBmbGF0dGVyIHRoZSBjaGFydCB3aWxsIGFwcGVhci5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dQZXJmb3JtYW5jZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIFxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSByZW5kZXJpbmcgZW50aXJlbHkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5lbmFibGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gdG9nZ2xlIHdpcmVmcmFtZSByZW5kZXJpbmcgb3RoZXJ3aXNlIHNvbGlkIGZpbGwgcmVuZGVyaW5nIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy53aXJlZnJhbWVzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSBzbGVlcGluZyBib2RpZXMgaW5kaWNhdG9ycy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dTbGVlcGluZ1xuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGRlYnVnIGluZm9ybWF0aW9uIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93RGVidWdcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgY29sbGlzaW9uIGJyb2FkcGhhc2UgZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIG5vIGxvbmdlciBpbXBsZW1lbnRlZFxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dCcm9hZHBoYXNlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGJvZHkgYm91bmRzIGRlYnVnIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93Qm91bmRzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGJvZHkgdmVsb2NpdHkgZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dWZWxvY2l0eVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBib2R5IGNvbGxpc2lvbnMgZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dDb2xsaXNpb25zXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGNvbGxpc2lvbiByZXNvbHZlciBzZXBhcmF0aW9ucyBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd1NlcGFyYXRpb25zXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGJvZHkgYXhlcyBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd0F4ZXNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSBwb3NpdGlvbnMgZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dQb3NpdGlvbnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSBhbmdsZSBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd0FuZ2xlSW5kaWNhdG9yXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGJvZHkgYW5kIHBhcnQgaWRzIGRlYnVnIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93SWRzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGJvZHkgdmVydGV4IG51bWJlcnMgZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dWZXJ0ZXhOdW1iZXJzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGJvZHkgY29udmV4IGh1bGxzIGRlYnVnIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9ucy5zaG93Q29udmV4SHVsbHNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYm9keSBpbnRlcm5hbCBlZGdlcyBkZWJ1ZyBvdmVybGF5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG9wdGlvbnMuc2hvd0ludGVybmFsRWRnZXNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgZmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgbW91c2UgcG9zaXRpb24gZGVidWcgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zLnNob3dNb3VzZVBvc2l0aW9uXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuUnVubmVyYCBtb2R1bGUgaXMgYW4gb3B0aW9uYWwgdXRpbGl0eSB3aGljaCBwcm92aWRlcyBhIGdhbWUgbG9vcCwgXG4qIHRoYXQgaGFuZGxlcyBjb250aW51b3VzbHkgdXBkYXRpbmcgYSBgTWF0dGVyLkVuZ2luZWAgZm9yIHlvdSB3aXRoaW4gYSBicm93c2VyLlxuKiBJdCBpcyBpbnRlbmRlZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGRlYnVnZ2luZyBwdXJwb3NlcywgYnV0IG1heSBhbHNvIGJlIHN1aXRhYmxlIGZvciBzaW1wbGUgZ2FtZXMuXG4qIElmIHlvdSBhcmUgdXNpbmcgeW91ciBvd24gZ2FtZSBsb29wIGluc3RlYWQsIHRoZW4geW91IGRvIG5vdCBuZWVkIHRoZSBgTWF0dGVyLlJ1bm5lcmAgbW9kdWxlLlxuKiBJbnN0ZWFkIGp1c3QgY2FsbCBgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGRlbHRhKWAgaW4geW91ciBvd24gbG9vcC5cbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFJ1bm5lclxuKi9cblxudmFyIFJ1bm5lciA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcblxudmFyIEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgRW5naW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZTtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIV9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgdmFyIF9mcmFtZVRpbWVvdXQ7XG5cbiAgICAgICAgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKXsgXG4gICAgICAgICAgICBfZnJhbWVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soQ29tbW9uLm5vdygpKTsgXG4gICAgICAgICAgICB9LCAxMDAwIC8gNjApO1xuICAgICAgICB9O1xuXG4gICAgICAgIF9jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9mcmFtZVRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgUnVubmVyLiBUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGFueSBwcm9wZXJ0aWVzIHlvdSB3aXNoIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7fSBvcHRpb25zXG4gICAgICovXG4gICAgUnVubmVyLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgZnBzOiA2MCxcbiAgICAgICAgICAgIGRlbHRhU2FtcGxlU2l6ZTogNjAsXG4gICAgICAgICAgICBjb3VudGVyVGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgZnJhbWVDb3VudGVyOiAwLFxuICAgICAgICAgICAgZGVsdGFIaXN0b3J5OiBbXSxcbiAgICAgICAgICAgIHRpbWVQcmV2OiBudWxsLFxuICAgICAgICAgICAgZnJhbWVSZXF1ZXN0SWQ6IG51bGwsXG4gICAgICAgICAgICBpc0ZpeGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcnVubmVyID0gQ29tbW9uLmV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgcnVubmVyLmRlbHRhID0gcnVubmVyLmRlbHRhIHx8IDEwMDAgLyBydW5uZXIuZnBzO1xuICAgICAgICBydW5uZXIuZGVsdGFNaW4gPSBydW5uZXIuZGVsdGFNaW4gfHwgMTAwMCAvIHJ1bm5lci5mcHM7XG4gICAgICAgIHJ1bm5lci5kZWx0YU1heCA9IHJ1bm5lci5kZWx0YU1heCB8fCAxMDAwIC8gKHJ1bm5lci5mcHMgKiAwLjUpO1xuICAgICAgICBydW5uZXIuZnBzID0gMTAwMCAvIHJ1bm5lci5kZWx0YTtcblxuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250aW51b3VzbHkgdGlja3MgYSBgTWF0dGVyLkVuZ2luZWAgYnkgY2FsbGluZyBgUnVubmVyLnRpY2tgIG9uIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBldmVudC5cbiAgICAgKiBAbWV0aG9kIHJ1blxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cbiAgICBSdW5uZXIucnVuID0gZnVuY3Rpb24ocnVubmVyLCBlbmdpbmUpIHtcbiAgICAgICAgLy8gY3JlYXRlIHJ1bm5lciBpZiBlbmdpbmUgaXMgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgaWYgKHR5cGVvZiBydW5uZXIucG9zaXRpb25JdGVyYXRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZW5naW5lID0gcnVubmVyO1xuICAgICAgICAgICAgcnVubmVyID0gUnVubmVyLmNyZWF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgKGZ1bmN0aW9uIHJ1bih0aW1lKXtcbiAgICAgICAgICAgIHJ1bm5lci5mcmFtZVJlcXVlc3RJZCA9IF9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgJiYgcnVubmVyLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBSdW5uZXIudGljayhydW5uZXIsIGVuZ2luZSwgdGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBnYW1lIGxvb3AgdXRpbGl0eSB0aGF0IHVwZGF0ZXMgdGhlIGVuZ2luZSBhbmQgcmVuZGVyZXIgYnkgb25lIHN0ZXAgKGEgJ3RpY2snKS5cbiAgICAgKiBGZWF0dXJlcyBkZWx0YSBzbW9vdGhpbmcsIHRpbWUgY29ycmVjdGlvbiBhbmQgZml4ZWQgb3IgZHluYW1pYyB0aW1pbmcuXG4gICAgICogQ29uc2lkZXIganVzdCBgRW5naW5lLnVwZGF0ZShlbmdpbmUsIGRlbHRhKWAgaWYgeW91J3JlIHVzaW5nIHlvdXIgb3duIGxvb3AuXG4gICAgICogQG1ldGhvZCB0aWNrXG4gICAgICogQHBhcmFtIHtydW5uZXJ9IHJ1bm5lclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICAgICAqL1xuICAgIFJ1bm5lci50aWNrID0gZnVuY3Rpb24ocnVubmVyLCBlbmdpbmUsIHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWluZyA9IGVuZ2luZS50aW1pbmcsXG4gICAgICAgICAgICBkZWx0YTtcblxuICAgICAgICBpZiAocnVubmVyLmlzRml4ZWQpIHtcbiAgICAgICAgICAgIC8vIGZpeGVkIHRpbWVzdGVwXG4gICAgICAgICAgICBkZWx0YSA9IHJ1bm5lci5kZWx0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgdGltZXN0ZXAgYmFzZWQgb24gd2FsbCBjbG9jayBiZXR3ZWVuIGNhbGxzXG4gICAgICAgICAgICBkZWx0YSA9ICh0aW1lIC0gcnVubmVyLnRpbWVQcmV2KSB8fCBydW5uZXIuZGVsdGE7XG4gICAgICAgICAgICBydW5uZXIudGltZVByZXYgPSB0aW1lO1xuXG4gICAgICAgICAgICAvLyBvcHRpbWlzdGljYWxseSBmaWx0ZXIgZGVsdGEgb3ZlciBhIGZldyBmcmFtZXMsIHRvIGltcHJvdmUgc3RhYmlsaXR5XG4gICAgICAgICAgICBydW5uZXIuZGVsdGFIaXN0b3J5LnB1c2goZGVsdGEpO1xuICAgICAgICAgICAgcnVubmVyLmRlbHRhSGlzdG9yeSA9IHJ1bm5lci5kZWx0YUhpc3Rvcnkuc2xpY2UoLXJ1bm5lci5kZWx0YVNhbXBsZVNpemUpO1xuICAgICAgICAgICAgZGVsdGEgPSBNYXRoLm1pbi5hcHBseShudWxsLCBydW5uZXIuZGVsdGFIaXN0b3J5KTtcblxuICAgICAgICAgICAgLy8gbGltaXQgZGVsdGFcbiAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgPCBydW5uZXIuZGVsdGFNaW4gPyBydW5uZXIuZGVsdGFNaW4gOiBkZWx0YTtcbiAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgPiBydW5uZXIuZGVsdGFNYXggPyBydW5uZXIuZGVsdGFNYXggOiBkZWx0YTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGVuZ2luZSB0aW1pbmcgb2JqZWN0XG4gICAgICAgICAgICBydW5uZXIuZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBldmVudCBvYmplY3RcbiAgICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1pbmcudGltZXN0YW1wXG4gICAgICAgIH07XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYmVmb3JlVGljaycsIGV2ZW50KTtcblxuICAgICAgICAvLyBmcHMgY291bnRlclxuICAgICAgICBydW5uZXIuZnJhbWVDb3VudGVyICs9IDE7XG4gICAgICAgIGlmICh0aW1lIC0gcnVubmVyLmNvdW50ZXJUaW1lc3RhbXAgPj0gMTAwMCkge1xuICAgICAgICAgICAgcnVubmVyLmZwcyA9IHJ1bm5lci5mcmFtZUNvdW50ZXIgKiAoKHRpbWUgLSBydW5uZXIuY291bnRlclRpbWVzdGFtcCkgLyAxMDAwKTtcbiAgICAgICAgICAgIHJ1bm5lci5jb3VudGVyVGltZXN0YW1wID0gdGltZTtcbiAgICAgICAgICAgIHJ1bm5lci5mcmFtZUNvdW50ZXIgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAndGljaycsIGV2ZW50KTtcblxuICAgICAgICAvLyB1cGRhdGVcbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYmVmb3JlVXBkYXRlJywgZXZlbnQpO1xuXG4gICAgICAgIEVuZ2luZS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJVcGRhdGUnLCBldmVudCk7XG5cbiAgICAgICAgRXZlbnRzLnRyaWdnZXIocnVubmVyLCAnYWZ0ZXJUaWNrJywgZXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbmRzIGV4ZWN1dGlvbiBvZiBgUnVubmVyLnJ1bmAgb24gdGhlIGdpdmVuIGBydW5uZXJgLCBieSBjYW5jZWxpbmcgdGhlIGFuaW1hdGlvbiBmcmFtZSByZXF1ZXN0IGV2ZW50IGxvb3AuXG4gICAgICogSWYgeW91IHdpc2ggdG8gb25seSB0ZW1wb3JhcmlseSBwYXVzZSB0aGUgZW5naW5lLCBzZWUgYGVuZ2luZS5lbmFibGVkYCBpbnN0ZWFkLlxuICAgICAqIEBtZXRob2Qgc3RvcFxuICAgICAqIEBwYXJhbSB7cnVubmVyfSBydW5uZXJcbiAgICAgKi9cbiAgICBSdW5uZXIuc3RvcCA9IGZ1bmN0aW9uKHJ1bm5lcikge1xuICAgICAgICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUocnVubmVyLmZyYW1lUmVxdWVzdElkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGBSdW5uZXIucnVuYC5cbiAgICAgKiBAbWV0aG9kIHN0YXJ0XG4gICAgICogQHBhcmFtIHtydW5uZXJ9IHJ1bm5lclxuICAgICAqIEBwYXJhbSB7ZW5naW5lfSBlbmdpbmVcbiAgICAgKi9cbiAgICBSdW5uZXIuc3RhcnQgPSBmdW5jdGlvbihydW5uZXIsIGVuZ2luZSkge1xuICAgICAgICBSdW5uZXIucnVuKHJ1bm5lciwgZW5naW5lKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAqXG4gICAgKiAgRXZlbnRzIERvY3VtZW50YXRpb25cbiAgICAqXG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYXQgdGhlIHN0YXJ0IG9mIGEgdGljaywgYmVmb3JlIGFueSB1cGRhdGVzIHRvIHRoZSBlbmdpbmUgb3IgdGltaW5nXG4gICAgKlxuICAgICogQGV2ZW50IGJlZm9yZVRpY2tcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGFmdGVyIGVuZ2luZSB0aW1pbmcgdXBkYXRlZCwgYnV0IGp1c3QgYmVmb3JlIHVwZGF0ZVxuICAgICpcbiAgICAqIEBldmVudCB0aWNrXG4gICAgKiBAcGFyYW0ge30gZXZlbnQgQW4gZXZlbnQgb2JqZWN0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQudGltZXN0YW1wIFRoZSBlbmdpbmUudGltaW5nLnRpbWVzdGFtcCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5zb3VyY2UgVGhlIHNvdXJjZSBvYmplY3Qgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQubmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgKiBGaXJlZCBhdCB0aGUgZW5kIG9mIGEgdGljaywgYWZ0ZXIgZW5naW5lIHVwZGF0ZSBhbmQgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgKlxuICAgICogQGV2ZW50IGFmdGVyVGlja1xuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogRmlyZWQgYmVmb3JlIHVwZGF0ZVxuICAgICpcbiAgICAqIEBldmVudCBiZWZvcmVVcGRhdGVcbiAgICAqIEBwYXJhbSB7fSBldmVudCBBbiBldmVudCBvYmplY3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC50aW1lc3RhbXAgVGhlIGVuZ2luZS50aW1pbmcudGltZXN0YW1wIG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50LnNvdXJjZSBUaGUgc291cmNlIG9iamVjdCBvZiB0aGUgZXZlbnRcbiAgICAqIEBwYXJhbSB7fSBldmVudC5uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICovXG5cbiAgICAvKipcbiAgICAqIEZpcmVkIGFmdGVyIHVwZGF0ZVxuICAgICpcbiAgICAqIEBldmVudCBhZnRlclVwZGF0ZVxuICAgICogQHBhcmFtIHt9IGV2ZW50IEFuIGV2ZW50IG9iamVjdFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnRpbWVzdGFtcCBUaGUgZW5naW5lLnRpbWluZy50aW1lc3RhbXAgb2YgdGhlIGV2ZW50XG4gICAgKiBAcGFyYW0ge30gZXZlbnQuc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0IG9mIHRoZSBldmVudFxuICAgICogQHBhcmFtIHt9IGV2ZW50Lm5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAgKi9cblxuICAgIC8qXG4gICAgKlxuICAgICogIFByb3BlcnRpZXMgRG9jdW1lbnRhdGlvblxuICAgICpcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHJ1bm5lciBpcyBydW5uaW5nIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEEgYEJvb2xlYW5gIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBydW5uZXIgc2hvdWxkIHVzZSBhIGZpeGVkIHRpbWVzdGVwIChvdGhlcndpc2UgaXQgaXMgdmFyaWFibGUpLlxuICAgICAqIElmIHRpbWluZyBpcyBmaXhlZCwgdGhlbiB0aGUgYXBwYXJlbnQgc2ltdWxhdGlvbiBzcGVlZCB3aWxsIGNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGZyYW1lIHJhdGUgKGJ1dCBiZWhhdmlvdXIgd2lsbCBiZSBkZXRlcm1pbmlzdGljKS5cbiAgICAgKiBJZiB0aGUgdGltaW5nIGlzIHZhcmlhYmxlLCB0aGVuIHRoZSBhcHBhcmVudCBzaW11bGF0aW9uIHNwZWVkIHdpbGwgYmUgY29uc3RhbnQgKGFwcHJveGltYXRlbHksIGJ1dCBhdCB0aGUgY29zdCBvZiBkZXRlcm1pbmluaXNtKS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBpc0ZpeGVkXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBIGBOdW1iZXJgIHRoYXQgc3BlY2lmaWVzIHRoZSB0aW1lIHN0ZXAgYmV0d2VlbiB1cGRhdGVzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBJZiBgZW5naW5lLnRpbWluZy5pc0ZpeGVkYCBpcyBzZXQgdG8gYHRydWVgLCB0aGVuIGBkZWx0YWAgaXMgZml4ZWQuXG4gICAgICogSWYgaXQgaXMgYGZhbHNlYCwgdGhlbiBgZGVsdGFgIGNhbiBkeW5hbWljYWxseSBjaGFuZ2UgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgYXBwYXJlbnQgc2ltdWxhdGlvbiBzcGVlZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBkZWx0YVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDEwMDAgLyA2MFxuICAgICAqL1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4qIFRoaXMgbW9kdWxlIGhhcyBub3cgYmVlbiByZXBsYWNlZCBieSBgTWF0dGVyLkNvbGxpc2lvbmAuXG4qXG4qIEFsbCB1c2FnZSBzaG91bGQgYmUgbWlncmF0ZWQgdG8gYE1hdHRlci5Db2xsaXNpb25gLlxuKiBGb3IgYmFjay1jb21wYXRpYmlsaXR5IHB1cnBvc2VzIHRoaXMgbW9kdWxlIHdpbGwgcmVtYWluIGZvciBhIHNob3J0IHRlcm0gYW5kIHRoZW4gbGF0ZXIgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuKlxuKiBUaGUgYE1hdHRlci5TQVRgIG1vZHVsZSBjb250YWlucyBtZXRob2RzIGZvciBkZXRlY3RpbmcgY29sbGlzaW9ucyB1c2luZyB0aGUgU2VwYXJhdGluZyBBeGlzIFRoZW9yZW0uXG4qXG4qIEBjbGFzcyBTQVRcbiogQGRlcHJlY2F0ZWRcbiovXG5cbnZhciBTQVQgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBTQVQ7XG5cbnZhciBDb2xsaXNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIENvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgZGVwcmVjYXRlZCA9IENvbW1vbi5kZXByZWNhdGVkO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllcyB1c2luZyB0aGUgU2VwYXJhdGluZyBBeGlzIFRoZW9yZW0uXG4gICAgICogQGRlcHJlY2F0ZWQgcmVwbGFjZWQgYnkgQ29sbGlzaW9uLmNvbGxpZGVzXG4gICAgICogQG1ldGhvZCBjb2xsaWRlc1xuICAgICAqIEBwYXJhbSB7Ym9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge2JvZHl9IGJvZHlCXG4gICAgICogQHJldHVybiB7Y29sbGlzaW9ufSBjb2xsaXNpb25cbiAgICAgKi9cbiAgICBTQVQuY29sbGlkZXMgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpIHtcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbi5jb2xsaWRlcyhib2R5QSwgYm9keUIpO1xuICAgIH07XG5cbiAgICBkZXByZWNhdGVkKFNBVCwgJ2NvbGxpZGVzJywgJ1NBVC5jb2xsaWRlcyDinqQgcmVwbGFjZWQgYnkgQ29sbGlzaW9uLmNvbGxpZGVzJyk7XG5cbn0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhlIGBNYXR0ZXIuU3ZnYCBtb2R1bGUgY29udGFpbnMgbWV0aG9kcyBmb3IgY29udmVydGluZyBTVkcgaW1hZ2VzIGludG8gYW4gYXJyYXkgb2YgdmVjdG9yIHBvaW50cy5cbipcbiogVG8gdXNlIHRoaXMgbW9kdWxlIHlvdSBhbHNvIG5lZWQgdGhlIFNWR1BhdGhTZWcgcG9seWZpbGw6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9nZXJzL3BhdGhzZWdcbipcbiogU2VlIHRoZSBpbmNsdWRlZCB1c2FnZSBbZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWFicnUvbWF0dGVyLWpzL3RyZWUvbWFzdGVyL2V4YW1wbGVzKS5cbipcbiogQGNsYXNzIFN2Z1xuKi9cblxudmFyIFN2ZyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN2ZztcblxudmFyIEJvdW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgQ29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gU1ZHIHBhdGggaW50byBhbiBhcnJheSBvZiB2ZWN0b3IgcG9pbnRzLlxuICAgICAqIElmIHRoZSBpbnB1dCBwYXRoIGZvcm1zIGEgY29uY2F2ZSBzaGFwZSwgeW91IG11c3QgZGVjb21wb3NlIHRoZSByZXN1bHQgaW50byBjb252ZXggcGFydHMgYmVmb3JlIHVzZS5cbiAgICAgKiBTZWUgYEJvZGllcy5mcm9tVmVydGljZXNgIHdoaWNoIHByb3ZpZGVzIHN1cHBvcnQgZm9yIHRoaXMuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgbm90IGd1YXJhbnRlZWQgdG8gc3VwcG9ydCBjb21wbGV4IHBhdGhzIChzdWNoIGFzIHRob3NlIHdpdGggaG9sZXMpLlxuICAgICAqIFlvdSBtdXN0IGxvYWQgdGhlIGBwYXRoc2VnLmpzYCBwb2x5ZmlsbCBvbiBuZXdlciBicm93c2Vycy5cbiAgICAgKiBAbWV0aG9kIHBhdGhUb1ZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtTVkdQYXRoRWxlbWVudH0gcGF0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlTGVuZ3RoPTE1XVxuICAgICAqIEByZXR1cm4ge1ZlY3RvcltdfSBwb2ludHNcbiAgICAgKi9cbiAgICBTdmcucGF0aFRvVmVydGljZXMgPSBmdW5jdGlvbihwYXRoLCBzYW1wbGVMZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEoJ1NWR1BhdGhTZWcnIGluIHdpbmRvdykpIHtcbiAgICAgICAgICAgIENvbW1vbi53YXJuKCdTdmcucGF0aFRvVmVydGljZXM6IFNWR1BhdGhTZWcgbm90IGRlZmluZWQsIGEgcG9seWZpbGwgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd291dC9zdmcudG9wb2x5LmpzL2Jsb2IvbWFzdGVyL3N2Zy50b3BvbHkuanNcbiAgICAgICAgdmFyIGksIGlsLCB0b3RhbCwgcG9pbnQsIHNlZ21lbnQsIHNlZ21lbnRzLCBcbiAgICAgICAgICAgIHNlZ21lbnRzUXVldWUsIGxhc3RTZWdtZW50LCBcbiAgICAgICAgICAgIGxhc3RQb2ludCwgc2VnbWVudEluZGV4LCBwb2ludHMgPSBbXSxcbiAgICAgICAgICAgIGx4LCBseSwgbGVuZ3RoID0gMCwgeCA9IDAsIHkgPSAwO1xuXG4gICAgICAgIHNhbXBsZUxlbmd0aCA9IHNhbXBsZUxlbmd0aCB8fCAxNTtcblxuICAgICAgICB2YXIgYWRkUG9pbnQgPSBmdW5jdGlvbihweCwgcHksIHBhdGhTZWdUeXBlKSB7XG4gICAgICAgICAgICAvLyBhbGwgb2RkLW51bWJlcmVkIHBhdGggdHlwZXMgYXJlIHJlbGF0aXZlIGV4Y2VwdCBQQVRIU0VHX0NMT1NFUEFUSCAoMSlcbiAgICAgICAgICAgIHZhciBpc1JlbGF0aXZlID0gcGF0aFNlZ1R5cGUgJSAyID09PSAxICYmIHBhdGhTZWdUeXBlID4gMTtcblxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgbGFzdCBwb2ludCBkb2Vzbid0IGVxdWFsIHRoZSBjdXJyZW50IHBvaW50IGFkZCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgaWYgKCFsYXN0UG9pbnQgfHwgcHggIT0gbGFzdFBvaW50LnggfHwgcHkgIT0gbGFzdFBvaW50LnkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBvaW50ICYmIGlzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbHggPSBsYXN0UG9pbnQueDtcbiAgICAgICAgICAgICAgICAgICAgbHkgPSBsYXN0UG9pbnQueTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBseCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGx5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGx4ICsgcHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGx5ICsgcHlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGxhc3QgcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWxhdGl2ZSB8fCAhbGFzdFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcblxuICAgICAgICAgICAgICAgIHggPSBseCArIHB4O1xuICAgICAgICAgICAgICAgIHkgPSBseSArIHB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhZGRTZWdtZW50UG9pbnQgPSBmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgICAgICAgICB2YXIgc2VnVHlwZSA9IHNlZ21lbnQucGF0aFNlZ1R5cGVBc0xldHRlci50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICAvLyBza2lwIHBhdGggZW5kc1xuICAgICAgICAgICAgaWYgKHNlZ1R5cGUgPT09ICdaJykgXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBtYXAgc2VnbWVudCB0byB4IGFuZCB5XG4gICAgICAgICAgICBzd2l0Y2ggKHNlZ1R5cGUpIHtcblxuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgIHggPSBzZWdtZW50Lng7XG4gICAgICAgICAgICAgICAgeSA9IHNlZ21lbnQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgIHggPSBzZWdtZW50Lng7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICB5ID0gc2VnbWVudC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRQb2ludCh4LCB5LCBzZWdtZW50LnBhdGhTZWdUeXBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBlbnN1cmUgcGF0aCBpcyBhYnNvbHV0ZVxuICAgICAgICBTdmcuX3N2Z1BhdGhUb0Fic29sdXRlKHBhdGgpO1xuXG4gICAgICAgIC8vIGdldCB0b3RhbCBsZW5ndGhcbiAgICAgICAgdG90YWwgPSBwYXRoLmdldFRvdGFsTGVuZ3RoKCk7XG5cbiAgICAgICAgLy8gcXVldWUgc2VnbWVudHNcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdGgucGF0aFNlZ0xpc3QubnVtYmVyT2ZJdGVtczsgaSArPSAxKVxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChwYXRoLnBhdGhTZWdMaXN0LmdldEl0ZW0oaSkpO1xuXG4gICAgICAgIHNlZ21lbnRzUXVldWUgPSBzZWdtZW50cy5jb25jYXQoKTtcblxuICAgICAgICAvLyBzYW1wbGUgdGhyb3VnaCBwYXRoXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0b3RhbCkge1xuICAgICAgICAgICAgLy8gZ2V0IHNlZ21lbnQgYXQgcG9zaXRpb25cbiAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IHBhdGguZ2V0UGF0aFNlZ0F0TGVuZ3RoKGxlbmd0aCk7XG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcblxuICAgICAgICAgICAgLy8gbmV3IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChzZWdtZW50ICE9IGxhc3RTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlZ21lbnRzUXVldWUubGVuZ3RoICYmIHNlZ21lbnRzUXVldWVbMF0gIT0gc2VnbWVudClcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VnbWVudFBvaW50KHNlZ21lbnRzUXVldWUuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCBwb2ludHMgaW4gYmV0d2VlbiB3aGVuIGN1cnZpbmdcbiAgICAgICAgICAgIC8vIFRPRE86IGFkYXB0aXZlIHNhbXBsaW5nXG4gICAgICAgICAgICBzd2l0Y2ggKHNlZ21lbnQucGF0aFNlZ1R5cGVBc0xldHRlci50b1VwcGVyQ2FzZSgpKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwYXRoLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhZGRQb2ludChwb2ludC54LCBwb2ludC55LCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgYnkgc2FtcGxlIHZhbHVlXG4gICAgICAgICAgICBsZW5ndGggKz0gc2FtcGxlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyBzZWdtZW50cyBub3QgcGFzc2VkIGJ5IHNhbXBsaW5nXG4gICAgICAgIGZvciAoaSA9IDAsIGlsID0gc2VnbWVudHNRdWV1ZS5sZW5ndGg7IGkgPCBpbDsgKytpKVxuICAgICAgICAgICAgYWRkU2VnbWVudFBvaW50KHNlZ21lbnRzUXVldWVbaV0pO1xuXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfTtcblxuICAgIFN2Zy5fc3ZnUGF0aFRvQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9waHJvZ3oubmV0L2NvbnZlcnQtc3ZnLXBhdGgtdG8tYWxsLWFic29sdXRlLWNvbW1hbmRzXG4gICAgICAgIC8vIENvcHlyaWdodCAoYykgR2F2aW4gS2lzdG5lclxuICAgICAgICAvLyBodHRwOi8vcGhyb2d6Lm5ldC9qcy9fUmV1c2VMaWNlbnNlLnR4dFxuICAgICAgICAvLyBNb2RpZmljYXRpb25zOiB0aWR5IGZvcm1hdHRpbmcgYW5kIG5hbWluZ1xuICAgICAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHgyLCB5Miwgc2VncyA9IHBhdGgucGF0aFNlZ0xpc3QsXG4gICAgICAgICAgICB4ID0gMCwgeSA9IDAsIGxlbiA9IHNlZ3MubnVtYmVyT2ZJdGVtcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gc2Vncy5nZXRJdGVtKGkpLFxuICAgICAgICAgICAgICAgIHNlZ1R5cGUgPSBzZWcucGF0aFNlZ1R5cGVBc0xldHRlcjtcblxuICAgICAgICAgICAgaWYgKC9bTUxIVkNTUVRBXS8udGVzdChzZWdUeXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICgneCcgaW4gc2VnKSB4ID0gc2VnLng7XG4gICAgICAgICAgICAgICAgaWYgKCd5JyBpbiBzZWcpIHkgPSBzZWcueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCd4MScgaW4gc2VnKSB4MSA9IHggKyBzZWcueDE7XG4gICAgICAgICAgICAgICAgaWYgKCd4MicgaW4gc2VnKSB4MiA9IHggKyBzZWcueDI7XG4gICAgICAgICAgICAgICAgaWYgKCd5MScgaW4gc2VnKSB5MSA9IHkgKyBzZWcueTE7XG4gICAgICAgICAgICAgICAgaWYgKCd5MicgaW4gc2VnKSB5MiA9IHkgKyBzZWcueTI7XG4gICAgICAgICAgICAgICAgaWYgKCd4JyBpbiBzZWcpIHggKz0gc2VnLng7XG4gICAgICAgICAgICAgICAgaWYgKCd5JyBpbiBzZWcpIHkgKz0gc2VnLnk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlZ1R5cGUpIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ01vdmV0b0Ficyh4LCB5KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0Ficyh4LCB5KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxBYnMoeCksIGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFicyh5KSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0Ficyh4LCB5LCB4MSwgeTEsIHgyLCB5MiksIGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnMoeCwgeSwgeDIsIHkyKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNBYnMoeCwgeSwgeDEsIHkxKSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICBzZWdzLnJlcGxhY2VJdGVtKHBhdGguY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnMoeCwgeSksIGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5yZXBsYWNlSXRlbShwYXRoLmNyZWF0ZVNWR1BhdGhTZWdBcmNBYnMoeCwgeSwgc2VnLnIxLCBzZWcucjIsIHNlZy5hbmdsZSwgc2VnLmxhcmdlQXJjRmxhZywgc2VnLnN3ZWVwRmxhZyksIGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgwO1xuICAgICAgICAgICAgICAgICAgICB5ID0geTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VnVHlwZSA9PSAnTScgfHwgc2VnVHlwZSA9PSAnbScpIHtcbiAgICAgICAgICAgICAgICB4MCA9IHg7XG4gICAgICAgICAgICAgICAgeTAgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufSkoKTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiogVGhpcyBtb2R1bGUgaGFzIG5vdyBiZWVuIHJlcGxhY2VkIGJ5IGBNYXR0ZXIuQ29tcG9zaXRlYC5cbipcbiogQWxsIHVzYWdlIHNob3VsZCBiZSBtaWdyYXRlZCB0byB0aGUgZXF1aXZhbGVudCBmdW5jdGlvbnMgZm91bmQgb24gYE1hdHRlci5Db21wb3NpdGVgLlxuKiBGb3IgZXhhbXBsZSBgV29ybGQuYWRkKHdvcmxkLCBib2R5KWAgbm93IGJlY29tZXMgYENvbXBvc2l0ZS5hZGQod29ybGQsIGJvZHkpYC5cbipcbiogVGhlIHByb3BlcnR5IGB3b3JsZC5ncmF2aXR5YCBoYXMgYmVlbiBtb3ZlZCB0byBgZW5naW5lLmdyYXZpdHlgLlxuKlxuKiBGb3IgYmFjay1jb21wYXRpYmlsaXR5IHB1cnBvc2VzIHRoaXMgbW9kdWxlIHdpbGwgcmVtYWluIGFzIGEgZGlyZWN0IGFsaWFzIHRvIGBNYXR0ZXIuQ29tcG9zaXRlYCBpbiB0aGUgc2hvcnQgdGVybSBkdXJpbmcgbWlncmF0aW9uLlxuKiBFdmVudHVhbGx5IHRoaXMgYWxpYXMgbW9kdWxlIHdpbGwgYmUgbWFya2VkIGFzIGRlcHJlY2F0ZWQgYW5kIHRoZW4gbGF0ZXIgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuKlxuKiBAY2xhc3MgV29ybGRcbiovXG5cbnZhciBXb3JsZCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG52YXIgQ29tcG9zaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBDb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgYWJvdmUsIGFsaWFzZXMgZm9yIGJhY2sgY29tcGF0aWJpbGl0eSBvbmx5XG4gICAgICovXG4gICAgV29ybGQuY3JlYXRlID0gQ29tcG9zaXRlLmNyZWF0ZTtcbiAgICBXb3JsZC5hZGQgPSBDb21wb3NpdGUuYWRkO1xuICAgIFdvcmxkLnJlbW92ZSA9IENvbXBvc2l0ZS5yZW1vdmU7XG4gICAgV29ybGQuY2xlYXIgPSBDb21wb3NpdGUuY2xlYXI7XG4gICAgV29ybGQuYWRkQ29tcG9zaXRlID0gQ29tcG9zaXRlLmFkZENvbXBvc2l0ZTtcbiAgICBXb3JsZC5hZGRCb2R5ID0gQ29tcG9zaXRlLmFkZEJvZHk7XG4gICAgV29ybGQuYWRkQ29uc3RyYWludCA9IENvbXBvc2l0ZS5hZGRDb25zdHJhaW50O1xuXG59KSgpO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsInQiLCJtb2RlIiwiX19lc01vZHVsZSIsIm5zIiwiY3JlYXRlIiwia2V5IiwiYmluZCIsIm4iLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIkNvbW1vbiIsIl9iYXNlRGVsdGEiLCJfbmV4dElkIiwiX3NlZWQiLCJfbm93U3RhcnRUaW1lIiwiRGF0ZSIsIl93YXJuZWRPbmNlIiwiX2RlY29tcCIsImV4dGVuZCIsIm9iaiIsImRlZXAiLCJhcmdzU3RhcnQiLCJhcmdzIiwiZGVlcENsb25lIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwicHJvcCIsImNvbnN0cnVjdG9yIiwiY2xvbmUiLCJrZXlzIiwicHVzaCIsInZhbHVlcyIsInBhdGgiLCJiZWdpbiIsImVuZCIsInNwbGl0Iiwic2xpY2UiLCJzZXQiLCJ2YWwiLCJwYXJ0cyIsInNodWZmbGUiLCJhcnJheSIsImoiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0ZW1wIiwiY2hvb3NlIiwiY2hvaWNlcyIsImlzRWxlbWVudCIsIkhUTUxFbGVtZW50Iiwibm9kZVR5cGUiLCJub2RlTmFtZSIsImlzQXJyYXkiLCJ0b1N0cmluZyIsImlzRnVuY3Rpb24iLCJpc1BsYWluT2JqZWN0IiwiaXNTdHJpbmciLCJjbGFtcCIsIm1pbiIsIm1heCIsInNpZ24iLCJub3ciLCJ3aW5kb3ciLCJwZXJmb3JtYW5jZSIsIndlYmtpdE5vdyIsIl9zZWVkZWRSYW5kb20iLCJjb2xvclRvTnVtYmVyIiwiY29sb3JTdHJpbmciLCJyZXBsYWNlIiwiY2hhckF0IiwicGFyc2VJbnQiLCJsb2dMZXZlbCIsImxvZyIsImNvbnNvbGUiLCJhcHBseSIsImNvbmNhdCIsIkFycmF5IiwiaW5mbyIsIndhcm4iLCJ3YXJuT25jZSIsIm1lc3NhZ2UiLCJqb2luIiwiZGVwcmVjYXRlZCIsIndhcm5pbmciLCJjaGFpbiIsIm5leHRJZCIsImluZGV4T2YiLCJoYXlzdGFjayIsIm5lZWRsZSIsIm1hcCIsImxpc3QiLCJmdW5jIiwibWFwcGVkIiwidG9wb2xvZ2ljYWxTb3J0IiwiZ3JhcGgiLCJyZXN1bHQiLCJ2aXNpdGVkIiwibm9kZSIsIl90b3BvbG9naWNhbFNvcnQiLCJuZWlnaGJvcnMiLCJuZWlnaGJvciIsImZ1bmNzIiwiX2NoYWluZWQiLCJsYXN0UmVzdWx0IiwiY2hhaW5QYXRoQmVmb3JlIiwiYmFzZSIsImNoYWluUGF0aEFmdGVyIiwic2V0RGVjb21wIiwiZGVjb21wIiwiZ2V0RGVjb21wIiwiZ2xvYmFsIiwiZSIsIkJvdW5kcyIsInZlcnRpY2VzIiwiYm91bmRzIiwieCIsInkiLCJ1cGRhdGUiLCJ2ZWxvY2l0eSIsIkluZmluaXR5IiwidmVydGV4IiwiY29udGFpbnMiLCJwb2ludCIsIm92ZXJsYXBzIiwiYm91bmRzQSIsImJvdW5kc0IiLCJ0cmFuc2xhdGUiLCJ2ZWN0b3IiLCJzaGlmdCIsInBvc2l0aW9uIiwiZGVsdGFYIiwiZGVsdGFZIiwiVmVjdG9yIiwibWFnbml0dWRlIiwic3FydCIsIm1hZ25pdHVkZVNxdWFyZWQiLCJyb3RhdGUiLCJhbmdsZSIsIm91dHB1dCIsImNvcyIsInNpbiIsInJvdGF0ZUFib3V0Iiwibm9ybWFsaXNlIiwiZG90IiwidmVjdG9yQSIsInZlY3RvckIiLCJjcm9zcyIsImNyb3NzMyIsInZlY3RvckMiLCJhZGQiLCJzdWIiLCJtdWx0Iiwic2NhbGFyIiwiZGl2IiwicGVycCIsIm5lZ2F0ZSIsIm5lZyIsImF0YW4yIiwiX3RlbXAiLCJWZXJ0aWNlcyIsInBvaW50cyIsImJvZHkiLCJpbmRleCIsImlzSW50ZXJuYWwiLCJmcm9tUGF0aCIsInBhdGhQYXR0ZXJuIiwibWF0Y2giLCJwYXJzZUZsb2F0IiwiY2VudHJlIiwiYXJlYSIsIm1lYW4iLCJhdmVyYWdlIiwic2lnbmVkIiwiYWJzIiwiaW5lcnRpYSIsIm1hc3MiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsInYiLCJ2ZXJ0aWNlc0xlbmd0aCIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwicG9pbnRYIiwicG9pbnRZIiwiZHgiLCJkeSIsIm5leHRWZXJ0ZXgiLCJzY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsImRlbHRhIiwiY2hhbWZlciIsInJhZGl1cyIsInF1YWxpdHkiLCJxdWFsaXR5TWluIiwicXVhbGl0eU1heCIsIm5ld1ZlcnRpY2VzIiwicHJldlZlcnRleCIsImN1cnJlbnRSYWRpdXMiLCJwcmV2Tm9ybWFsIiwibmV4dE5vcm1hbCIsImRpYWdvbmFsUmFkaXVzIiwicG93IiwicmFkaXVzVmVjdG9yIiwibWlkTm9ybWFsIiwic2NhbGVkVmVydGV4IiwicHJlY2lzaW9uIiwiYWxwaGEiLCJhY29zIiwidGhldGEiLCJjbG9ja3dpc2VTb3J0Iiwic29ydCIsInZlcnRleEEiLCJ2ZXJ0ZXhCIiwiaXNDb252ZXgiLCJmbGFnIiwiayIsInoiLCJodWxsIiwidXBwZXIiLCJsb3dlciIsInBvcCIsIkJvZHkiLCJTbGVlcGluZyIsIkF4ZXMiLCJfdGltZUNvcnJlY3Rpb24iLCJfaW5lcnRpYVNjYWxlIiwiX25leHRDb2xsaWRpbmdHcm91cElkIiwiX25leHROb25Db2xsaWRpbmdHcm91cElkIiwiX25leHRDYXRlZ29yeSIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsImlkIiwidHlwZSIsImxhYmVsIiwicGx1Z2luIiwiZm9yY2UiLCJ0b3JxdWUiLCJwb3NpdGlvbkltcHVsc2UiLCJjb25zdHJhaW50SW1wdWxzZSIsInRvdGFsQ29udGFjdHMiLCJzcGVlZCIsImFuZ3VsYXJTcGVlZCIsImFuZ3VsYXJWZWxvY2l0eSIsImlzU2Vuc29yIiwiaXNTdGF0aWMiLCJpc1NsZWVwaW5nIiwibW90aW9uIiwic2xlZXBUaHJlc2hvbGQiLCJkZW5zaXR5IiwicmVzdGl0dXRpb24iLCJmcmljdGlvbiIsImZyaWN0aW9uU3RhdGljIiwiZnJpY3Rpb25BaXIiLCJjb2xsaXNpb25GaWx0ZXIiLCJjYXRlZ29yeSIsIm1hc2siLCJncm91cCIsInNsb3AiLCJ0aW1lU2NhbGUiLCJyZW5kZXIiLCJ2aXNpYmxlIiwib3BhY2l0eSIsInN0cm9rZVN0eWxlIiwiZmlsbFN0eWxlIiwibGluZVdpZHRoIiwic3ByaXRlIiwieFNjYWxlIiwieVNjYWxlIiwieE9mZnNldCIsInlPZmZzZXQiLCJldmVudHMiLCJjaXJjbGVSYWRpdXMiLCJwb3NpdGlvblByZXYiLCJhbmdsZVByZXYiLCJwYXJlbnQiLCJheGVzIiwiZGVsdGFUaW1lIiwiX29yaWdpbmFsIiwiX2luaXRQcm9wZXJ0aWVzIiwibmV4dEdyb3VwIiwiaXNOb25Db2xsaWRpbmciLCJuZXh0Q2F0ZWdvcnkiLCJkZWZhdWx0RmlsbFN0eWxlIiwiZGVmYXVsdFN0cm9rZVN0eWxlIiwiZGVmYXVsdExpbmVXaWR0aCIsInNldHRpbmdzIiwic2V0U3RhdGljIiwic2V0TWFzcyIsInNldERlbnNpdHkiLCJzZXRJbmVydGlhIiwic2V0VmVydGljZXMiLCJzZXRQb3NpdGlvbiIsInNldEFuZ2xlIiwic2V0VmVsb2NpdHkiLCJzZXRBbmd1bGFyVmVsb2NpdHkiLCJzZXRTcGVlZCIsInNldEFuZ3VsYXJTcGVlZCIsInNldFBhcnRzIiwic2V0Q2VudHJlIiwicGFydCIsImludmVyc2VNYXNzIiwiaW52ZXJzZUluZXJ0aWEiLCJtb21lbnQiLCJmcm9tVmVydGljZXMiLCJhdXRvSHVsbCIsImh1bGxDZW50cmUiLCJ0b3RhbCIsIl90b3RhbFByb3BlcnRpZXMiLCJyZWxhdGl2ZSIsInVwZGF0ZVZlbG9jaXR5IiwiZ2V0VmVsb2NpdHkiLCJnZXRTcGVlZCIsImdldEFuZ3VsYXJWZWxvY2l0eSIsImdldEFuZ3VsYXJTcGVlZCIsInRyYW5zbGF0aW9uIiwicm90YXRpb24iLCJ0b3RhbEFyZWEiLCJ0b3RhbEluZXJ0aWEiLCJkZWx0YVRpbWVTcXVhcmVkIiwiY29ycmVjdGlvbiIsInZlbG9jaXR5UHJldlgiLCJ2ZWxvY2l0eVByZXZZIiwidXBkYXRlVmVsb2NpdGllcyIsImJvZHlWZWxvY2l0eSIsImFwcGx5Rm9yY2UiLCJvZmZzZXQiLCJwcm9wZXJ0aWVzIiwiRXZlbnRzIiwib24iLCJldmVudE5hbWVzIiwiY2FsbGJhY2siLCJuYW1lcyIsIm9mZiIsImNhbGxiYWNrcyIsIm5ld0NhbGxiYWNrcyIsInRyaWdnZXIiLCJldmVudCIsImV2ZW50Q2xvbmUiLCJDb21wb3NpdGUiLCJpc01vZGlmaWVkIiwiYm9kaWVzIiwiY29uc3RyYWludHMiLCJjb21wb3NpdGVzIiwiY2FjaGUiLCJhbGxCb2RpZXMiLCJhbGxDb25zdHJhaW50cyIsImFsbENvbXBvc2l0ZXMiLCJzZXRNb2RpZmllZCIsImNvbXBvc2l0ZSIsInVwZGF0ZVBhcmVudHMiLCJ1cGRhdGVDaGlsZHJlbiIsImNoaWxkQ29tcG9zaXRlIiwib2JqZWN0cyIsImFkZEJvZHkiLCJhZGRDb25zdHJhaW50IiwiYWRkQ29tcG9zaXRlIiwiY29uc3RyYWludCIsInJlbW92ZSIsInJlbW92ZUJvZHkiLCJyZW1vdmVDb25zdHJhaW50IiwicmVtb3ZlQ29tcG9zaXRlIiwiY29tcG9zaXRlQSIsImNvbXBvc2l0ZUIiLCJyZW1vdmVDb21wb3NpdGVBdCIsInNwbGljZSIsInJlbW92ZUJvZHlBdCIsInJlbW92ZUNvbnN0cmFpbnRBdCIsImNsZWFyIiwia2VlcFN0YXRpYyIsImZpbHRlciIsIm1vdmUiLCJyZWJhc2UiLCJyZWN1cnNpdmUiLCJfbW90aW9uV2FrZVRocmVzaG9sZCIsIl9tb3Rpb25TbGVlcFRocmVzaG9sZCIsIl9taW5CaWFzIiwibW90aW9uU2xlZXBUaHJlc2hvbGQiLCJtaW5Nb3Rpb24iLCJtYXhNb3Rpb24iLCJzbGVlcENvdW50ZXIiLCJhZnRlckNvbGxpc2lvbnMiLCJwYWlycyIsInBhaXIiLCJpc0FjdGl2ZSIsImNvbGxpc2lvbiIsImJvZHlBIiwiYm9keUIiLCJzbGVlcGluZ0JvZHkiLCJtb3ZpbmdCb2R5Iiwid2FzU2xlZXBpbmciLCJDb2xsaXNpb24iLCJQYWlyIiwiX3N1cHBvcnRzIiwiX292ZXJsYXBBQiIsIm92ZXJsYXAiLCJheGlzIiwiX292ZXJsYXBCQSIsImNvbGxpZGVkIiwicGFyZW50QSIsInBhcmVudEIiLCJkZXB0aCIsIm5vcm1hbCIsInRhbmdlbnQiLCJwZW5ldHJhdGlvbiIsInN1cHBvcnRzIiwiY29sbGlkZXMiLCJfb3ZlcmxhcEF4ZXMiLCJ0YWJsZSIsIm1pbk92ZXJsYXAiLCJtaW5BeGlzIiwibWluQXhpc1giLCJtaW5BeGlzWSIsInN1cHBvcnRzQiIsIl9maW5kU3VwcG9ydHMiLCJzdXBwb3J0Q291bnQiLCJzdXBwb3J0c0EiLCJ2ZXJ0aWNlc0EiLCJ2ZXJ0aWNlc0IiLCJ2ZXJ0aWNlc0FMZW5ndGgiLCJ2ZXJ0aWNlc0JMZW5ndGgiLCJ2ZXJ0aWNlc0FYIiwidmVydGljZXNBWSIsInZlcnRpY2VzQlgiLCJ2ZXJ0aWNlc0JZIiwiYXhlc0xlbmd0aCIsIm92ZXJsYXBNaW4iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJvdmVybGFwQXhpc051bWJlciIsIm92ZXJsYXBBQiIsIm92ZXJsYXBCQSIsImF4aXNYIiwiYXhpc1kiLCJtaW5BIiwibWluQiIsIm1heEEiLCJtYXhCIiwiX3Byb2plY3RUb0F4aXMiLCJwcm9qZWN0aW9uIiwiZGlyZWN0aW9uIiwiYm9keUFQb3NpdGlvblgiLCJib2R5QVBvc2l0aW9uWSIsIm5vcm1hbFgiLCJub3JtYWxZIiwibmVhcmVzdERpc3RhbmNlIiwidmVydGV4QyIsImRpc3RhbmNlIiwiQ29udGFjdCIsInRpbWVzdGFtcCIsImNvbnRhY3RzIiwiYWN0aXZlQ29udGFjdHMiLCJzZXBhcmF0aW9uIiwiY29uZmlybWVkQWN0aXZlIiwidGltZUNyZWF0ZWQiLCJ0aW1lVXBkYXRlZCIsInBhcmVudEFWZXJ0aWNlc0xlbmd0aCIsInN1cHBvcnQiLCJjb250YWN0SWQiLCJjb250YWN0Iiwic2V0QWN0aXZlIiwiQ29uc3RyYWludCIsIl93YXJtaW5nIiwiX3RvcnF1ZURhbXBlbiIsIl9taW5MZW5ndGgiLCJwb2ludEEiLCJwb2ludEIiLCJpbml0aWFsUG9pbnRBIiwiaW5pdGlhbFBvaW50QiIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJhbmd1bGFyU3RpZmZuZXNzIiwiYW5nbGVBIiwiYW5nbGVCIiwiYW5jaG9ycyIsInByZVNvbHZlQWxsIiwiaW1wdWxzZSIsInNvbHZlQWxsIiwiZml4ZWRBIiwiZml4ZWRCIiwic29sdmUiLCJwb2ludEFXb3JsZCIsInBvaW50QldvcmxkIiwiY3VycmVudExlbmd0aCIsImRpZmZlcmVuY2UiLCJpc1JpZ2lkIiwibWFzc1RvdGFsIiwiaW5lcnRpYVRvdGFsIiwicmVzaXN0YW5jZVRvdGFsIiwic2hhcmUiLCJub3JtYWxWZWxvY2l0eSIsInJlbGF0aXZlVmVsb2NpdHkiLCJ6ZXJvIiwicG9zdFNvbHZlQWxsIiwiZ3JhZGllbnQiLCJ0b0ZpeGVkIiwieHgiLCJCb2RpZXMiLCJyZWN0YW5nbGUiLCJ3aWR0aCIsImhlaWdodCIsInRyYXBlem9pZCIsInNsb3BlIiwicm9vZiIsIngxIiwieDIiLCJ4MyIsInZlcnRpY2VzUGF0aCIsImNpcmNsZSIsIm1heFNpZGVzIiwic2lkZXMiLCJjZWlsIiwicG9seWdvbiIsIlBJIiwieXkiLCJ2ZXJ0ZXhTZXRzIiwiZmxhZ0ludGVybmFsIiwicmVtb3ZlQ29sbGluZWFyIiwibWluaW11bUFyZWEiLCJyZW1vdmVEdXBsaWNhdGVQb2ludHMiLCJjYW5EZWNvbXAiLCJpc0NvbmNhdmUiLCJCb29sZWFuIiwicXVpY2tEZWNvbXAiLCJjb25jYXZlIiwibWFrZUNDVyIsInJlbW92ZUNvbGxpbmVhclBvaW50cyIsImRlY29tcG9zZWQiLCJjaHVuayIsImNodW5rVmVydGljZXMiLCJjb2luY2lkZW50X21heF9kaXN0IiwicGFydEEiLCJwYXJ0QiIsInBhdiIsInBidiIsImRhIiwiZGIiLCJEZXRlY3RvciIsInNldEJvZGllcyIsImRldGVjdG9yIiwiY29sbGlzaW9ucyIsImJvZGllc0xlbmd0aCIsImNhbkNvbGxpZGUiLCJfY29tcGFyZUJvdW5kc1giLCJib3VuZFhNYXgiLCJib3VuZFlNYXgiLCJib3VuZFlNaW4iLCJib2R5QVN0YXRpYyIsInBhcnRzQUxlbmd0aCIsInBhcnRzQVNpbmdsZSIsInBhcnRzQkxlbmd0aCIsInBhcnRzQVN0YXJ0IiwicGFydHNCU3RhcnQiLCJmaWx0ZXJBIiwiZmlsdGVyQiIsIk1vdXNlIiwiZWxlbWVudCIsIm1vdXNlIiwiZG9jdW1lbnQiLCJhYnNvbHV0ZSIsIm1vdXNlZG93blBvc2l0aW9uIiwibW91c2V1cFBvc2l0aW9uIiwid2hlZWxEZWx0YSIsImJ1dHRvbiIsInBpeGVsUmF0aW8iLCJnZXRBdHRyaWJ1dGUiLCJzb3VyY2VFdmVudHMiLCJtb3VzZW1vdmUiLCJtb3VzZWRvd24iLCJtb3VzZXVwIiwibW91c2V3aGVlbCIsIl9nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb24iLCJ0b3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJwcmV2ZW50RGVmYXVsdCIsImRldGFpbCIsInNldEVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xlYXJTb3VyY2VFdmVudHMiLCJzZXRPZmZzZXQiLCJzZXRTY2FsZSIsImVsZW1lbnRCb3VuZHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyb290Tm9kZSIsImRvY3VtZW50RWxlbWVudCIsInBhcmVudE5vZGUiLCJzY3JvbGxYIiwicGFnZVhPZmZzZXQiLCJ1bmRlZmluZWQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVgiLCJsZWZ0IiwicGFnZVkiLCJ0b3AiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIlBsdWdpbiIsIl9yZWdpc3RyeSIsInJlZ2lzdGVyIiwiaXNQbHVnaW4iLCJyZWdpc3RlcmVkIiwicGx1Z2luVmVyc2lvbiIsInZlcnNpb25QYXJzZSIsInZlcnNpb24iLCJudW1iZXIiLCJyZWdpc3RlcmVkVmVyc2lvbiIsInJlc29sdmUiLCJkZXBlbmRlbmN5IiwiZGVwZW5kZW5jeVBhcnNlIiwicmFuZ2UiLCJpbnN0YWxsIiwiaXNVc2VkIiwidXNlZCIsImlzRm9yIiwicGFyc2VkIiwiZm9yIiwidmVyc2lvblNhdGlzZmllcyIsInVzZSIsInBsdWdpbnMiLCJ1c2VzIiwiZGVwZW5kZW5jaWVzIiwic29ydGVkRGVwZW5kZW5jaWVzIiwic3RhdHVzIiwiX3dhcm5lZCIsInRyYWNrZWQiLCJwYXJzZWRCYXNlIiwicmVzb2x2ZWQiLCJwYXR0ZXJuIiwidGVzdCIsImV4ZWMiLCJtYWpvciIsIm1pbm9yIiwicGF0Y2giLCJpc1JhbmdlIiwib3BlcmF0b3IiLCJwcmVyZWxlYXNlIiwibm9ybWFsSW1wdWxzZSIsInRhbmdlbnRJbXB1bHNlIiwiRW5naW5lIiwiUmVzb2x2ZXIiLCJQYWlycyIsInBvc2l0aW9uSXRlcmF0aW9ucyIsInZlbG9jaXR5SXRlcmF0aW9ucyIsImNvbnN0cmFpbnRJdGVyYXRpb25zIiwiZW5hYmxlU2xlZXBpbmciLCJncmF2aXR5IiwidGltaW5nIiwibGFzdERlbHRhIiwibGFzdEVsYXBzZWQiLCJlbmdpbmUiLCJ3b3JsZCIsImdyaWQiLCJidWNrZXRzIiwiYnJvYWRwaGFzZSIsIm1ldHJpY3MiLCJzdGFydFRpbWUiLCJfYm9kaWVzQXBwbHlHcmF2aXR5IiwiX2JvZGllc1VwZGF0ZSIsImNvbGxpc2lvblN0YXJ0IiwicG9zaXRpb25EYW1waW5nIiwicHJlU29sdmVQb3NpdGlvbiIsInNvbHZlUG9zaXRpb24iLCJwb3N0U29sdmVQb3NpdGlvbiIsInByZVNvbHZlVmVsb2NpdHkiLCJzb2x2ZVZlbG9jaXR5IiwiX2JvZGllc1VwZGF0ZVZlbG9jaXRpZXMiLCJjb2xsaXNpb25BY3RpdmUiLCJjb2xsaXNpb25FbmQiLCJfYm9kaWVzQ2xlYXJGb3JjZXMiLCJtZXJnZSIsImVuZ2luZUEiLCJlbmdpbmVCIiwiZ3Jhdml0eVNjYWxlIiwiX3Jlc3RpbmdUaHJlc2giLCJfcmVzdGluZ1RocmVzaFRhbmdlbnQiLCJfcG9zaXRpb25EYW1wZW4iLCJfcG9zaXRpb25XYXJtaW5nIiwiX2ZyaWN0aW9uTm9ybWFsTXVsdGlwbGllciIsIl9mcmljdGlvbk1heFN0YXRpYyIsImFjdGl2ZUNvdW50IiwicGFpcnNMZW5ndGgiLCJjb250YWN0U2hhcmUiLCJwb3NpdGlvbkRhbXBlbiIsInNsb3BEYW1wZW4iLCJwb3NpdGlvbldhcm1pbmciLCJ2ZXJ0aWNlc1RyYW5zbGF0ZSIsImJvdW5kc1VwZGF0ZSIsInBvc2l0aW9uSW1wdWxzZVgiLCJwb3NpdGlvbkltcHVsc2VZIiwiY29udGFjdHNMZW5ndGgiLCJjb250YWN0VmVydGV4IiwiaW1wdWxzZVgiLCJpbXB1bHNlWSIsInRpbWVTY2FsZVNxdWFyZWQiLCJ0aW1lU2NhbGVDdWJlZCIsInJlc3RpbmdUaHJlc2giLCJyZXN0aW5nVGhyZXNoVGFuZ2VudCIsImZyaWN0aW9uTm9ybWFsTXVsdGlwbGllciIsImZyaWN0aW9uTWF4U3RhdGljIiwibWF4RnJpY3Rpb24iLCJib2R5QVZlbG9jaXR5IiwiYm9keUJWZWxvY2l0eSIsInRhbmdlbnRYIiwidGFuZ2VudFkiLCJpbnZlcnNlTWFzc1RvdGFsIiwib2Zmc2V0QVgiLCJvZmZzZXRBWSIsIm9mZnNldEJYIiwib2Zmc2V0QlkiLCJ2ZWxvY2l0eVBvaW50QVgiLCJ2ZWxvY2l0eVBvaW50QVkiLCJ2ZWxvY2l0eVBvaW50QlgiLCJ2ZWxvY2l0eVBvaW50QlkiLCJyZWxhdGl2ZVZlbG9jaXR5WCIsInJlbGF0aXZlVmVsb2NpdHlZIiwidGFuZ2VudFZlbG9jaXR5Iiwibm9ybWFsT3ZlcmxhcCIsIm5vcm1hbEZvcmNlIiwiZnJpY3Rpb25MaW1pdCIsIm9BY04iLCJvQmNOIiwiY29udGFjdE5vcm1hbEltcHVsc2UiLCJjb250YWN0VGFuZ2VudEltcHVsc2UiLCJwYWlyc0xpc3QiLCJwYWlyc0xpc3RMZW5ndGgiLCJwYWlyc1RhYmxlIiwiY29sbGlzaW9uc0xlbmd0aCIsInBhaXJJbmRleCIsInJlbW92ZVBhaXJJbmRleCIsIk1hdHRlciIsIkNvbXBvc2l0ZXMiLCJHcmlkIiwiTW91c2VDb25zdHJhaW50IiwiUXVlcnkiLCJSZW5kZXIiLCJSdW5uZXIiLCJTQVQiLCJTdmciLCJXb3JsZCIsInJ1biIsImJlZm9yZSIsImFmdGVyIiwic3RhY2siLCJjb2x1bW5zIiwicm93cyIsImNvbHVtbkdhcCIsInJvd0dhcCIsImxhc3RCb2R5Iiwicm93IiwibWF4SGVpZ2h0IiwiY29sdW1uIiwiYm9keUhlaWdodCIsImJvZHlXaWR0aCIsInhPZmZzZXRBIiwieU9mZnNldEEiLCJ4T2Zmc2V0QiIsInlPZmZzZXRCIiwiYm9keUFIZWlnaHQiLCJib2R5QVdpZHRoIiwiYm9keUJIZWlnaHQiLCJib2R5QldpZHRoIiwibWVzaCIsImNyb3NzQnJhY2UiLCJjb2wiLCJib2R5QyIsInB5cmFtaWQiLCJhY3R1YWxSb3dzIiwibGFzdEJvZHlXaWR0aCIsInN0YXJ0IiwibmV3dG9uc0NyYWRsZSIsInNpemUiLCJjYXIiLCJ3aGVlbFNpemUiLCJ3aGVlbEJhc2UiLCJ3aGVlbEFPZmZzZXQiLCJ3aGVlbEJPZmZzZXQiLCJ3aGVlbFlPZmZzZXQiLCJ3aGVlbEEiLCJ3aGVlbEIiLCJheGVsQSIsImF4ZWxCIiwic29mdEJvZHkiLCJwYXJ0aWNsZVJhZGl1cyIsInBhcnRpY2xlT3B0aW9ucyIsImNvbnN0cmFpbnRPcHRpb25zIiwiYnVja2V0V2lkdGgiLCJidWNrZXRIZWlnaHQiLCJmb3JjZVVwZGF0ZSIsImJ1Y2tldCIsImJ1Y2tldElkIiwiZ3JpZENoYW5nZWQiLCJuZXdSZWdpb24iLCJfZ2V0UmVnaW9uIiwicmVnaW9uIiwidW5pb24iLCJfcmVnaW9uVW5pb24iLCJzdGFydENvbCIsImVuZENvbCIsInN0YXJ0Um93IiwiZW5kUm93IiwiX2dldEJ1Y2tldElkIiwiaXNJbnNpZGVOZXdSZWdpb24iLCJpc0luc2lkZU9sZFJlZ2lvbiIsIl9idWNrZXRSZW1vdmVCb2R5IiwiX2NyZWF0ZUJ1Y2tldCIsIl9idWNrZXRBZGRCb2R5IiwiX2NyZWF0ZUFjdGl2ZVBhaXJzTGlzdCIsInJlZ2lvbkEiLCJyZWdpb25CIiwiX2NyZWF0ZVJlZ2lvbiIsImdyaWRQYWlycyIsInBhaXJJZCIsImJ1Y2tldExlbmd0aCIsInBhaXJLZXlzIiwicGFpcktleXNMZW5ndGgiLCJjYW52YXMiLCJtb3VzZUNvbnN0cmFpbnQiLCJfdHJpZ2dlckV2ZW50cyIsIm1vdXNlRXZlbnRzIiwicmF5Iiwic3RhcnRQb2ludCIsImVuZFBvaW50IiwicmF5V2lkdGgiLCJyYXlBbmdsZSIsInJheUxlbmd0aCIsInJheVgiLCJyYXlZIiwib3V0c2lkZSIsIl9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJfY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIiwid2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJtc0NhbmNlbEFuaW1hdGlvbkZyYW1lIiwiX2dvb2RGcHMiLCJfZ29vZERlbHRhIiwiZnJhbWVSZXF1ZXN0SWQiLCJoaXN0b3J5U2l6ZSIsImRlbHRhSGlzdG9yeSIsImxhc3RUaW1lIiwibGFzdFRpbWVzdGFtcCIsInRpbWVzdGFtcEVsYXBzZWQiLCJ0aW1lc3RhbXBFbGFwc2VkSGlzdG9yeSIsImVuZ2luZURlbHRhSGlzdG9yeSIsImVuZ2luZUVsYXBzZWRIaXN0b3J5IiwiZWxhcHNlZEhpc3RvcnkiLCJiYWNrZ3JvdW5kIiwid2lyZWZyYW1lQmFja2dyb3VuZCIsImhhc0JvdW5kcyIsImVuYWJsZWQiLCJ3aXJlZnJhbWVzIiwic2hvd1NsZWVwaW5nIiwic2hvd0RlYnVnIiwic2hvd1N0YXRzIiwic2hvd1BlcmZvcm1hbmNlIiwic2hvd0JvdW5kcyIsInNob3dWZWxvY2l0eSIsInNob3dDb2xsaXNpb25zIiwic2hvd1NlcGFyYXRpb25zIiwic2hvd0F4ZXMiLCJzaG93UG9zaXRpb25zIiwic2hvd0FuZ2xlSW5kaWNhdG9yIiwic2hvd0lkcyIsInNob3dWZXJ0ZXhOdW1iZXJzIiwic2hvd0NvbnZleEh1bGxzIiwic2hvd0ludGVybmFsRWRnZXMiLCJzaG93TW91c2VQb3NpdGlvbiIsIl9jcmVhdGVDYW52YXMiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsInRleHR1cmVzIiwiY29udHJvbGxlciIsInNob3dCcm9hZHBoYXNlIiwic2V0UGl4ZWxSYXRpbyIsImFwcGVuZENoaWxkIiwibG9vcCIsInRpbWUiLCJfdXBkYXRlVGltaW5nIiwic3RhdHMiLCJzdG9wIiwiX2dldFBpeGVsUmF0aW8iLCJzZXRBdHRyaWJ1dGUiLCJzdHlsZSIsImxvb2tBdCIsInBhZGRpbmciLCJjZW50ZXIiLCJ2aWV3SGVpZ2h0Iiwidmlld1dpZHRoIiwib3V0ZXJSYXRpbyIsImlubmVyUmF0aW8iLCJzdGFydFZpZXdUcmFuc2Zvcm0iLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsImJvdW5kc1NjYWxlWCIsImJvdW5kc1NjYWxlWSIsInNldFRyYW5zZm9ybSIsImVuZFZpZXdUcmFuc2Zvcm0iLCJjdXJyZW50QmFja2dyb3VuZCIsIl9hcHBseUJhY2tncm91bmQiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJmaWxsUmVjdCIsImJvZHlDb252ZXhIdWxscyIsImJvZHlXaXJlZnJhbWVzIiwiYm9keUJvdW5kcyIsImJvZHlBeGVzIiwiYm9keVBvc2l0aW9ucyIsImJvZHlJZHMiLCJzZXBhcmF0aW9ucyIsInZlcnRleE51bWJlcnMiLCJtb3VzZVBvc2l0aW9uIiwic2VjdGlvbnMiLCJmb250IiwidGV4dEJhc2VsaW5lIiwidGV4dEFsaWduIiwic2VjdGlvbiIsImZpbGxUZXh0IiwibGFzdEVuZ2luZURlbHRhIiwiZGVsdGFNZWFuIiwiX21lYW4iLCJlbGFwc2VkTWVhbiIsImVuZ2luZURlbHRhTWVhbiIsImVuZ2luZUVsYXBzZWRNZWFuIiwidGltZXN0YW1wRWxhcHNlZE1lYW4iLCJyYXRlTWVhbiIsImZwcyIsImdyYXBoSGVpZ2h0IiwiZ2FwIiwicm91bmQiLCJjb3VudCIsImluZGljYXRvciIsInBsb3RZIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlIiwiYXJjIiwiY2xvc2VQYXRoIiwiY29pbHMiLCJmaWxsIiwiZ2xvYmFsQWxwaGEiLCJ0ZXh0dXJlIiwiX2dldFRleHR1cmUiLCJkcmF3SW1hZ2UiLCJyZWN0IiwiY29ycmVjdGVkIiwibm9ybWFsUG9zWCIsIm5vcm1hbFBvc1kiLCJpbnNwZWN0b3IiLCJzZWxlY3RlZCIsIml0ZW0iLCJkYXRhIiwic2V0TGluZURhc2giLCJzZWxlY3RTdGFydCIsInNlbGVjdEJvdW5kcyIsInVuc2hpZnQiLCJjcmVhdGVFbGVtZW50Iiwib25jb250ZXh0bWVudSIsIm9uc2VsZWN0c3RhcnQiLCJkZXZpY2VQaXhlbFJhdGlvIiwiYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwibXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwib0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJpbWFnZVBhdGgiLCJpbWFnZSIsIkltYWdlIiwic3JjIiwiY3NzQmFja2dyb3VuZCIsImJhY2tncm91bmRTaXplIiwiX2ZyYW1lVGltZW91dCIsImNsZWFyVGltZW91dCIsImRlbHRhU2FtcGxlU2l6ZSIsImNvdW50ZXJUaW1lc3RhbXAiLCJmcmFtZUNvdW50ZXIiLCJ0aW1lUHJldiIsImlzRml4ZWQiLCJydW5uZXIiLCJkZWx0YU1pbiIsImRlbHRhTWF4IiwidGljayIsInBhdGhUb1ZlcnRpY2VzIiwic2FtcGxlTGVuZ3RoIiwiaWwiLCJzZWdtZW50Iiwic2VnbWVudHMiLCJzZWdtZW50c1F1ZXVlIiwibGFzdFNlZ21lbnQiLCJsYXN0UG9pbnQiLCJzZWdtZW50SW5kZXgiLCJseCIsImx5IiwiYWRkUG9pbnQiLCJweCIsInB5IiwicGF0aFNlZ1R5cGUiLCJpc1JlbGF0aXZlIiwiYWRkU2VnbWVudFBvaW50Iiwic2VnVHlwZSIsInBhdGhTZWdUeXBlQXNMZXR0ZXIiLCJ0b1VwcGVyQ2FzZSIsIl9zdmdQYXRoVG9BYnNvbHV0ZSIsImdldFRvdGFsTGVuZ3RoIiwicGF0aFNlZ0xpc3QiLCJudW1iZXJPZkl0ZW1zIiwiZ2V0SXRlbSIsImdldFBhdGhTZWdBdExlbmd0aCIsImdldFBvaW50QXRMZW5ndGgiLCJ4MCIsInkwIiwieTEiLCJ5MiIsInNlZ3MiLCJsZW4iLCJzZWciLCJyZXBsYWNlSXRlbSIsImNyZWF0ZVNWR1BhdGhTZWdNb3ZldG9BYnMiLCJjcmVhdGVTVkdQYXRoU2VnTGluZXRvQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxBYnMiLCJjcmVhdGVTVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnMiLCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aEFicyIsImNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzIiwiY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnMiLCJjcmVhdGVTVkdQYXRoU2VnQXJjQWJzIiwicjEiLCJyMiIsImxhcmdlQXJjRmxhZyIsInN3ZWVwRmxhZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/matter-js@0.19.0/node_modules/matter-js/build/matter.js\n");

/***/ })

};
;